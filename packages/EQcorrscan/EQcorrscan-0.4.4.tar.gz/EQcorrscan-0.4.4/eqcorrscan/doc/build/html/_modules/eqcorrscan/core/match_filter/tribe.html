<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>eqcorrscan.core.match_filter.tribe &#8212; EQcorrscan 0.4.3 documentation</title>
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../../_static/EQcorrscan_logo.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html"><span><img src="../../../../_static/EQcorrscan_logo.jpg"></span>
          EQcorrscan</a>
        <span class="navbar-text navbar-version pull-left"><b>0.4</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro.html">1. Introduction to the EQcorrscan package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">2. EQcorrscan installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../updates.html">3. Whatâ€™s new</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">4. EQcorrscan tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">5. EQcorrscan API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for eqcorrscan.core.match_filter.tribe</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for network matched-filter detection of seismic data.</span>

<span class="sd">Designed to cross-correlate templates generated by template_gen function</span>
<span class="sd">with data and output the detections.</span>

<span class="sd">:copyright:</span>
<span class="sd">    EQcorrscan developers.</span>

<span class="sd">:license:</span>
<span class="sd">    GNU Lesser General Public License, Version 3</span>
<span class="sd">    (https://www.gnu.org/copyleft/lesser.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tarfile</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">Catalog</span><span class="p">,</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">read_events</span>
<span class="kn">from</span> <span class="nn">obspy.core.event</span> <span class="kn">import</span> <span class="n">Comment</span><span class="p">,</span> <span class="n">CreationInfo</span>

<span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter.template</span> <span class="kn">import</span> <span class="n">Template</span><span class="p">,</span> <span class="n">group_templates</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter.party</span> <span class="kn">import</span> <span class="n">Party</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter.helpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_safemembers</span><span class="p">,</span> <span class="n">_par_read</span><span class="p">,</span> <span class="n">get_waveform_client</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter.matched_filter</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_group_detect</span><span class="p">,</span> <span class="n">MatchFilterError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.core</span> <span class="kn">import</span> <span class="n">template_gen</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.utils.pre_processing</span> <span class="kn">import</span> <span class="n">_check_daylong</span>

<span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Tribe"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe">[docs]</a><span class="k">class</span> <span class="nc">Tribe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holder for multiple templates.</span>

<span class="sd">    :type templates: List of Template</span>
<span class="sd">    :param templates: The templates within the Tribe.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Tribe.__init__"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">templates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">Template</span><span class="p">):</span>
            <span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">templates</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">templates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">templates</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print information about the tribe.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; print(tribe)</span>
<span class="sd">        Tribe of 1 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;Tribe of </span><span class="si">%i</span><span class="s1"> templates&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two Tribes or a Tribe and a Template together. &#39;+&#39;</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_ab = tribe + Tribe(templates=[Template(name=&#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; print(tribe_ab)</span>
<span class="sd">        Tribe of 2 templates</span>
<span class="sd">        &gt;&gt;&gt; tribe_abc = tribe_ab + Template(name=&#39;c&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(tribe_abc)</span>
<span class="sd">        Tribe of 3 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add in place: &#39;+=&#39;</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe += Tribe(templates=[Template(name=&#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; print(tribe)</span>
<span class="sd">        Tribe of 2 templates</span>
<span class="sd">        &gt;&gt;&gt; tribe += Template(name=&#39;c&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(tribe)</span>
<span class="sd">        Tribe of 3 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tribe</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">templates</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Template</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must be either Template or Tribe&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for equality. Rich comparison operator &#39;==&#39;</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe_a = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_b = Tribe(templates=[Template(name=&#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_a == tribe_b</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; tribe_a == tribe_a</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">templates</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for inequality. Rich comparison operator &#39;!=&#39;</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe_a = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_b = Tribe(templates=[Template(name=&#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_a != tribe_b</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; tribe_a != tribe_a</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of Templates in Tribe. len(tribe)</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe_a = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; len(tribe_a)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator for the Tribe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Support slicing to get Templates from Tribe.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;a&#39;), Template(name=&#39;b&#39;),</span>
<span class="sd">        ...                          Template(name=&#39;c&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe[1] # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Template b:</span>
<span class="sd">         0 channels;</span>
<span class="sd">         lowcut: None Hz;</span>
<span class="sd">         highcut: None Hz;</span>
<span class="sd">         sampling rate None Hz;</span>
<span class="sd">         filter order: None;</span>
<span class="sd">         process length: None s</span>
<span class="sd">        &gt;&gt;&gt; tribe[0:2]</span>
<span class="sd">        Tribe of 2 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">templates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span>
                      <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Template: </span><span class="si">%s</span><span class="s1"> not in tribe&#39;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="Tribe.sort"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the tribe, sorts by template name.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;c&#39;), Template(name=&#39;b&#39;),</span>
<span class="sd">        ...                          Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe.sort()</span>
<span class="sd">        Tribe of 3 templates</span>
<span class="sd">        &gt;&gt;&gt; tribe[0] # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Template a:</span>
<span class="sd">         0 channels;</span>
<span class="sd">         lowcut: None Hz;</span>
<span class="sd">         highcut: None Hz;</span>
<span class="sd">         sampling rate None Hz;</span>
<span class="sd">         filter order: None;</span>
<span class="sd">         process length: None s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Tribe.select"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select a particular template from the tribe.</span>

<span class="sd">        :type template_name: str</span>
<span class="sd">        :param template_name: Template name to look-up</span>
<span class="sd">        :return: Template</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;c&#39;), Template(name=&#39;b&#39;),</span>
<span class="sd">        ...                          Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe.select(&#39;b&#39;) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Template b:</span>
<span class="sd">         0 channels;</span>
<span class="sd">         lowcut: None Hz;</span>
<span class="sd">         highcut: None Hz;</span>
<span class="sd">         sampling rate None Hz;</span>
<span class="sd">         filter order: None;</span>
<span class="sd">         process length: None s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">template_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Tribe.remove"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a template from the tribe.</span>

<span class="sd">        :type template: :class:`eqcorrscan.core.match_filter.Template`</span>
<span class="sd">        :param template: Template to remove from tribe</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;c&#39;), Template(name=&#39;b&#39;),</span>
<span class="sd">        ...                          Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe.remove(tribe.templates[0])</span>
<span class="sd">        Tribe of 2 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">template</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Tribe.copy"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the Tribe.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe_a = Tribe(templates=[Template(name=&#39;a&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; tribe_b = tribe_a.copy()</span>
<span class="sd">        &gt;&gt;&gt; tribe_a == tribe_b</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tribe.write"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">catalog_format</span><span class="o">=</span><span class="s2">&quot;QUAKEML&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the tribe to a file using tar archive formatting.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename:</span>
<span class="sd">            Filename to write to, if it exists it will be appended to.</span>
<span class="sd">        :type compress: bool</span>
<span class="sd">        :param compress:</span>
<span class="sd">            Whether to compress the tar archive or not, if False then will</span>
<span class="sd">            just be files in a folder.</span>
<span class="sd">        :type catalog_format: str</span>
<span class="sd">        :param catalog_format:</span>
<span class="sd">            What format to write the detection-catalog with. Only Nordic,</span>
<span class="sd">            SC3ML, QUAKEML are supported. Note that not all information is</span>
<span class="sd">            written for all formats (QUAKEML is the most complete, but is</span>
<span class="sd">            slow for IO).</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;c&#39;, st=read())])</span>
<span class="sd">        &gt;&gt;&gt; tribe.write(&#39;test_tribe&#39;)</span>
<span class="sd">        Tribe of 1 templates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter</span> <span class="kn">import</span> <span class="n">CAT_EXT_MAP</span>

        <span class="k">if</span> <span class="n">catalog_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">CAT_EXT_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">catalog_format</span><span class="p">))</span>
        <span class="n">dirname</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_write</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="n">tribe_cat</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Check that the name in the comment matches the template name</span>
                <span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">comments</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">comment</span><span class="o">.</span><span class="n">text</span> <span class="ow">and</span> <span class="n">comment</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span>
                            <span class="s2">&quot;eqcorrscan_template_&quot;</span><span class="p">):</span>
                        <span class="n">comment</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;eqcorrscan_template_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">tribe_cat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tribe_cat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tribe_cat</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;tribe_cat.</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">CAT_EXT_MAP</span><span class="p">[</span><span class="n">catalog_format</span><span class="p">])),</span> <span class="nb">format</span><span class="o">=</span><span class="n">catalog_format</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">template</span><span class="o">.</span><span class="n">st</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">.ms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">name</span><span class="p">)),</span>
                <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;MSEED&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compress</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.tgz&quot;</span><span class="p">):</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Appending &#39;.tgz&#39; to filename.&quot;</span><span class="p">)</span>
                <span class="n">filename</span> <span class="o">+=</span> <span class="s2">&quot;.tgz&quot;</span>
            <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w:gz&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
                <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">arcname</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">dirname</span><span class="p">))</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_par_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal write function to write a formatted parameter file.</span>

<span class="sd">        :type dirname: str</span>
<span class="sd">        :param dirname: Directory to write the parameter file to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">dirname</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="s1">&#39;template_parameters.csv&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">parfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;st&#39;</span><span class="p">,</span> <span class="s1">&#39;event&#39;</span><span class="p">]:</span>
                        <span class="n">parfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="p">)</span>
                <span class="n">parfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Tribe.read"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a tribe of templates from a tar formatted file.</span>

<span class="sd">        :type filename: str</span>
<span class="sd">        :param filename: File to read templates from.</span>

<span class="sd">        .. rubric:: Example</span>

<span class="sd">        &gt;&gt;&gt; tribe = Tribe(templates=[Template(name=&#39;c&#39;, st=read())])</span>
<span class="sd">        &gt;&gt;&gt; tribe.write(&#39;test_tribe&#39;)</span>
<span class="sd">        Tribe of 1 templates</span>
<span class="sd">        &gt;&gt;&gt; tribe_back = Tribe().read(&#39;test_tribe.tgz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; tribe_back == tribe</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r:*&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">arc</span><span class="p">:</span>
            <span class="n">temp_dir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
            <span class="n">arc</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">temp_dir</span><span class="p">,</span> <span class="n">members</span><span class="o">=</span><span class="n">_safemembers</span><span class="p">(</span><span class="n">arc</span><span class="p">))</span>
            <span class="n">tribe_dir</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">temp_dir</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_from_folder</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">tribe_dir</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_read_from_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal folder reader.</span>

<span class="sd">        :type dirname: str</span>
<span class="sd">        :param dirname: Folder to read from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates</span> <span class="o">=</span> <span class="n">_par_read</span><span class="p">(</span><span class="n">dirname</span><span class="o">=</span><span class="n">dirname</span><span class="p">,</span> <span class="n">compressed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">t_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">dirname</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> <span class="s1">&#39;*.ms&#39;</span><span class="p">)</span>
        <span class="n">tribe_cat_file</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="s2">&quot;tribe_cat.*&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tribe_cat_file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tribe_cat</span> <span class="o">=</span> <span class="n">read_events</span><span class="p">(</span><span class="n">tribe_cat_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tribe_cat</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">()</span>
        <span class="n">previous_template_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">previous_template_names</span><span class="p">:</span>
                <span class="c1"># Don&#39;t read in for templates that we already have.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">tribe_cat</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">event</span><span class="o">.</span><span class="n">comments</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">comment</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;eqcorrscan_template_&#39;</span> <span class="o">+</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="n">template</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>
            <span class="n">t_file</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_files</span>
                      <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.ms&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_file</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No waveform for template: &#39;</span> <span class="o">+</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">templates</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_file</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Multiple waveforms found, using: &#39;</span> <span class="o">+</span> <span class="n">t_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">template</span><span class="o">.</span><span class="n">st</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">t_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">templates</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="Tribe.cluster"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cluster the tribe.</span>

<span class="sd">        Cluster templates within a tribe: returns multiple tribes each of</span>
<span class="sd">        which could be stacked.</span>

<span class="sd">        :type method: str</span>
<span class="sd">        :param method:</span>
<span class="sd">            Method of stacking, see :mod:`eqcorrscan.utils.clustering`</span>

<span class="sd">        :return: List of tribes.</span>

<span class="sd">        .. rubric:: Example</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="kn">import</span> <span class="n">clustering</span>
        <span class="n">tribes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">clustering</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;space_cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;space_time_cluster&#39;</span><span class="p">]:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="n">Catalog</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">event</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">new_tribe</span> <span class="o">=</span> <span class="n">Tribe</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">new_tribe</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span>
                                                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">event</span><span class="p">])</span>
                <span class="n">tribes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tribe</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tribes</span></div>

<div class="viewcode-block" id="Tribe.detect"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.detect">[docs]</a>    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">threshold_type</span><span class="p">,</span> <span class="n">trig_int</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">plotdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">daylong</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_process</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">xcorr_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">concurrency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">ignore_length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_bad_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">overlap</span><span class="o">=</span><span class="s2">&quot;calculate&quot;</span><span class="p">,</span> <span class="n">full_peaks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">process_cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect using a Tribe of templates within a continuous stream.</span>

<span class="sd">        :type stream: `obspy.core.stream.Stream`</span>
<span class="sd">        :param stream: Continuous data to detect within using the Template.</span>
<span class="sd">        :type threshold: float</span>
<span class="sd">        :param threshold:</span>
<span class="sd">            Threshold level, if using `threshold_type=&#39;MAD&#39;` then this will be</span>
<span class="sd">            the multiple of the median absolute deviation.</span>
<span class="sd">        :type threshold_type: str</span>
<span class="sd">        :param threshold_type:</span>
<span class="sd">            The type of threshold to be used, can be MAD, absolute or</span>
<span class="sd">            av_chan_corr.  See Note on thresholding below.</span>
<span class="sd">        :type trig_int: float</span>
<span class="sd">        :param trig_int:</span>
<span class="sd">            Minimum gap between detections from one template in seconds.</span>
<span class="sd">            If multiple detections occur within trig_int of one-another, the</span>
<span class="sd">            one with the highest cross-correlation sum will be selected.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :param plot: Turn plotting on or off.</span>
<span class="sd">        :type plotdir: str</span>
<span class="sd">        :param plotdir:</span>
<span class="sd">            The path to save plots to. If `plotdir=None` (default) then the</span>
<span class="sd">            figure will be shown on screen.</span>
<span class="sd">        :type daylong: bool</span>
<span class="sd">        :param daylong:</span>
<span class="sd">            Set to True to use the</span>
<span class="sd">            :func:`eqcorrscan.utils.pre_processing.dayproc` routine, which</span>
<span class="sd">            preforms additional checks and is more efficient for day-long data</span>
<span class="sd">            over other methods.</span>
<span class="sd">        :type parallel_process: bool</span>
<span class="sd">        :param parallel_process:</span>
<span class="sd">        :type xcorr_func: str or callable</span>
<span class="sd">        :param xcorr_func:</span>
<span class="sd">            A str of a registered xcorr function or a callable for implementing</span>
<span class="sd">            a custom xcorr function. For more information see:</span>
<span class="sd">            :func:`eqcorrscan.utils.correlate.register_array_xcorr`</span>
<span class="sd">        :type concurrency: str</span>
<span class="sd">        :param concurrency:</span>
<span class="sd">            The type of concurrency to apply to the xcorr function. Options are</span>
<span class="sd">            &#39;multithread&#39;, &#39;multiprocess&#39;, &#39;concurrent&#39;. For more details see</span>
<span class="sd">            :func:`eqcorrscan.utils.correlate.get_stream_xcorr`</span>
<span class="sd">        :type cores: int</span>
<span class="sd">        :param cores: Number of workers for procesisng and detection.</span>
<span class="sd">        :type ignore_length: bool</span>
<span class="sd">        :param ignore_length:</span>
<span class="sd">            If using daylong=True, then dayproc will try check that the data</span>
<span class="sd">            are there for at least 80% of the day, if you don&#39;t want this check</span>
<span class="sd">            (which will raise an error if too much data are missing) then set</span>
<span class="sd">            ignore_length=True.  This is not recommended!</span>
<span class="sd">        :type ignore_bad_data: bool</span>
<span class="sd">        :param ignore_bad_data:</span>
<span class="sd">            If False (default), errors will be raised if data are excessively</span>
<span class="sd">            gappy or are mostly zeros. If True then no error will be raised,</span>
<span class="sd">            but an empty trace will be returned (and not used in detection).</span>
<span class="sd">        :type group_size: int</span>
<span class="sd">        :param group_size:</span>
<span class="sd">            Maximum number of templates to run at once, use to reduce memory</span>
<span class="sd">            consumption, if unset will use all templates.</span>
<span class="sd">        :type overlap: float</span>
<span class="sd">        :param overlap:</span>
<span class="sd">            Either None, &quot;calculate&quot; or a float of number of seconds to</span>
<span class="sd">            overlap detection streams by.  This is to counter the effects of</span>
<span class="sd">            the delay-and-stack in calculating cross-correlation sums. Setting</span>
<span class="sd">            overlap = &quot;calculate&quot; will work out the appropriate overlap based</span>
<span class="sd">            on the maximum lags within templates.</span>
<span class="sd">        :type full_peaks: bool</span>
<span class="sd">        :param full_peaks: See `eqcorrscan.utils.findpeak.find_peaks2_short`</span>
<span class="sd">        :type save_progress: bool</span>
<span class="sd">        :param save_progress:</span>
<span class="sd">            Whether to save the resulting party at every data step or not.</span>
<span class="sd">            Useful for long-running processes.</span>
<span class="sd">        :type process_cores: int</span>
<span class="sd">        :param process_cores:</span>
<span class="sd">            Number of processes to use for pre-processing (if different to</span>
<span class="sd">            `cores`).</span>

<span class="sd">        :return:</span>
<span class="sd">            :class:`eqcorrscan.core.match_filter.Party` of Families of</span>
<span class="sd">            detections.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            When using the &quot;fftw&quot; correlation backend the length of the fft</span>
<span class="sd">            can be set. See :mod:`eqcorrscan.utils.correlate` for more info.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            `stream` must not be pre-processed. If your data contain gaps</span>
<span class="sd">            you should *NOT* fill those gaps before using this method.</span>
<span class="sd">            The pre-process functions (called within) will fill the gaps</span>
<span class="sd">            internally prior to processing, process the data, then re-fill</span>
<span class="sd">            the gaps with zeros to ensure correlations are not incorrectly</span>
<span class="sd">            calculated within gaps. If your data have gaps you should pass a</span>
<span class="sd">            merged stream without the `fill_value` argument</span>
<span class="sd">            (e.g.: `stream = stream.merge()`).</span>

<span class="sd">        .. note::</span>
<span class="sd">            **Data overlap:**</span>

<span class="sd">            Internally this routine shifts and trims the data according to the</span>
<span class="sd">            offsets in the template (e.g. if trace 2 starts 2 seconds after</span>
<span class="sd">            trace 1 in the template then the continuous data will be shifted</span>
<span class="sd">            by 2 seconds to align peak correlations prior to summing).</span>
<span class="sd">            Because of this, detections at the start and end of continuous</span>
<span class="sd">            data streams **may be missed**.  The maximum time-period that</span>
<span class="sd">            might be missing detections is the maximum offset in the template.</span>

<span class="sd">            To work around this, if you are conducting matched-filter</span>
<span class="sd">            detections through long-duration continuous data, we suggest</span>
<span class="sd">            using some overlap (a few seconds, on the order of the maximum</span>
<span class="sd">            offset in the templates) in the continuous data.  You will then</span>
<span class="sd">            need to post-process the detections (which should be done anyway</span>
<span class="sd">            to remove duplicates).  See below note for how `overlap` argument</span>
<span class="sd">            affects data internally if `stream` is longer than the processing</span>
<span class="sd">            length.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            If `stream` is longer than processing length, this routine will</span>
<span class="sd">            ensure that data overlap between loops, which will lead to no</span>
<span class="sd">            missed detections at data start-stop points (see above note).</span>
<span class="sd">            This will result in end-time not being strictly</span>
<span class="sd">            honoured, so detections may occur after the end-time set.  This is</span>
<span class="sd">            because data must be run in the correct process-length.</span>

<span class="sd">        .. note::</span>
<span class="sd">            **Thresholding:**</span>

<span class="sd">            **MAD** threshold is calculated as the:</span>

<span class="sd">            .. math::</span>

<span class="sd">                threshold {\\times} (median(abs(cccsum)))</span>

<span class="sd">            where :math:`cccsum` is the cross-correlation sum for a given</span>
<span class="sd">            template.</span>

<span class="sd">            **absolute** threshold is a true absolute threshold based on the</span>
<span class="sd">            cccsum value.</span>

<span class="sd">            **av_chan_corr** is based on the mean values of single-channel</span>
<span class="sd">            cross-correlations assuming all data are present as required for</span>
<span class="sd">            the template, e.g:</span>

<span class="sd">            .. math::</span>

<span class="sd">                av\_chan\_corr\_thresh=threshold \\times (cccsum /</span>
<span class="sd">                len(template))</span>

<span class="sd">            where :math:`template` is a single template from the input and the</span>
<span class="sd">            length is the number of channels within this template.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">party</span> <span class="o">=</span> <span class="n">Party</span><span class="p">()</span>
        <span class="n">template_groups</span> <span class="o">=</span> <span class="n">group_templates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">)</span>
        <span class="c1"># now we can compute the detections for each group</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">template_groups</span><span class="p">:</span>
            <span class="n">group_party</span> <span class="o">=</span> <span class="n">_group_detect</span><span class="p">(</span>
                <span class="n">templates</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                <span class="n">threshold_type</span><span class="o">=</span><span class="n">threshold_type</span><span class="p">,</span> <span class="n">trig_int</span><span class="o">=</span><span class="n">trig_int</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">group_size</span><span class="o">=</span><span class="n">group_size</span><span class="p">,</span> <span class="n">pre_processed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">daylong</span><span class="o">=</span><span class="n">daylong</span><span class="p">,</span> <span class="n">parallel_process</span><span class="o">=</span><span class="n">parallel_process</span><span class="p">,</span>
                <span class="n">xcorr_func</span><span class="o">=</span><span class="n">xcorr_func</span><span class="p">,</span> <span class="n">concurrency</span><span class="o">=</span><span class="n">concurrency</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span>
                <span class="n">ignore_length</span><span class="o">=</span><span class="n">ignore_length</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="n">plotdir</span><span class="p">,</span>
                <span class="n">full_peaks</span><span class="o">=</span><span class="n">full_peaks</span><span class="p">,</span> <span class="n">process_cores</span><span class="o">=</span><span class="n">process_cores</span><span class="p">,</span>
                <span class="n">ignore_bad_data</span><span class="o">=</span><span class="n">ignore_bad_data</span><span class="p">,</span> <span class="n">arg_check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">party</span> <span class="o">+=</span> <span class="n">group_party</span>
            <span class="k">if</span> <span class="n">save_progress</span><span class="p">:</span>
                <span class="n">party</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;eqcorrscan_temporary_party&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">party</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">family</span> <span class="ow">in</span> <span class="n">party</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">family</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">family</span><span class="o">.</span><span class="n">detections</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">_uniq</span><span class="p">()</span><span class="o">.</span><span class="n">detections</span>
        <span class="k">return</span> <span class="n">party</span></div>

<div class="viewcode-block" id="Tribe.client_detect"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.client_detect">[docs]</a>    <span class="k">def</span> <span class="nf">client_detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                      <span class="n">threshold_type</span><span class="p">,</span> <span class="n">trig_int</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">min_gap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">daylong</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_process</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">xcorr_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">concurrency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">ignore_length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_bad_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">group_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_stream</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_peaks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">save_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process_cores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect using a Tribe of templates within a continuous stream.</span>

<span class="sd">        :type client: `obspy.clients.*.Client`</span>
<span class="sd">        :param client: Any obspy client with a dataselect service.</span>
<span class="sd">        :type starttime: :class:`obspy.core.UTCDateTime`</span>
<span class="sd">        :param starttime: Start-time for detections.</span>
<span class="sd">        :type endtime: :class:`obspy.core.UTCDateTime`</span>
<span class="sd">        :param endtime: End-time for detections</span>
<span class="sd">        :type threshold: float</span>
<span class="sd">        :param threshold:</span>
<span class="sd">            Threshold level, if using `threshold_type=&#39;MAD&#39;` then this will be</span>
<span class="sd">            the multiple of the median absolute deviation.</span>
<span class="sd">        :type threshold_type: str</span>
<span class="sd">        :param threshold_type:</span>
<span class="sd">            The type of threshold to be used, can be MAD, absolute or</span>
<span class="sd">            av_chan_corr.  See Note on thresholding below.</span>
<span class="sd">        :type trig_int: float</span>
<span class="sd">        :param trig_int:</span>
<span class="sd">            Minimum gap between detections from one template in seconds.</span>
<span class="sd">            If multiple detections occur within trig_int of one-another, the</span>
<span class="sd">            one with the highest cross-correlation sum will be selected.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :param plot: Turn plotting on or off.</span>
<span class="sd">        :type plotdir: str</span>
<span class="sd">        :param plotdir:</span>
<span class="sd">            The path to save plots to. If `plotdir=None` (default) then the</span>
<span class="sd">            figure will be shown on screen.</span>
<span class="sd">        :type min_gap: float</span>
<span class="sd">        :param min_gap:</span>
<span class="sd">            Minimum gap allowed in data - use to remove traces with known</span>
<span class="sd">            issues</span>
<span class="sd">        :type daylong: bool</span>
<span class="sd">        :param daylong:</span>
<span class="sd">            Set to True to use the</span>
<span class="sd">            :func:`eqcorrscan.utils.pre_processing.dayproc` routine, which</span>
<span class="sd">            preforms additional checks and is more efficient for day-long data</span>
<span class="sd">            over other methods.</span>
<span class="sd">        :type parallel_process: bool</span>
<span class="sd">        :param parallel_process:</span>
<span class="sd">        :type xcorr_func: str or callable</span>
<span class="sd">        :param xcorr_func:</span>
<span class="sd">            A str of a registered xcorr function or a callable for implementing</span>
<span class="sd">            a custom xcorr function. For more information see:</span>
<span class="sd">            :func:`eqcorrscan.utils.correlate.register_array_xcorr`</span>
<span class="sd">        :type concurrency: str</span>
<span class="sd">        :param concurrency:</span>
<span class="sd">            The type of concurrency to apply to the xcorr function. Options are</span>
<span class="sd">            &#39;multithread&#39;, &#39;multiprocess&#39;, &#39;concurrent&#39;. For more details see</span>
<span class="sd">            :func:`eqcorrscan.utils.correlate.get_stream_xcorr`</span>
<span class="sd">        :type cores: int</span>
<span class="sd">        :param cores: Number of workers for processing and detection.</span>
<span class="sd">        :type ignore_length: bool</span>
<span class="sd">        :param ignore_length:</span>
<span class="sd">            If using daylong=True, then dayproc will try check that the data</span>
<span class="sd">            are there for at least 80% of the day, if you don&#39;t want this check</span>
<span class="sd">            (which will raise an error if too much data are missing) then set</span>
<span class="sd">            ignore_length=True.  This is not recommended!</span>
<span class="sd">        :type ignore_bad_data: bool</span>
<span class="sd">        :param ignore_bad_data:</span>
<span class="sd">            If False (default), errors will be raised if data are excessively</span>
<span class="sd">            gappy or are mostly zeros. If True then no error will be raised,</span>
<span class="sd">            but an empty trace will be returned (and not used in detection).</span>
<span class="sd">        :type group_size: int</span>
<span class="sd">        :param group_size:</span>
<span class="sd">            Maximum number of templates to run at once, use to reduce memory</span>
<span class="sd">            consumption, if unset will use all templates.</span>
<span class="sd">        :type full_peaks: bool</span>
<span class="sd">        :param full_peaks: See `eqcorrscan.utils.findpeaks.find_peaks2_short`</span>
<span class="sd">        :type save_progress: bool</span>
<span class="sd">        :param save_progress:</span>
<span class="sd">            Whether to save the resulting party at every data step or not.</span>
<span class="sd">            Useful for long-running processes.</span>
<span class="sd">        :type process_cores: int</span>
<span class="sd">        :param process_cores:</span>
<span class="sd">            Number of processes to use for pre-processing (if different to</span>
<span class="sd">            `cores`).</span>
<span class="sd">        :type return_stream: bool</span>
<span class="sd">        :param return_stream:</span>
<span class="sd">            Whether to also output the stream downloaded, useful if you plan</span>
<span class="sd">            to use the stream for something else, e.g. lag_calc.</span>
<span class="sd">        :type retries: int</span>
<span class="sd">        :param retries:</span>
<span class="sd">            Number of attempts allowed for downloading - allows for transient</span>
<span class="sd">            server issues.</span>

<span class="sd">        :return:</span>
<span class="sd">            :class:`eqcorrscan.core.match_filter.Party` of Families of</span>
<span class="sd">            detections.</span>


<span class="sd">        .. Note::</span>
<span class="sd">            When using the &quot;fftw&quot; correlation backend the length of the fft</span>
<span class="sd">            can be set. See :mod:`eqcorrscan.utils.correlate` for more info.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            Ensures that data overlap between loops, which will lead to no</span>
<span class="sd">            missed detections at data start-stop points (see note for</span>
<span class="sd">            :meth:`eqcorrscan.core.match_filter.Tribe.detect` method).</span>
<span class="sd">            This will result in end-time not being strictly</span>
<span class="sd">            honoured, so detections may occur after the end-time set.  This is</span>
<span class="sd">            because data must be run in the correct process-length.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Plotting within the match-filter routine uses the Agg backend</span>
<span class="sd">            with interactive plotting turned off.  This is because the function</span>
<span class="sd">            is designed to work in bulk.  If you wish to turn interactive</span>
<span class="sd">            plotting on you must import matplotlib in your script first,</span>
<span class="sd">            when you then import match_filter you will get the warning that</span>
<span class="sd">            this call to matplotlib has no effect, which will mean that</span>
<span class="sd">            match_filter has not changed the plotting behaviour.</span>

<span class="sd">        .. note::</span>
<span class="sd">            **Thresholding:**</span>

<span class="sd">            **MAD** threshold is calculated as the:</span>

<span class="sd">            .. math::</span>

<span class="sd">                threshold {\\times} (median(abs(cccsum)))</span>

<span class="sd">            where :math:`cccsum` is the cross-correlation sum for a given</span>
<span class="sd">            template.</span>

<span class="sd">            **absolute** threshold is a true absolute threshold based on the</span>
<span class="sd">            cccsum value.</span>

<span class="sd">            **av_chan_corr** is based on the mean values of single-channel</span>
<span class="sd">            cross-correlations assuming all data are present as required for</span>
<span class="sd">            the template, e.g:</span>

<span class="sd">            .. math::</span>

<span class="sd">                av\_chan\_corr\_thresh=threshold \\times (cccsum /</span>
<span class="sd">                len(template))</span>

<span class="sd">            where :math:`template` is a single template from the input and the</span>
<span class="sd">            length is the number of channels within this template.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">obspy.clients.fdsn.client</span> <span class="kn">import</span> <span class="n">FDSNException</span>

        <span class="c1"># This uses get_waveforms_bulk to get data - not all client types have</span>
        <span class="c1"># this, so we check and monkey patch here.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s2">&quot;get_waveforms_bulk&quot;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s2">&quot;get_waveforms&quot;</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;client </span><span class="si">{</span><span class="n">client</span><span class="si">}</span><span class="s2"> must have at least a get_waveforms method&quot;</span><span class="p">)</span>
            <span class="n">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Client </span><span class="si">{</span><span class="n">client</span><span class="si">}</span><span class="s2"> does not have a get_waveforms_bulk &quot;</span>
                        <span class="s2">&quot;method, monkey-patching this&quot;</span><span class="p">)</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">get_waveform_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

        <span class="n">party</span> <span class="o">=</span> <span class="n">Party</span><span class="p">()</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="mi">300</span>
        <span class="c1"># Apply a buffer, often data downloaded is not the correct length</span>
        <span class="n">data_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">process_length</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">])</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="n">max_delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">template</span><span class="o">.</span><span class="n">st</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s1">&#39;starttime&#39;</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">-</span>
                         <span class="n">template</span><span class="o">.</span><span class="n">st</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s1">&#39;starttime&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_delay</span> <span class="o">&gt;</span> <span class="n">pad</span><span class="p">:</span>
                <span class="n">pad</span> <span class="o">=</span> <span class="n">max_delay</span>
        <span class="n">download_groups</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">starttime</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_length</span>
        <span class="n">template_channel_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">st</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="n">chan_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chan_id</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;?&#39;</span> <span class="o">+</span>
                                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chan_id</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,)</span>
                <span class="n">template_channel_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan_id</span><span class="p">)</span>
        <span class="n">template_channel_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">template_channel_ids</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">return_stream</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">download_groups</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">download_groups</span><span class="p">:</span>
            <span class="n">download_groups</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">download_groups</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">download_groups</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">download_groups</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">download_groups</span><span class="p">):</span>
            <span class="n">bulk_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">chan_id</span> <span class="ow">in</span> <span class="n">template_channel_ids</span><span class="p">:</span>
                <span class="n">bulk_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">chan_id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chan_id</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">chan_id</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">chan_id</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                    <span class="n">starttime</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">data_length</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">pad</span> <span class="o">+</span> <span class="n">buff</span><span class="p">),</span>
                    <span class="n">starttime</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data_length</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad</span> <span class="o">+</span> <span class="n">buff</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">retry_attempt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retries</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Downloading data&quot;</span><span class="p">)</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms_bulk</span><span class="p">(</span><span class="n">bulk_info</span><span class="p">)</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">&quot;Downloaded data for </span><span class="si">{0}</span><span class="s2"> traces&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="n">FDSNException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;Split the request in smaller&quot;</span> <span class="ow">in</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                        <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Datacentre does not support large requests: &quot;</span>
                            <span class="s2">&quot;splitting request into smaller chunks&quot;</span><span class="p">)</span>
                        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">_bulk</span> <span class="ow">in</span> <span class="n">bulk_info</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">st</span> <span class="o">+=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms_bulk</span><span class="p">([</span><span class="n">_bulk</span><span class="p">])</span>
                            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No data for </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_bulk</span><span class="p">))</span>
                                <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                                <span class="k">continue</span>
                        <span class="n">Logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Downloaded data for </span><span class="si">{0}</span><span class="s2"> traces&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)))</span>
                        <span class="k">break</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MatchFilterError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not download data after </span><span class="si">{0}</span><span class="s2"> attempts&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">retries</span><span class="p">))</span>
            <span class="c1"># Get gaps and remove traces as necessary</span>
            <span class="k">if</span> <span class="n">min_gap</span><span class="p">:</span>
                <span class="n">gaps</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_gaps</span><span class="p">(</span><span class="n">min_gap</span><span class="o">=</span><span class="n">min_gap</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Large gaps in downloaded data&quot;</span><span class="p">)</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
                    <span class="n">gappy_channels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">([(</span><span class="n">gap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gap</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gap</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">gap</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                             <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="n">gaps</span><span class="p">]))</span>
                    <span class="n">_st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                        <span class="n">tr_stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                                    <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">tr_stats</span> <span class="ow">in</span> <span class="n">gappy_channels</span><span class="p">:</span>
                            <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;Removing gappy channel: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tr</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">_st</span> <span class="o">+=</span> <span class="n">tr</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">_st</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">st</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s2">&quot;simple&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
            <span class="n">st</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">starttime</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">data_length</span><span class="p">)</span> <span class="o">-</span> <span class="n">pad</span><span class="p">,</span>
                    <span class="n">endtime</span><span class="o">=</span><span class="n">starttime</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data_length</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_check_daylong</span><span class="p">(</span><span class="n">tr</span><span class="p">):</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> contains more zeros than non-zero, &quot;</span>
                        <span class="s2">&quot;removed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">&lt;</span> \
                   <span class="mf">0.8</span> <span class="o">*</span> <span class="n">data_length</span><span class="p">:</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is less than 80</span><span class="si">% o</span><span class="s2">f the required length&quot;</span>
                        <span class="s2">&quot;, removed&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">return_stream</span><span class="p">:</span>
                <span class="n">stream</span> <span class="o">+=</span> <span class="n">st</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">party</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span>
                    <span class="n">stream</span><span class="o">=</span><span class="n">st</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                    <span class="n">threshold_type</span><span class="o">=</span><span class="n">threshold_type</span><span class="p">,</span> <span class="n">trig_int</span><span class="o">=</span><span class="n">trig_int</span><span class="p">,</span>
                    <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="n">plotdir</span><span class="p">,</span> <span class="n">daylong</span><span class="o">=</span><span class="n">daylong</span><span class="p">,</span>
                    <span class="n">parallel_process</span><span class="o">=</span><span class="n">parallel_process</span><span class="p">,</span> <span class="n">xcorr_func</span><span class="o">=</span><span class="n">xcorr_func</span><span class="p">,</span>
                    <span class="n">concurrency</span><span class="o">=</span><span class="n">concurrency</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span>
                    <span class="n">ignore_length</span><span class="o">=</span><span class="n">ignore_length</span><span class="p">,</span>
                    <span class="n">ignore_bad_data</span><span class="o">=</span><span class="n">ignore_bad_data</span><span class="p">,</span> <span class="n">group_size</span><span class="o">=</span><span class="n">group_size</span><span class="p">,</span>
                    <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_peaks</span><span class="o">=</span><span class="n">full_peaks</span><span class="p">,</span>
                    <span class="n">process_cores</span><span class="o">=</span><span class="n">process_cores</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save_progress</span><span class="p">:</span>
                    <span class="n">party</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;eqcorrscan_temporary_party&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                    <span class="s1">&#39;Error, routine incomplete, returning incomplete Party&#39;</span><span class="p">)</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">return_stream</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">party</span><span class="p">,</span> <span class="n">stream</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">party</span>
        <span class="k">for</span> <span class="n">family</span> <span class="ow">in</span> <span class="n">party</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">family</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">family</span><span class="o">.</span><span class="n">detections</span> <span class="o">=</span> <span class="n">family</span><span class="o">.</span><span class="n">_uniq</span><span class="p">()</span><span class="o">.</span><span class="n">detections</span>
        <span class="k">if</span> <span class="n">return_stream</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">party</span><span class="p">,</span> <span class="n">stream</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">party</span></div>

<div class="viewcode-block" id="Tribe.construct"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.Tribe.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">samp_rate</span><span class="p">,</span> <span class="n">filt_order</span><span class="p">,</span>
                  <span class="n">length</span><span class="p">,</span> <span class="n">prepick</span><span class="p">,</span> <span class="n">swin</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">process_len</span><span class="o">=</span><span class="mi">86400</span><span class="p">,</span>
                  <span class="n">all_horiz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">min_snr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_cores</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">skip_short_chans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a Tribe of Templates.</span>

<span class="sd">        :type method: str</span>
<span class="sd">        :param method:</span>
<span class="sd">            Method of Tribe generation. Possible options are: `from_client`,</span>
<span class="sd">            `from_seishub`, `from_meta_file`.  See below on the additional</span>
<span class="sd">            required arguments for each method.</span>
<span class="sd">        :type lowcut: float</span>
<span class="sd">        :param lowcut:</span>
<span class="sd">            Low cut (Hz), if set to None will not apply a lowcut</span>
<span class="sd">        :type highcut: float</span>
<span class="sd">        :param highcut:</span>
<span class="sd">            High cut (Hz), if set to None will not apply a highcut.</span>
<span class="sd">        :type samp_rate: float</span>
<span class="sd">        :param samp_rate:</span>
<span class="sd">            New sampling rate in Hz.</span>
<span class="sd">        :type filt_order: int</span>
<span class="sd">        :param filt_order:</span>
<span class="sd">            Filter level (number of corners).</span>
<span class="sd">        :type length: float</span>
<span class="sd">        :param length: Length of template waveform in seconds.</span>
<span class="sd">        :type prepick: float</span>
<span class="sd">        :param prepick: Pre-pick time in seconds</span>
<span class="sd">        :type swin: str</span>
<span class="sd">        :param swin:</span>
<span class="sd">            P, S, P_all, S_all or all, defaults to all: see note in</span>
<span class="sd">            :func:`eqcorrscan.core.template_gen.template_gen`</span>
<span class="sd">        :type process_len: int</span>
<span class="sd">        :param process_len: Length of data in seconds to download and process.</span>
<span class="sd">        :type all_horiz: bool</span>
<span class="sd">        :param all_horiz:</span>
<span class="sd">            To use both horizontal channels even if there is only a pick on</span>
<span class="sd">            one of them.  Defaults to False.</span>
<span class="sd">        :type delayed: bool</span>
<span class="sd">        :param delayed: If True, each channel will begin relative to it&#39;s own</span>
<span class="sd">            pick-time, if set to False, each channel will begin at the same</span>
<span class="sd">            time.</span>
<span class="sd">        :type plot: bool</span>
<span class="sd">        :param plot: Plot templates or not.</span>
<span class="sd">        :type plotdir: str</span>
<span class="sd">        :param plotdir:</span>
<span class="sd">            The path to save plots to. If `plotdir=None` (default) then the</span>
<span class="sd">            figure will be shown on screen.</span>
<span class="sd">        :type min_snr: float</span>
<span class="sd">        :param min_snr:</span>
<span class="sd">            Minimum signal-to-noise ratio for a channel to be included in the</span>
<span class="sd">            template, where signal-to-noise ratio is calculated as the ratio</span>
<span class="sd">            of the maximum amplitude in the template window to the rms</span>
<span class="sd">            amplitude in the whole window given.</span>
<span class="sd">        :type parallel: bool</span>
<span class="sd">        :param parallel: Whether to process data in parallel or not.</span>
<span class="sd">        :type num_cores: int</span>
<span class="sd">        :param num_cores:</span>
<span class="sd">            Number of cores to try and use, if False and parallel=True,</span>
<span class="sd">            will use either all your cores, or as many traces as in the data</span>
<span class="sd">            (whichever is smaller).</span>
<span class="sd">        :type save_progress: bool</span>
<span class="sd">        :param save_progress:</span>
<span class="sd">            Whether to save the resulting template set at every data step or</span>
<span class="sd">            not. Useful for long-running processes.</span>
<span class="sd">        :type skip_short_chans: bool</span>
<span class="sd">        :param skip_short_chans:</span>
<span class="sd">            Whether to ignore channels that have insufficient length data or</span>
<span class="sd">            not. Useful when the quality of data is not known, e.g. when</span>
<span class="sd">            downloading old, possibly triggered data from a datacentre</span>
<span class="sd">        :type save_progress: bool</span>
<span class="sd">        :param save_progress:</span>
<span class="sd">            Whether to save the resulting party at every data step or not.</span>
<span class="sd">            Useful for long-running processes.</span>

<span class="sd">        .. note::</span>
<span class="sd">            *Method specific arguments:*</span>

<span class="sd">            - `from_client` requires:</span>
<span class="sd">                :param str client_id:</span>
<span class="sd">                    string passable by obspy to generate Client, or any object</span>
<span class="sd">                    with a `get_waveforms` method, including a Client instance.</span>
<span class="sd">                :param `obspy.core.event.Catalog` catalog:</span>
<span class="sd">                    Catalog of events to generate template for</span>
<span class="sd">                :param float data_pad: Pad length for data-downloads in seconds</span>
<span class="sd">            - `from_seishub` requires:</span>
<span class="sd">                :param str url: url to seishub database</span>
<span class="sd">                :param `obspy.core.event.Catalog` catalog:</span>
<span class="sd">                    Catalog of events to generate template for</span>
<span class="sd">                :param float data_pad: Pad length for data-downloads in seconds</span>
<span class="sd">            - `from_meta_file` requires:</span>
<span class="sd">                :param str meta_file:</span>
<span class="sd">                    Path to obspy-readable event file, or an obspy Catalog</span>
<span class="sd">                :param `obspy.core.stream.Stream` st:</span>
<span class="sd">                    Stream containing waveform data for template. Note that</span>
<span class="sd">                    this should be the same length of stream as you will use</span>
<span class="sd">                    for the continuous detection, e.g. if you detect in</span>
<span class="sd">                    day-long files, give this a day-long file!</span>
<span class="sd">                :param bool process:</span>
<span class="sd">                    Whether to process the data or not, defaults to True.</span>

<span class="sd">        .. Note::</span>
<span class="sd">            Method: `from_sac` is not supported by Tribe.construct and must</span>
<span class="sd">            use Template.construct.</span>

<span class="sd">        .. Note:: Templates will be named according to their start-time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">templates</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span> <span class="n">process_lengths</span> <span class="o">=</span> <span class="n">template_gen</span><span class="o">.</span><span class="n">template_gen</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="n">highcut</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">filt_order</span><span class="o">=</span><span class="n">filt_order</span><span class="p">,</span> <span class="n">samp_rate</span><span class="o">=</span><span class="n">samp_rate</span><span class="p">,</span> <span class="n">prepick</span><span class="o">=</span><span class="n">prepick</span><span class="p">,</span>
            <span class="n">return_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_progress</span><span class="o">=</span><span class="n">save_progress</span><span class="p">,</span> <span class="n">swin</span><span class="o">=</span><span class="n">swin</span><span class="p">,</span>
            <span class="n">process_len</span><span class="o">=</span><span class="n">process_len</span><span class="p">,</span> <span class="n">all_horiz</span><span class="o">=</span><span class="n">all_horiz</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="n">plotdir</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">min_snr</span><span class="o">=</span><span class="n">min_snr</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
            <span class="n">num_cores</span><span class="o">=</span><span class="n">num_cores</span><span class="p">,</span> <span class="n">skip_short_chans</span><span class="o">=</span><span class="n">skip_short_chans</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">template</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">process_len</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">templates</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span>
                                                <span class="n">process_lengths</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">Template</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)):</span>
                    <span class="n">Logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Data are zero in float16, missing data,&#39;</span>
                                   <span class="s1">&#39; will not use: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
                    <span class="n">template</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Empty Template&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">t</span><span class="o">.</span><span class="n">st</span> <span class="o">=</span> <span class="n">template</span>
            <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s1">&#39;starttime&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span> \
                <span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y_%m_</span><span class="si">%d</span><span class="s1">t%H_%M_%S&#39;</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">lowcut</span> <span class="o">=</span> <span class="n">lowcut</span>
            <span class="n">t</span><span class="o">.</span><span class="n">highcut</span> <span class="o">=</span> <span class="n">highcut</span>
            <span class="n">t</span><span class="o">.</span><span class="n">filt_order</span> <span class="o">=</span> <span class="n">filt_order</span>
            <span class="n">t</span><span class="o">.</span><span class="n">samp_rate</span> <span class="o">=</span> <span class="n">samp_rate</span>
            <span class="n">t</span><span class="o">.</span><span class="n">process_length</span> <span class="o">=</span> <span class="n">process_len</span>
            <span class="n">t</span><span class="o">.</span><span class="n">prepick</span> <span class="o">=</span> <span class="n">prepick</span>
            <span class="n">event</span><span class="o">.</span><span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Comment</span><span class="p">(</span>
                <span class="n">text</span><span class="o">=</span><span class="s2">&quot;eqcorrscan_template_&quot;</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">creation_info</span><span class="o">=</span><span class="n">CreationInfo</span><span class="p">(</span><span class="n">agency</span><span class="o">=</span><span class="s1">&#39;eqcorrscan&#39;</span><span class="p">,</span>
                                           <span class="n">author</span><span class="o">=</span><span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">())))</span>
            <span class="n">t</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="read_tribe"><a class="viewcode-back" href="../../../../submodules/core.match_filter.tribe.html#eqcorrscan.core.match_filter.tribe.read_tribe">[docs]</a><span class="k">def</span> <span class="nf">read_tribe</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a Tribe of templates from a tar archive.</span>

<span class="sd">    :param fname: Filename to read from</span>
<span class="sd">    :return: :class:`eqcorrscan.core.match_filter.Tribe`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tribe</span> <span class="o">=</span> <span class="n">Tribe</span><span class="p">()</span>
    <span class="n">tribe</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tribe</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
    <span class="c1"># List files to be removed after doctest</span>
    <span class="n">cleanup</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;test_tribe.tgz&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cleanup</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2015-2021: EQcorrscan developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>