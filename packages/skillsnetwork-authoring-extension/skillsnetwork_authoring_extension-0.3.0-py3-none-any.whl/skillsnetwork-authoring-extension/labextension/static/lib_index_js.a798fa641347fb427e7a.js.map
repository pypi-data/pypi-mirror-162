{"version":3,"file":"lib_index_js.a798fa641347fb427e7a.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA0D;AACL;AACG;AACP;AACqC;AAC9B;AACpB;AACI;AACgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,oEAAgB,EAAE,2DAAS;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAe;AAC9C;AACA,YAAY,sDAAY,CAAC,sDAAY,CAAC,kDAAa;AACnD;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,kEAAkB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAW;AACnC;AACA;AACA,kDAAkD,0DAAqB,EAAE,uDAAkB;AAC3F,0CAA0C,2DAAsB;AAChE;AACA,QAAQ,uDAAkB;AAC1B,4BAA4B,gDAAQ;AACpC,4BAA4B,sDAAc;AAC1C;AACA,2EAA2E,MAAM,2DAAsB,EAAE;AACzG,cAAc,uDAAe,SAAS,sDAAY,SAAS,uDAAkB;AAC7E;AACA,8DAA8D,MAAM,2DAAsB,EAAE;AAC5F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EkC;AAC9B;AAC2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+EAA6B;AACtD;AACA,+BAA+B,8EAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC,uCAAuC,YAAY,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,wEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,0DAAiB;AACnC;AACP;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AACyC;AAC0B;AACjC;AAClC;AACA;AACA;AACO,4BAA4B,mDAAM;AACzC;AACA;AACA,4BAA4B,yDAAO;AACnC;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,qEAAmB;AACrC,KAAK;AACL;AACA;AACA,YAAY,kDAAa;AACzB;AACA,KAAK;AACL,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEwH;AAC1E;AACJ;AAChB;AACS;AACD;AAC3B;AACP;AACA,QAAQ,kDAAa;AACrB,wBAAwB,mDAAY;AACpC,iBAAiB,mDAAc;AAC/B;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,8DAAY,IAAI;AACxB;AACA,KAAK;AACL;AACA,QAAQ,8DAAY,IAAI;AACxB,QAAQ,mEAA0B;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,qDAAY;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,iDAAY;AACrC,SAAS;AACT;AACA;AACA,YAAY,8DAAY,IAAI;AAC5B,YAAY,iEAAwB;AACpC;AACA,SAAS;AACT;AACA;AACA,YAAY,8DAAY,IAAI;AAC5B,YAAY,iEAAwB;AACpC;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACpE8B;AACA;AAC9B;AACA,IAAI,+CAAM;AACV,IAAI,uCAAI;AACR;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACN6B;AACF;AACW;AACD;AACC;AACjB;AAC4B;AAC3B;AACN;AAC7B;AACP;AACA;AACA,eAAe,2DAAS,EAAE,kEAAgB,EAAE,oEAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,WAAW;AAC3B;AACA,yBAAyB,iDAAI,GAAG,UAAU;AAC1C;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA,0BAA0B,mDAAM,GAAG,kBAAkB;AACrD,0BAA0B,qEAAmB,IAAI,iEAAe;AAChE,aAAa;AACb;AACA,oBAAoB,qDAAY;AAChC;AACA,wCAAwC,gDAAQ;AAChD,wCAAwC,sDAAc;AACtD,oFAAoF,MAAM,2DAAsB,EAAE;AAClH;AACA;AACA;AACA;AACA,0BAA0B,uDAAe,UAAU,sDAAY;AAC/D;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DqD;AACb;AACR;AACG;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,+DAAa;AACnC;AACA;AACA;AACA,qCAAqC,qDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,+CAAW;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,qFAAqF,6DAAwB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;AC3HA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B","sources":["webpack://skillsnetwork-authoring-extension/./lib/button/index.js","webpack://skillsnetwork-authoring-extension/./lib/config.js","webpack://skillsnetwork-authoring-extension/./lib/dialog.js","webpack://skillsnetwork-authoring-extension/./lib/handler.js","webpack://skillsnetwork-authoring-extension/./lib/index.js","webpack://skillsnetwork-authoring-extension/./lib/menu/index.js","webpack://skillsnetwork-authoring-extension/./lib/tools.js","webpack://skillsnetwork-authoring-extension/./node_modules/process/browser.js"],"sourcesContent":["import { IDocumentManager } from '@jupyterlab/docmanager';\nimport { ToolbarButton } from '@jupyterlab/apputils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { getFileContents, getLabFilePath, loadLabContents, parseJwt } from '../tools';\nimport { axiosHandler, postLabModel } from '../handler';\nimport { Globals } from '../config';\nimport { ATLAS_TOKEN } from '../config';\nimport { INotebookTracker } from '@jupyterlab/notebook';\n/**\n * The plugin registration information.\n */\nconst plugin = {\n    activate,\n    id: 'skillsnetwork-authoring-extension:plugin',\n    autoStart: true,\n    requires: [INotebookTracker, IDocumentManager, IMainMenu]\n};\n/**\n * A notebook widget extension that adds a button to the toolbar.\n */\nexport class ButtonExtension {\n    /**\n     * Create a new extension for the notebook panel widget.\n     *\n     * @param panel Notebook panel\n     * @param context Notebook context\n     * @returns Disposable on the added button\n     */\n    createNew(panel, context) {\n        const start = async () => {\n            // Get the current file contents\n            const file = await getFileContents(panel, context);\n            // POST to Atlas the file contents/lab model\n            postLabModel(axiosHandler(Globals.TOKEN), file);\n        };\n        const button = new ToolbarButton({\n            className: 'publish-lab-button',\n            label: 'Publish',\n            onClick: start,\n            tooltip: 'Publish Lab'\n        });\n        panel.toolbar.insertItem(10, 'publish', button);\n        return new DisposableDelegate(() => {\n            button.dispose();\n        });\n    }\n}\n/**\n * Activate the extension.\n *\n * @param app Main application object\n */\nasync function activate(app, mainMenu, docManager) {\n    console.log(\"Activated skillsnetwork-authoring-extension button plugin!\");\n    // init the token, globals\n    const token = await ATLAS_TOKEN();\n    // Add the Publish widget to the lab environment\n    app.docRegistry.addWidgetExtension('Notebook', new ButtonExtension());\n    console.log('Detected your environment as: ', Globals.LAB_TOOL_TYPE, Globals.AUTHOR_ENV);\n    console.log('Using default kernel: ', Globals.PY_KERNEL_NAME);\n    // Only try to load up a notebook when author is using the browser tool (not in local)\n    if (Globals.AUTHOR_ENV === 'browser') {\n        const parsedToken = parseJwt(token);\n        const labFilename = getLabFilePath(parsedToken);\n        // Attempt to open the lab\n        let widget = await docManager.createNew(labFilename, 'notebook', { name: Globals.PY_KERNEL_NAME });\n        await loadLabContents(widget, axiosHandler(token), Globals.AUTHOR_ENV);\n        widget.context.ready.then(() => {\n            docManager.openOrReveal(labFilename, 'default', { name: Globals.PY_KERNEL_NAME });\n        });\n    }\n}\n/**\n * Export the plugin as default.\n */\nexport default plugin;\n","import { ServerConnection } from '@jupyterlab/services';\nimport axios from \"axios\";\nimport { KernelSpecAPI } from '@jupyterlab/services';\nconst getServerBaseUrl = (settings) => {\n    let baseUrl = settings.baseUrl;\n    // Add the trailing slash if it is missing.\n    if (!baseUrl.endsWith('/')) {\n        baseUrl += '/';\n    }\n    return baseUrl;\n};\nexport const ATLAS_BASE_URL = await (async () => {\n    const currentUrl = window.location.href;\n    const parameters = new URL(currentUrl).searchParams;\n    const baseUrl = parameters.get('atlas_base_url');\n    if (baseUrl === null) {\n        const init = {\n            method: 'GET',\n        };\n        const settings = ServerConnection.makeSettings();\n        const requestUrl = getServerBaseUrl(settings) + 'skillsnetwork-authoring-extension/config';\n        const response = await ServerConnection.makeRequest(requestUrl, init, settings);\n        const configuration = (await response.json());\n        return configuration.ATLAS_BASE_URL;\n    }\n    else {\n        return baseUrl;\n    }\n})();\n/**\n * Extracts the session token. Will first try to get a token via the URL, if none was found then try to get the token via cookie.\n *\n * @returns token\n */\nexport const ATLAS_TOKEN = async () => {\n    var _a;\n    const currentURL = window.location.href;\n    const params = new URL(currentURL).searchParams;\n    let token = params.get('token');\n    Globals.LAB_TOOL_TYPE = 'JUPYTER_LITE';\n    if (token === null) {\n        // Try getting it from cookie\n        const COOKIE_NAME = (_a = process.env.ATLAS_TOKEN_COOKIE_NAME) !== null && _a !== void 0 ? _a : 'atlas_token';\n        const reg = new RegExp(`(^| )${COOKIE_NAME}=([^;]+)`);\n        let match = reg.exec(document.cookie);\n        // If found then set that as our token o/w set it as empty str for now\n        (match !== null) ? token = match[2] : token = 'NO_TOKEN';\n        Globals.LAB_TOOL_TYPE = 'JUPYTER_LAB';\n    }\n    if (token === null || token === 'NO_TOKEN') {\n        // If no token was found in the URL or cookies, the author is in their local env (hopefully...)\n        Globals.AUTHOR_ENV = 'local';\n    }\n    else {\n        Globals.AUTHOR_ENV = 'browser';\n    }\n    if (Globals.LAB_TOOL_TYPE === 'JUPYTER_LAB') {\n        // In production, jupyterlab doesn't have python3 as a kernel option so use python\n        Globals.PY_KERNEL_NAME = await GET_PYKERNEL();\n        Globals.DEFAULT_LAB_NAME = 'lab.ipynb';\n    }\n    else if (Globals.LAB_TOOL_TYPE === 'JUPYTER_LITE') {\n        Globals.PY_KERNEL_NAME = 'python';\n        Globals.DEFAULT_LAB_NAME = 'lab.jupyterlite.ipynb';\n    }\n    Globals.TOKEN = token;\n    return token;\n};\n/**\n * Gets the python kernel. If more than one python kernel is found, prioritize python3. If only one python kernel is found, select that kernel\n *\n * @returns pykernel\n */\nexport const GET_PYKERNEL = async () => {\n    // Get the available kernels\n    let kspecs = await (await KernelSpecAPI.getSpecs()).kernelspecs;\n    function checkPython(spec) {\n        return spec.includes('python');\n    }\n    let keys = Object.keys(kspecs);\n    // filter for only the spec names with python in it, sorted\n    let filtered_keys = keys.filter(checkPython).sort();\n    // return the priority python\n    let pykernel = filtered_keys[filtered_keys.length - 1];\n    return pykernel;\n};\nexport var CancelToken = axios.CancelToken;\nexport var source = CancelToken.source();\n// Global variables\nexport class Globals {\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { Widget } from '@lumino/widgets';\nimport { Dialog, showDialog, Spinner } from '@jupyterlab/apputils';\nimport { source } from './config';\n/**\n * A widget that holds the loading spinner\n */\nexport class SpinnerDialog extends Widget {\n    constructor() {\n        const body = document.createElement('div');\n        const spinner = new Spinner();\n        body.appendChild(spinner.node);\n        body.style.padding = '15px';\n        super({ node: body });\n    }\n}\n/**\n * Shows the Loading dialog\n */\nexport const show_spinner = (message) => {\n    const spinWidget = new SpinnerDialog();\n    showDialog({\n        title: message,\n        body: spinWidget,\n        buttons: [Dialog.cancelButton()]\n    })\n        .then(result => {\n        if (!result.button.accept) {\n            source.cancel('Operation cancelled by the user.');\n        }\n    })\n        .catch(error => { });\n};\n/**\n * Shows the Success dialog\n */\nexport const showSuccessPublishDialog = () => {\n    showDialog({\n        title: 'Success!',\n        body: 'This lab was successfully submitted for publishing!',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n/**\n * Shows the Failed to publish dialog\n */\nexport const showFailurePublishDialog = () => {\n    showDialog({\n        title: 'Failed to Publish',\n        body: 'This lab failed to publish.',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n/**\n * Shows the Failed to load lab dialog\n */\nexport const showFailureImportLabDialog = () => {\n    showDialog({\n        title: 'Failed to Load Lab',\n        body: 'This lab failed to load.',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n","import { show_spinner, showSuccessPublishDialog, showFailurePublishDialog, showFailureImportLabDialog } from './dialog';\nimport { Dialog } from '@jupyterlab/apputils';\nimport { ATLAS_BASE_URL } from './config';\nimport axios from 'axios';\nimport { Globals } from './config';\nimport { source } from './config';\nexport const axiosHandler = (lab_token) => {\n    if (lab_token)\n        Globals.TOKEN = lab_token;\n    const atlasClient = axios.create({\n        baseURL: ATLAS_BASE_URL,\n        headers: {\n            Authorization: `Bearer ${lab_token}`,\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*'\n        }\n    });\n    return atlasClient;\n};\n/**\n * GET the lab model / JSON that represents a .ipynb file/notebook from ATLAS\n *\n * @param axiosHandler Axios client that contains a JWT Bearer token\n * @returns Promise<void>\n */\nexport const getLabModel = (axiosHandler) => {\n    // GET the lab model\n    return axiosHandler\n        .get('v1/labs')\n        .then(result => {\n        Dialog.flush(); //remove spinner\n        return JSON.parse(result.data.body);\n    })\n        .catch(error => {\n        Dialog.flush(); //remove spinner\n        showFailureImportLabDialog();\n        console.log(error);\n        return 0;\n    });\n};\n/**\n * POST the lab model / JSON from the .ipynb file/notebook to ATLAS\n *\n * @param axiosHandler Axios client that contains a JWT Bearer token\n * @returns Promise<void>\n */\nexport const postLabModel = async (axiosHandler, labModel) => {\n    show_spinner('Publishing...');\n    return new Promise(async (resolve, reject) => {\n        await axiosHandler\n            .post('v1/labs', {\n            body: labModel\n        }, {\n            cancelToken: source.token,\n        })\n            .then(res => {\n            console.log('SUCCESSFULLY PUSHED', res);\n            Dialog.flush(); //remove spinner\n            showSuccessPublishDialog();\n            resolve;\n        })\n            .catch((error) => {\n            console.log(error);\n            Dialog.flush(); // remove spinner\n            showFailurePublishDialog();\n            reject;\n        });\n    });\n};\n","import { menu } from './menu';\nimport plugin from './button';\nconst main = [\n    plugin,\n    menu\n];\nexport default main;\n","import { IMainMenu } from '@jupyterlab/mainmenu';\nimport { Menu, Widget } from '@lumino/widgets';\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { INotebookTracker, } from '@jupyterlab/notebook';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { show_spinner } from '../dialog';\nimport { getLabFilePath, loadLabContents, parseJwt } from '../tools';\nimport { axiosHandler } from '../handler';\nimport { Globals } from '../config';\nexport const menu = {\n    id: 'skillsnetwork-authoring-extension:menu',\n    autoStart: true,\n    requires: [IMainMenu, INotebookTracker, IDocumentManager],\n    activate: (app, mainMenu, notebookTracker, docManager) => {\n        console.log('Activated skillsnetwork-authoring-extension menu plugin!');\n        const editLabFromToken = 'edit-lab-from-token';\n        app.commands.addCommand(editLabFromToken, {\n            label: 'Edit a Lab',\n            execute: () => {\n                showTokenDialog(notebookTracker, docManager);\n            }\n        });\n        const { commands } = app;\n        // Create a new menu\n        const menu = new Menu({ commands });\n        menu.title.label = 'Skills Network';\n        mainMenu.addMenu(menu, { rank: 80 });\n        // Add command to menu\n        menu.addItem({\n            command: editLabFromToken,\n            args: {}\n        });\n        const showTokenDialog = (notebookTracker, docManager) => {\n            // Generate Dialog body\n            let bodyDialog = document.createElement('div');\n            let nameLabel = document.createElement('label');\n            nameLabel.textContent = \"Enter your authorization token: \";\n            let tokenInput = document.createElement('input');\n            tokenInput.className = \"jp-mod-styled\";\n            bodyDialog.appendChild(nameLabel);\n            bodyDialog.appendChild(tokenInput);\n            showDialog({\n                title: \"Edit a Lab\",\n                body: new Widget({ node: bodyDialog }),\n                buttons: [Dialog.cancelButton(), Dialog.okButton()]\n            }).then(async (result) => {\n                if (result.button.accept) {\n                    show_spinner('Loading up your lab...');\n                    const token = tokenInput.value;\n                    const parsedToken = parseJwt(token);\n                    const labFilename = getLabFilePath(parsedToken);\n                    const nbPanel = docManager.createNew(labFilename, 'notebook', { name: Globals.PY_KERNEL_NAME });\n                    if (nbPanel === undefined) {\n                        throw Error('Error loading lab');\n                    }\n                    nbPanel.show();\n                    await loadLabContents(nbPanel, axiosHandler(tokenInput.value));\n                }\n            })\n                .catch();\n        };\n    }\n};\n","import { NotebookModel } from '@jupyterlab/notebook';\nimport { getLabModel } from './handler';\nimport { Buffer } from 'buffer';\nimport { Globals } from './config';\n/**\n * Extracts the relevant data from the cells of the notebook\n *\n * @param cell Cell model\n * @returns ICellData object\n */\nexport const getCellContents = (cell) => {\n    const cellData = {\n        cell_type: cell.model.type,\n        id: cell.model.id,\n        metadata: {},\n        outputs: [],\n        source: [cell.model.value.text]\n    };\n    return cellData;\n};\n/**\n * Gets the raw data (cell models and content, notebook configurations) from the .ipynb file\n *\n * @param panel Notebook panel\n * @param context Notebook context\n */\nexport const getFileContents = (panel, context) => {\n    // Cell types: \"code\" | \"markdown\" | \"raw\"\n    const allCells = [];\n    panel.content.widgets.forEach((cell) => {\n        const cellData = getCellContents(cell);\n        allCells.push(cellData);\n    });\n    // Get the configs from the notebook model\n    const config_meta = context.model.metadata.toJSON();\n    const config_nbmajor = context.model.nbformat;\n    const config_nbminor = context.model.nbformatMinor;\n    // Put all data into IPynbRaw object\n    const rawFile = {\n        cells: allCells,\n        metadata: config_meta,\n        nbformat: config_nbmajor,\n        nbformat_minor: config_nbminor\n    };\n    return JSON.stringify(rawFile, null, 2);\n};\nexport const loadLabContents = async (widget, axiosHandlers, author_env) => {\n    const model = new NotebookModel();\n    // Only try to load the initial lab notebook if the author is not coming from their local env\n    if (author_env !== 'local') {\n        try {\n            const lab_model = (await getLabModel(axiosHandlers));\n            model.fromJSON(lab_model);\n        }\n        catch (_a) {\n            throw 'Error getting lab model';\n        }\n        // testing purposes\n        //model.fromJSON(DEFAULT_CONTENT);\n    }\n    // testing purposes:\n    // model.fromJSON(DEFAULT_CONTENT);\n    widget.content.model = model;\n};\nexport const parseJwt = (token) => {\n    const base64Url = token.split('.')[1];\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    // const decoded = atob(base64);\n    const decoded = Buffer.from(base64, 'base64').toString();\n    const jsonPayload = decodeURIComponent(decoded.split('').map(function (c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n    return JSON.parse(jsonPayload);\n};\nexport const getLabFilePath = (jwtparsed) => {\n    var _a;\n    let labFilename = (_a = jwtparsed.lab_filepath) !== null && _a !== void 0 ? _a : Globals.DEFAULT_LAB_NAME;\n    // Replace labs/ prefix with empty string\n    // TODO: We need a more robust way to do this and not rely on the assumption that the lab is in the labs folder\n    // TODO: This is required as the createNew method will not automatically create the parent directories\n    labFilename = labFilename.replace('labs/', '');\n    return labFilename;\n};\n// eslint-disable-next-line @typescript-eslint/quotes\nexport const DEFAULT_CONTENT = {\n    cells: [\n        {\n            cell_type: 'code',\n            id: 'c852569f-bf26-4994-88e7-3b94874d3853',\n            metadata: {},\n            source: ['print(\"hello world again\")']\n        },\n        {\n            cell_type: 'markdown',\n            id: '5a2dc856-763a-4f12-b675-481ed971178a',\n            metadata: {},\n            source: ['this is markdown']\n        },\n        {\n            cell_type: 'raw',\n            id: '492a02e8-ec75-49f7-8560-b30256bca6af',\n            metadata: {},\n            source: ['this is raw']\n        }\n    ],\n    metadata: {\n        kernelspec: {\n            display_name: 'Python 3 (ipykernel)',\n            language: 'python',\n            name: 'python3'\n        },\n        language_info: {\n            codemirror_mode: { name: 'ipython', version: 3 },\n            file_extension: '.py',\n            mimetype: 'text/x-python',\n            name: 'python',\n            nbconvert_exporter: 'python',\n            pygments_lexer: 'ipython3',\n            version: '3.10.4'\n        }\n    },\n    nbformat: 4,\n    nbformat_minor: 5\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"names":[],"sourceRoot":""}