# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['meta_tags_parser']

package_data = \
{'': ['*']}

install_requires = \
['httpx']

setup_kwargs = {
    'name': 'meta-tags-parser',
    'version': '1.2.1',
    'description': 'Fast and modern meta tags parser (og, twitter, title, description, etc) with snippet support',
    'long_description': '# Meta tags parser\n[![Test, lint, publish](https://github.com/xfenix/meta-tags-parser/actions/workflows/main.yml/badge.svg)](https://github.com/xfenix/meta-tags-parser/actions/workflows/main.yml)\n[![PyPI version](https://badge.fury.io/py/meta-tags-parser.svg)](https://badge.fury.io/py/meta-tags-parser)\n[![Downloads](https://pepy.tech/badge/meta-tags-parser)](https://pepy.tech/project/meta-tags-parser)\n[![codecov](https://codecov.io/gh/xfenix/meta-tags-parser/branch/master/graph/badge.svg)](https://codecov.io/gh/xfenix/meta-tags-parser)\n<a href="https://github.com/psf/black"><img alt="Code style: black" src="https://img.shields.io/badge/code%20style-black-000000.svg"></a>\n[![Imports: isort](https://img.shields.io/badge/imports-isort-%231674b1?style=flat&labelColor=ef8336)](https://timothycrosley.github.io/isort/)\n\nFast, modern, pure python meta tags parser and snippet creator with full support of type annotations, py.typed in basic package and structured output. No jelly dicts, only typed structures!  \nIf you want to see what exactly is social media snippets, look at the example:\n![](https://raw.githubusercontent.com/xfenix/meta-tags-parser/master/social-media-snippets.png)\n\n## Requirements\n* Python 3.8+\n* [Httpx](https://www.python-httpx.org/)\n\n## Install\n`pip install meta-tags-parser`\n\n## Usage\n### TL:DR\n1. Parse meta tags from source:\n    ```python\n    from meta_tags_parser import parse_meta_tags_from_source, structs\n\n\n    desired_result: structs.TagsGroup = parse_meta_tags_from_source("""... html source ...""")\n    # desired_result — is what you want\n    ```\n1. Parse meta tags from url:\n    ```python\n    from meta_tags_parser import parse_tags_from_url, parse_tags_from_url_async, structs\n\n\n    desired_result: structs.TagsGroup = parse_tags_from_url("https://xfenix.ru")\n    # and async variant\n    desired_result: structs.TagsGroup = await parse_tags_from_url_async("https://xfenix.ru")\n    # desired_result — is what you want for both cases\n    ```\n1. Parse social media snippet from source:\n    ```python\n    from meta_tags_parser import parse_snippets_from_source, structs\n\n\n    snippet_obj: structs.SnippetGroup = parse_snippets_from_source("""... html source ...""")\n    # snippet_obj — is what you want\n    # access like snippet_obj.open_graph.title, ...\n    ```\n1. Parse social media snippet from url:\n    ```python\n    from meta_tags_parser import parse_snippets_from_url, parse_snippets_from_url_async, structs\n\n\n    snippet_obj: structs.SnippetGroup = parse_snippets_from_url("https://xfenix.ru")\n    # and async variant\n    snippet_obj: structs.SnippetGroup = await parse_snippets_from_url_async("https://xfenix.ru")\n    # snippet_obj — is what you want\n    # access like snippet_obj.open_graph.title, ...\n    ```\n\n**Huge note**: functions `*_from_url` written only for convenience and very error-prone, so any reconnections/error handling — completely on your side.  \nAlso, I don\'t want to add some bloated requirements to achieve robust connections for any users, because they may simply not await any of this from the library. But if you really need this — write me.\n\n### Basic snippets parsing\nLets say you want extract snippet for twitter from html page:\n```python\nfrom meta_tags_parser import parse_snippets_from_source, structs\n\n\nmy_result: structs.TagsGroup = parse_snippets_from_source("""\n    <meta property="og:card" content="summary_large_image">\n    <meta property="og:url" content="https://github.com/">\n    <meta property="og:title" content="Hello, my friend">\n    <meta property="og:description" content="Content here, yehehe">\n    <meta property="twitter:card" content="summary_large_image">\n    <meta property="twitter:url" content="https://github.com/">\n    <meta property="twitter:title" content="Hello, my friend">\n    <meta property="twitter:description" content="Content here, yehehe">\n""")\n\nprint(my_result)\n# What will be printed:\n"""\nSnippetGroup(\n    open_graph=SocialMediaSnippet(\n        title=\'Hello, my friend\',\n        description=\'Content here, yehehe\',\n        image=\'\',\n        url=\'https://github.com/\'\n    ),\n    twitter=SocialMediaSnippet(\n        title=\'Hello, my friend\',\n        description=\'Content here, yehehe\',\n        image=\'\',\n        url=\'https://github.com/\'\n    )\n)\n"""\n# You can access attributes as this\nmy_result.open_graph.title\nmy_result.twitter.image\n# All fields are necessary and will be always available, even if they have not contain data\n# So no need to worry about attributes exsitence (but you may need to check values)\n```\n\n### Basic meta tags parsing\nMain function is `parse_meta_tags_from_source`. It can be used like this:\n```python\nfrom meta_tags_parser import parse_meta_tags_from_source, structs\n\n\nmy_result: structs.TagsGroup = parse_meta_tags_from_source("""... html source ...""")\nprint(my_result)\n\n# What will be printed:\n"""\nstructs.TagsGroup(\n    title="...",\n    twitter=[\n        structs.OneMetaTag(\n            name="title", value="Hello",\n            ...\n        )\n    ],\n    open_graph=[\n        structs.OneMetaTag(\n            name="title", value="Hello",\n            ...\n        )\n    ],\n    basic=[\n        structs.OneMetaTag(\n            name="title", value="Hello",\n            ...\n        )\n    ],\n    other=[\n        structs.OneMetaTag(\n            name="article:name", value="Hello",\n            ...\n        )\n    ]\n)\n"""\n```\nAs you can see from this example, we are not using any jelly dicts, only structured dataclasses. Lets see another example:\n\n```python\nfrom meta_tags_parser import parse_meta_tags_from_source, structs\n\n\nmy_result: structs.TagsGroup = parse_meta_tags_from_source("""\n    <meta property="twitter:card" content="summary_large_image">\n    <meta property="twitter:url" content="https://github.com/">\n    <meta property="twitter:title" content="Hello, my friend">\n    <meta property="twitter:description" content="Content here, yehehe">\n""")\n\nprint(my_result)\n# What will be printed:\n"""\nTagsGroup(\n    title=\'\',\n    basic=[],\n    open_graph=[],\n    twitter=[\n        OneMetaTag(name=\'card\', value=\'summary_large_image\'),\n        OneMetaTag(name=\'url\', value=\'https://github.com/\'),\n        OneMetaTag(name=\'title\', value=\'Hello, my friend\'),\n        OneMetaTag(name=\'description\', value=\'Content here, yehehe\')\n    ],\n    other=[]\n)\n"""\n\nfor one_tag in my_result.twitter:\n    if one_tag.name == "title":\n        print(one_tag.value)\n# What will be printed:\n"""\nHello, my friend\n"""\n```\n\n### If you want to improve speed\nYou can specify what you want to parse:\n```python\nfrom meta_tags_parser import parse_meta_tags_from_source, structs\n\n\nresult: structs.TagsGroup = parse_meta_tags_from_source("""... source ...""",\n    what_to_parse=(WhatToParse.TITLE, WhatToParse.BASIC, WhatToParse.OPEN_GRAPH, WhatToParse.TWITTER, WhatToParse.OTHER)\n)\n```\nIf you reduce this tuple of parsing requirements it may increase overall parsing speed.\n\n## Important notes\n* Any name in meta tag (name or property attribute) will be lowercased\n* I decided to strip `og:` and `twitter:` from original attributes, and let dataclass structures carry this information. If parser met meta tag with property `og:name`, it will be available in `my_result` variable as one element of list `my_result.open_graph`\n* Title of page (e.g. `<title>Something</title>`) will be available as string `my_result.title` (of course, you recieve `Something`)\n* «Standart» tags like title, description (check full list here [./meta_tags_parser/structs.py](./meta_tags_parser/structs.py) in constant `BASIC_META_TAGS`) will be available as list in `my_result.basic`\n* Other tags will be available as list in `my_result.other` attribute, name of tags will be preserved, unlike `og:`/`twitter:` behaviour\n* If you want structured snippets, use `parse_snippets_from_source` function\n\n\n# Changelog\nYou can check https://github.com/xfenix/meta-tags-parser/releases/ release page.\n',
    'author': 'Denis Anikin',
    'author_email': 'ad@xfenix.ru',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/xfenix/meta-tags-parser/',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
