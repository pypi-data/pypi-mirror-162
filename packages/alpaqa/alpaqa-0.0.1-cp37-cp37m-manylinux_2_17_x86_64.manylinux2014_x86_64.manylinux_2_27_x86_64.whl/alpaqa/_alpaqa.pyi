from typing import Any, Callable, ClassVar, Optional, Tuple, Union

from typing import overload
import datetime
import flags
import numpy
ApproxKKT: PANOCStopCrit
ApproxKKT2: PANOCStopCrit
BasedOnCurvature: LBFGSStepsize
BasedOnGradientStepSize: LBFGSStepsize
Converged: SolverStatus
FPRNorm: PANOCStopCrit
FPRNorm2: PANOCStopCrit
Interrupted: SolverStatus
Ipopt: PANOCStopCrit
MaxIter: SolverStatus
MaxTime: SolverStatus
NoProgress: SolverStatus
NotFinite: SolverStatus
ProjGradNorm: PANOCStopCrit
ProjGradNorm2: PANOCStopCrit
ProjGradUnitNorm: PANOCStopCrit
ProjGradUnitNorm2: PANOCStopCrit
Unknown: SolverStatus

class ALMParams:
    M: float
    max_iter: int
    max_num_initial_retries: int
    max_num_retries: int
    max_time: datetime.timedelta
    max_total_num_retries: int
    preconditioning: bool
    print_interval: int
    single_penalty_factor: bool
    Δ: float
    Δ_lower: float
    Σ_0: float
    Σ_0_lower: float
    Σ_max: float
    Σ_min: float
    δ: float
    ε: float
    ε_0: float
    ε_0_increase: float
    θ: float
    ρ: float
    ρ_increase: float
    σ_0: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class ALMSolver:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, alm_params: Union[ALMParams,dict], panoc_solver: PANOCSolver) -> None: ...
    @overload
    def __init__(self, alm_params: Union[ALMParams,dict], pga_solver: PGASolver) -> None: ...
    @overload
    def __init__(self, alm_params: Union[ALMParams,dict], structuredpanoc_solver: StructuredPANOCLBFGSSolver) -> None: ...
    @overload
    def __init__(self, alm_params: Union[ALMParams,dict], inner_solver: InnerSolver) -> None: ...
    @overload
    def __init__(self, panoc_solver: PANOCSolver) -> None: ...
    @overload
    def __init__(self, pga_solver: PGASolver) -> None: ...
    @overload
    def __init__(self, structuredpanoc_solver: StructuredPANOCLBFGSSolver) -> None: ...
    @overload
    def __init__(self, inner_solver: InnerSolver) -> None: ...
    @overload
    def __init__(self, alm_params: ALMParams) -> None: ...
    def __call__(self, problem: Problem, x: Optional[numpy.ndarray[numpy.float64[m,1]]] = ..., y: Optional[numpy.ndarray[numpy.float64[m,1]]] = ...) -> Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],dict]: ...
    @property
    def inner_solver(self) -> InnerSolver: ...
    @property
    def params(self) -> ALMParams: ...

class Box:
    lowerbound: numpy.ndarray[numpy.float64[m,1]]
    upperbound: numpy.ndarray[numpy.float64[m,1]]
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, ub: numpy.ndarray[numpy.float64[m,1]], lb: numpy.ndarray[numpy.float64[m,1]]) -> None: ...

class EvalCounter:
    f: int
    g: int
    grad_f: int
    grad_g_prod: int
    grad_gi: int
    hess_L: int
    hess_L_prod: int
    time: EvalTimer
    def __init__(self, *args, **kwargs) -> None: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class EvalTimer:
    f: datetime.timedelta
    g: datetime.timedelta
    grad_f: datetime.timedelta
    grad_g_prod: datetime.timedelta
    grad_gi: datetime.timedelta
    hess_L: datetime.timedelta
    hess_L_prod: datetime.timedelta
    def __init__(self, *args, **kwargs) -> None: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class GAAPGAParams:
    L_max: float
    L_min: float
    Lipschitz: LipschitzEstimateParams
    full_flush_on_γ_change: bool
    limitedqr_mem: int
    max_iter: int
    max_no_progress: int
    max_time: datetime.timedelta
    print_interval: int
    quadratic_upperbound_tolerance_factor: float
    stop_crit: PANOCStopCrit
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class GAAPGAProgressInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def L(self) -> float: ...
    @property
    def fpr(self) -> float: ...
    @property
    def grad_ψ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def grad_ψ_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def k(self) -> int: ...
    @property
    def norm_sq_p(self) -> float: ...
    @property
    def p(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def y(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def Σ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def γ(self) -> float: ...
    @property
    def ε(self) -> float: ...
    @property
    def ψ(self) -> float: ...
    @property
    def ψ_hat(self) -> float: ...

class GAAPGASolver(InnerSolver):
    def __init__(self, arg0: GAAPGAParams) -> None: ...
    def set_progress_callback(self, callback: Callable[[GAAPGAProgressInfo],None]) -> None: ...
    def __call__(self, problem: Problem, Σ: numpy.ndarray[numpy.float64[m,1]], ε: float, x: numpy.ndarray[numpy.float64[m,1]], y: numpy.ndarray[numpy.float64[m,1]]) -> Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],dict]: ...
    @property
    def params(self) -> object: ...

class InnerSolver:
    def __init__(self) -> None: ...
    def get_name(self) -> str: ...
    def get_params(self) -> object: ...
    def stop(self) -> None: ...
    def __call__(self, arg0: Problem, arg1: numpy.ndarray[numpy.float64[m,1]], arg2: float, arg3: bool, arg4: numpy.ndarray[numpy.float64[m,1],flags.writeable], arg5: numpy.ndarray[numpy.float64[m,1],flags.writeable], arg6: numpy.ndarray[numpy.float64[m,1],flags.writeable]) -> InnerSolverStats: ...

class InnerSolverStats:
    def __init__(self, arg0: dict) -> None: ...

class LBFGSDirection(PANOCDirection):
    def __init__(self, params: LBFGSParams) -> None: ...
    def apply(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: float) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def changed_γ(self, arg0: float, arg1: float) -> None: ...
    def get_name(self) -> str: ...
    def initialize(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def reset(self) -> None: ...
    def update(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: numpy.ndarray[numpy.float64[m,1]], arg4: numpy.ndarray[numpy.float64[m,1]], arg5: Box, arg6: float) -> bool: ...
    @property
    def params(self) -> object: ...

class LBFGSParams:
    cbfgs: LBFGSParamsCBFGS
    memory: int
    rescale_when_γ_changes: bool
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class LBFGSParamsCBFGS:
    α: float
    ϵ: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class LBFGSStepsize:
    __members__: ClassVar[dict] = ...  # read-only
    BasedOnCurvature: ClassVar[LBFGSStepsize] = ...
    BasedOnGradientStepSize: ClassVar[LBFGSStepsize] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LipschitzEstimateParams:
    L_0: float
    Lγ_factor: float
    δ: float
    ε: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class PANOCDirection:
    def __init__(self) -> None: ...
    def apply(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: float) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def changed_γ(self, arg0: float, arg1: float) -> None: ...
    def get_name(self) -> str: ...
    def initialize(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def reset(self) -> None: ...
    def update(self, arg0: numpy.ndarray[numpy.float64[m,1]], arg1: numpy.ndarray[numpy.float64[m,1]], arg2: numpy.ndarray[numpy.float64[m,1]], arg3: numpy.ndarray[numpy.float64[m,1]], arg4: numpy.ndarray[numpy.float64[m,1]], arg5: Box, arg6: float) -> bool: ...

class PANOCParams:
    L_max: float
    L_min: float
    Lipschitz: LipschitzEstimateParams
    alternative_linesearch_cond: bool
    lbfgs_stepsize: LBFGSStepsize
    max_iter: int
    max_no_progress: int
    max_time: datetime.timedelta
    print_interval: int
    quadratic_upperbound_tolerance_factor: float
    update_lipschitz_in_linesearch: bool
    τ_min: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class PANOCProgressInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def L(self) -> float: ...
    @property
    def fpr(self) -> float: ...
    @property
    def grad_ψ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def grad_ψ_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def k(self) -> int: ...
    @property
    def norm_sq_p(self) -> float: ...
    @property
    def p(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def y(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def Σ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def γ(self) -> float: ...
    @property
    def ε(self) -> float: ...
    @property
    def τ(self) -> float: ...
    @property
    def φγ(self) -> float: ...
    @property
    def ψ(self) -> float: ...
    @property
    def ψ_hat(self) -> float: ...

class PANOCSolver(InnerSolver):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, panoc_params: Union[PANOCParams,dict], lbfgs_direction: LBFGSDirection) -> None: ...
    @overload
    def __init__(self, panoc_params: Union[PANOCParams,dict], lbfgs_params: Union[LBFGSParams,dict]) -> None: ...
    @overload
    def __init__(self, panoc_params: Union[PANOCParams,dict], direction: PANOCDirection) -> None: ...
    def set_progress_callback(self, callback: Callable[[PANOCProgressInfo],None]) -> None: ...
    def __call__(self, problem: Problem, Σ: numpy.ndarray[numpy.float64[m,1]], ε: float, x: numpy.ndarray[numpy.float64[m,1]], y: numpy.ndarray[numpy.float64[m,1]]) -> Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],dict]: ...
    @property
    def direction(self) -> PANOCDirection: ...
    @property
    def params(self) -> object: ...

class PANOCStopCrit:
    __members__: ClassVar[dict] = ...  # read-only
    ApproxKKT: ClassVar[PANOCStopCrit] = ...
    ApproxKKT2: ClassVar[PANOCStopCrit] = ...
    FPRNorm: ClassVar[PANOCStopCrit] = ...
    FPRNorm2: ClassVar[PANOCStopCrit] = ...
    Ipopt: ClassVar[PANOCStopCrit] = ...
    ProjGradNorm: ClassVar[PANOCStopCrit] = ...
    ProjGradNorm2: ClassVar[PANOCStopCrit] = ...
    ProjGradUnitNorm: ClassVar[PANOCStopCrit] = ...
    ProjGradUnitNorm2: ClassVar[PANOCStopCrit] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PGAParams:
    L_max: float
    L_min: float
    Lipschitz: LipschitzEstimateParams
    max_iter: int
    max_time: datetime.timedelta
    print_interval: int
    quadratic_upperbound_tolerance_factor: float
    stop_crit: PANOCStopCrit
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class PGAProgressInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def L(self) -> float: ...
    @property
    def fpr(self) -> float: ...
    @property
    def grad_ψ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def grad_ψ_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def k(self) -> int: ...
    @property
    def norm_sq_p(self) -> float: ...
    @property
    def p(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def y(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def Σ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def γ(self) -> float: ...
    @property
    def ε(self) -> float: ...
    @property
    def ψ(self) -> float: ...
    @property
    def ψ_hat(self) -> float: ...

class PGASolver(InnerSolver):
    def __init__(self, arg0: PGAParams) -> None: ...
    def set_progress_callback(self, callback: Callable[[PGAProgressInfo],None]) -> None: ...
    def __call__(self, problem: Problem, Σ: numpy.ndarray[numpy.float64[m,1]], ε: float, x: numpy.ndarray[numpy.float64[m,1]], y: numpy.ndarray[numpy.float64[m,1]]) -> Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],dict]: ...
    @property
    def params(self) -> object: ...

class Problem:
    C: Box
    D: Box
    f: Any
    g: Any
    grad_f: Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]
    grad_g_prod: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]
    grad_gi: Callable[[numpy.ndarray[numpy.float64[m,1]],int],numpy.ndarray[numpy.float64[m,1]]]
    hess_L: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,n]]]
    hess_L_prod: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]
    m: int
    n: int
    def __init__(self, n: int, m: int) -> None: ...

class ProblemWithCounters(Problem):
    C: Box
    D: Box
    m: int
    n: int
    def __init__(self, problem: Problem) -> None: ...
    @property
    def evaluations(self) -> EvalCounter: ...
    @property
    def f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],float]: ...
    @property
    def g(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_g_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_gi(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],int],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def hess_L(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,n]]]: ...
    @property
    def hess_L_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...

class ProblemWithParam(Problem):
    C: Box
    D: Box
    m: int
    n: int
    param: numpy.ndarray[numpy.float64[m,1]]
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],float]: ...
    @property
    def g(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_g_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_gi(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],int],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def hess_L(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,n]]]: ...
    @property
    def hess_L_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...

class ProblemWithParamWithCounters(ProblemWithParam):
    C: Box
    D: Box
    m: int
    n: int
    param: numpy.ndarray[numpy.float64[m,1]]
    def __init__(self, problem: ProblemWithParam) -> None: ...
    @property
    def evaluations(self) -> EvalCounter: ...
    @property
    def f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],float]: ...
    @property
    def g(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_f(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_g_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def grad_gi(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],int],numpy.ndarray[numpy.float64[m,1]]]: ...
    @property
    def hess_L(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,n]]]: ...
    @property
    def hess_L_prod(self) -> Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]]: ...

class SolverStatus:
    __members__: ClassVar[dict] = ...  # read-only
    Converged: ClassVar[SolverStatus] = ...
    Interrupted: ClassVar[SolverStatus] = ...
    MaxIter: ClassVar[SolverStatus] = ...
    MaxTime: ClassVar[SolverStatus] = ...
    NoProgress: ClassVar[SolverStatus] = ...
    NotFinite: ClassVar[SolverStatus] = ...
    Unknown: ClassVar[SolverStatus] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StructuredPANOCLBFGSParams:
    L_max: float
    L_min: float
    Lipschitz: LipschitzEstimateParams
    alternative_linesearch_cond: bool
    full_augmented_hessian: bool
    hessian_step_size_heuristic: int
    hessian_vec: bool
    hessian_vec_finite_differences: bool
    lbfgs_stepsize: LBFGSStepsize
    max_iter: int
    max_no_progress: int
    max_time: datetime.timedelta
    nonmonotone_linesearch: float
    print_interval: int
    quadratic_upperbound_tolerance_factor: float
    stop_crit: PANOCStopCrit
    update_lipschitz_in_linesearch: bool
    τ_min: float
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self) -> dict: ...

class StructuredPANOCLBFGSProgressInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def L(self) -> float: ...
    @property
    def fpr(self) -> float: ...
    @property
    def grad_ψ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def grad_ψ_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def k(self) -> int: ...
    @property
    def norm_sq_p(self) -> float: ...
    @property
    def p(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def x_hat(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def y(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def Σ(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    @property
    def γ(self) -> float: ...
    @property
    def ε(self) -> float: ...
    @property
    def τ(self) -> float: ...
    @property
    def φγ(self) -> float: ...
    @property
    def ψ(self) -> float: ...
    @property
    def ψ_hat(self) -> float: ...

class StructuredPANOCLBFGSSolver(InnerSolver):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, panoc_params: Union[StructuredPANOCLBFGSParams,dict], lbfgs_params: Union[LBFGSParams,dict]) -> None: ...
    def set_progress_callback(self, callback: Callable[[StructuredPANOCLBFGSProgressInfo],None]) -> None: ...
    def __call__(self, problem: Problem, Σ: numpy.ndarray[numpy.float64[m,1]], ε: float, x: numpy.ndarray[numpy.float64[m,1]], y: numpy.ndarray[numpy.float64[m,1]]) -> Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]],dict]: ...
    @property
    def params(self) -> object: ...

def load_casadi_problem(so_name: str, n: int = ..., m: int = ..., second_order: bool = ...) -> Problem: ...
def load_casadi_problem_with_param(so_name: str, n: int = ..., m: int = ..., p: int = ..., second_order: bool = ...) -> ProblemWithParam: ...
def panoc(ψ: Callable[[numpy.ndarray[numpy.float64[m,1]]],float], grad_ψ: Callable[[numpy.ndarray[numpy.float64[m,1]]],numpy.ndarray[numpy.float64[m,1]]], C: Box, x0: Optional[numpy.ndarray[numpy.float64[m,1]]] = ..., ε: float = ..., params: PANOCParams = ..., lbfgs_params: LBFGSParams = ...) -> Tuple[numpy.ndarray[numpy.float64[m,1]],dict]: ...
