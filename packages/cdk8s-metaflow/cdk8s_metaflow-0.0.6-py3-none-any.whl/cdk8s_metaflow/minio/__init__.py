import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import cdk8s
import constructs


class Tenant(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.Tenant",
):
    '''
    :stability: experimental
    :schema: Tenant
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        spec: typing.Union["TenantSpec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantScheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Defines a "Tenant" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Tenant.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = TenantProps(spec=spec, metadata=metadata, scheduler=scheduler)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest") # type: ignore[misc]
    @builtins.classmethod
    def manifest(
        cls,
        *,
        spec: typing.Union["TenantSpec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantScheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''(experimental) Renders a Kubernetes manifest for "Tenant".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        '''
        props = TenantProps(spec=spec, metadata=metadata, scheduler=scheduler)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''(experimental) Renders the object to Kubernetes JSON.

        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''(experimental) Returns the apiVersion and kind for "Tenant".

        :stability: experimental
        '''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantProps",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata", "scheduler": "scheduler"},
)
class TenantProps:
    def __init__(
        self,
        *,
        spec: typing.Union["TenantSpec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantScheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        :schema: Tenant
        '''
        if isinstance(spec, dict):
            spec = TenantSpec(**spec)
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(scheduler, dict):
            scheduler = TenantScheduler(**scheduler)
        if __debug__:
            type_hints = typing.get_type_hints(TenantProps.__init__)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument scheduler", value=scheduler, expected_type=type_hints["scheduler"])
        self._values: typing.Dict[str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata
        if scheduler is not None:
            self._values["scheduler"] = scheduler

    @builtins.property
    def spec(self) -> "TenantSpec":
        '''
        :stability: experimental
        :schema: Tenant#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("TenantSpec", result)

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :stability: experimental
        :schema: Tenant#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def scheduler(self) -> typing.Optional["TenantScheduler"]:
        '''
        :stability: experimental
        :schema: Tenant#scheduler
        '''
        result = self._values.get("scheduler")
        return typing.cast(typing.Optional["TenantScheduler"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantScheduler",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantScheduler:
    def __init__(self, *, name: builtins.str) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantScheduler
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantScheduler.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantScheduler#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantScheduler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpec",
    jsii_struct_bases=[],
    name_mapping={
        "zones": "zones",
        "cert_config": "certConfig",
        "configuration": "configuration",
        "creds_secret": "credsSecret",
        "env": "env",
        "expose_services": "exposeServices",
        "external_ca_cert_secret": "externalCaCertSecret",
        "external_cert_secret": "externalCertSecret",
        "external_client_cert_secret": "externalClientCertSecret",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "image_pull_secret": "imagePullSecret",
        "kes": "kes",
        "log": "log",
        "mount_path": "mountPath",
        "pod_management_policy": "podManagementPolicy",
        "priority_class_name": "priorityClassName",
        "prometheus": "prometheus",
        "request_auto_cert": "requestAutoCert",
        "s3": "s3",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "side_cars": "sideCars",
        "sub_path": "subPath",
        "users": "users",
    },
)
class TenantSpec:
    def __init__(
        self,
        *,
        zones: typing.Sequence[typing.Union["TenantSpecZones", typing.Dict[str, typing.Any]]],
        cert_config: typing.Optional[typing.Union["TenantSpecCertConfig", typing.Dict[str, typing.Any]]] = None,
        configuration: typing.Optional[typing.Union["TenantSpecConfiguration", typing.Dict[str, typing.Any]]] = None,
        creds_secret: typing.Optional[typing.Union["TenantSpecCredsSecret", typing.Dict[str, typing.Any]]] = None,
        env: typing.Optional[typing.Sequence[typing.Union["TenantSpecEnv", typing.Dict[str, typing.Any]]]] = None,
        expose_services: typing.Optional[typing.Union["TenantSpecExposeServices", typing.Dict[str, typing.Any]]] = None,
        external_ca_cert_secret: typing.Optional[typing.Sequence[typing.Union["TenantSpecExternalCaCertSecret", typing.Dict[str, typing.Any]]]] = None,
        external_cert_secret: typing.Optional[typing.Sequence[typing.Union["TenantSpecExternalCertSecret", typing.Dict[str, typing.Any]]]] = None,
        external_client_cert_secret: typing.Optional[typing.Union["TenantSpecExternalClientCertSecret", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        image_pull_secret: typing.Optional[typing.Union["TenantSpecImagePullSecret", typing.Dict[str, typing.Any]]] = None,
        kes: typing.Optional[typing.Union["TenantSpecKes", typing.Dict[str, typing.Any]]] = None,
        log: typing.Optional[typing.Union["TenantSpecLog", typing.Dict[str, typing.Any]]] = None,
        mount_path: typing.Optional[builtins.str] = None,
        pod_management_policy: typing.Optional[builtins.str] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        prometheus: typing.Optional[typing.Union["TenantSpecPrometheus", typing.Dict[str, typing.Any]]] = None,
        request_auto_cert: typing.Optional[builtins.bool] = None,
        s3: typing.Optional[typing.Union["TenantSpecS3", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        side_cars: typing.Optional[typing.Union["TenantSpecSideCars", typing.Dict[str, typing.Any]]] = None,
        sub_path: typing.Optional[builtins.str] = None,
        users: typing.Optional[typing.Sequence[typing.Union["TenantSpecUsers", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param zones: 
        :param cert_config: 
        :param configuration: 
        :param creds_secret: 
        :param env: 
        :param expose_services: 
        :param external_ca_cert_secret: 
        :param external_cert_secret: 
        :param external_client_cert_secret: 
        :param image: 
        :param image_pull_policy: 
        :param image_pull_secret: 
        :param kes: 
        :param log: 
        :param mount_path: 
        :param pod_management_policy: 
        :param priority_class_name: 
        :param prometheus: 
        :param request_auto_cert: 
        :param s3: 
        :param security_context: 
        :param service_account_name: 
        :param side_cars: 
        :param sub_path: 
        :param users: 

        :stability: experimental
        :schema: TenantSpec
        '''
        if isinstance(cert_config, dict):
            cert_config = TenantSpecCertConfig(**cert_config)
        if isinstance(configuration, dict):
            configuration = TenantSpecConfiguration(**configuration)
        if isinstance(creds_secret, dict):
            creds_secret = TenantSpecCredsSecret(**creds_secret)
        if isinstance(expose_services, dict):
            expose_services = TenantSpecExposeServices(**expose_services)
        if isinstance(external_client_cert_secret, dict):
            external_client_cert_secret = TenantSpecExternalClientCertSecret(**external_client_cert_secret)
        if isinstance(image_pull_secret, dict):
            image_pull_secret = TenantSpecImagePullSecret(**image_pull_secret)
        if isinstance(kes, dict):
            kes = TenantSpecKes(**kes)
        if isinstance(log, dict):
            log = TenantSpecLog(**log)
        if isinstance(prometheus, dict):
            prometheus = TenantSpecPrometheus(**prometheus)
        if isinstance(s3, dict):
            s3 = TenantSpecS3(**s3)
        if isinstance(security_context, dict):
            security_context = TenantSpecSecurityContext(**security_context)
        if isinstance(side_cars, dict):
            side_cars = TenantSpecSideCars(**side_cars)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpec.__init__)
            check_type(argname="argument zones", value=zones, expected_type=type_hints["zones"])
            check_type(argname="argument cert_config", value=cert_config, expected_type=type_hints["cert_config"])
            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
            check_type(argname="argument creds_secret", value=creds_secret, expected_type=type_hints["creds_secret"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument expose_services", value=expose_services, expected_type=type_hints["expose_services"])
            check_type(argname="argument external_ca_cert_secret", value=external_ca_cert_secret, expected_type=type_hints["external_ca_cert_secret"])
            check_type(argname="argument external_cert_secret", value=external_cert_secret, expected_type=type_hints["external_cert_secret"])
            check_type(argname="argument external_client_cert_secret", value=external_client_cert_secret, expected_type=type_hints["external_client_cert_secret"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument image_pull_secret", value=image_pull_secret, expected_type=type_hints["image_pull_secret"])
            check_type(argname="argument kes", value=kes, expected_type=type_hints["kes"])
            check_type(argname="argument log", value=log, expected_type=type_hints["log"])
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument pod_management_policy", value=pod_management_policy, expected_type=type_hints["pod_management_policy"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument prometheus", value=prometheus, expected_type=type_hints["prometheus"])
            check_type(argname="argument request_auto_cert", value=request_auto_cert, expected_type=type_hints["request_auto_cert"])
            check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument side_cars", value=side_cars, expected_type=type_hints["side_cars"])
            check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            check_type(argname="argument users", value=users, expected_type=type_hints["users"])
        self._values: typing.Dict[str, typing.Any] = {
            "zones": zones,
        }
        if cert_config is not None:
            self._values["cert_config"] = cert_config
        if configuration is not None:
            self._values["configuration"] = configuration
        if creds_secret is not None:
            self._values["creds_secret"] = creds_secret
        if env is not None:
            self._values["env"] = env
        if expose_services is not None:
            self._values["expose_services"] = expose_services
        if external_ca_cert_secret is not None:
            self._values["external_ca_cert_secret"] = external_ca_cert_secret
        if external_cert_secret is not None:
            self._values["external_cert_secret"] = external_cert_secret
        if external_client_cert_secret is not None:
            self._values["external_client_cert_secret"] = external_client_cert_secret
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if image_pull_secret is not None:
            self._values["image_pull_secret"] = image_pull_secret
        if kes is not None:
            self._values["kes"] = kes
        if log is not None:
            self._values["log"] = log
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if pod_management_policy is not None:
            self._values["pod_management_policy"] = pod_management_policy
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if prometheus is not None:
            self._values["prometheus"] = prometheus
        if request_auto_cert is not None:
            self._values["request_auto_cert"] = request_auto_cert
        if s3 is not None:
            self._values["s3"] = s3
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if side_cars is not None:
            self._values["side_cars"] = side_cars
        if sub_path is not None:
            self._values["sub_path"] = sub_path
        if users is not None:
            self._values["users"] = users

    @builtins.property
    def zones(self) -> typing.List["TenantSpecZones"]:
        '''
        :stability: experimental
        :schema: TenantSpec#zones
        '''
        result = self._values.get("zones")
        assert result is not None, "Required property 'zones' is missing"
        return typing.cast(typing.List["TenantSpecZones"], result)

    @builtins.property
    def cert_config(self) -> typing.Optional["TenantSpecCertConfig"]:
        '''
        :stability: experimental
        :schema: TenantSpec#certConfig
        '''
        result = self._values.get("cert_config")
        return typing.cast(typing.Optional["TenantSpecCertConfig"], result)

    @builtins.property
    def configuration(self) -> typing.Optional["TenantSpecConfiguration"]:
        '''
        :stability: experimental
        :schema: TenantSpec#configuration
        '''
        result = self._values.get("configuration")
        return typing.cast(typing.Optional["TenantSpecConfiguration"], result)

    @builtins.property
    def creds_secret(self) -> typing.Optional["TenantSpecCredsSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpec#credsSecret
        '''
        result = self._values.get("creds_secret")
        return typing.cast(typing.Optional["TenantSpecCredsSecret"], result)

    @builtins.property
    def env(self) -> typing.Optional[typing.List["TenantSpecEnv"]]:
        '''
        :stability: experimental
        :schema: TenantSpec#env
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.List["TenantSpecEnv"]], result)

    @builtins.property
    def expose_services(self) -> typing.Optional["TenantSpecExposeServices"]:
        '''
        :stability: experimental
        :schema: TenantSpec#exposeServices
        '''
        result = self._values.get("expose_services")
        return typing.cast(typing.Optional["TenantSpecExposeServices"], result)

    @builtins.property
    def external_ca_cert_secret(
        self,
    ) -> typing.Optional[typing.List["TenantSpecExternalCaCertSecret"]]:
        '''
        :stability: experimental
        :schema: TenantSpec#externalCaCertSecret
        '''
        result = self._values.get("external_ca_cert_secret")
        return typing.cast(typing.Optional[typing.List["TenantSpecExternalCaCertSecret"]], result)

    @builtins.property
    def external_cert_secret(
        self,
    ) -> typing.Optional[typing.List["TenantSpecExternalCertSecret"]]:
        '''
        :stability: experimental
        :schema: TenantSpec#externalCertSecret
        '''
        result = self._values.get("external_cert_secret")
        return typing.cast(typing.Optional[typing.List["TenantSpecExternalCertSecret"]], result)

    @builtins.property
    def external_client_cert_secret(
        self,
    ) -> typing.Optional["TenantSpecExternalClientCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpec#externalClientCertSecret
        '''
        result = self._values.get("external_client_cert_secret")
        return typing.cast(typing.Optional["TenantSpecExternalClientCertSecret"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_secret(self) -> typing.Optional["TenantSpecImagePullSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpec#imagePullSecret
        '''
        result = self._values.get("image_pull_secret")
        return typing.cast(typing.Optional["TenantSpecImagePullSecret"], result)

    @builtins.property
    def kes(self) -> typing.Optional["TenantSpecKes"]:
        '''
        :stability: experimental
        :schema: TenantSpec#kes
        '''
        result = self._values.get("kes")
        return typing.cast(typing.Optional["TenantSpecKes"], result)

    @builtins.property
    def log(self) -> typing.Optional["TenantSpecLog"]:
        '''
        :stability: experimental
        :schema: TenantSpec#log
        '''
        result = self._values.get("log")
        return typing.cast(typing.Optional["TenantSpecLog"], result)

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_management_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#podManagementPolicy
        '''
        result = self._values.get("pod_management_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prometheus(self) -> typing.Optional["TenantSpecPrometheus"]:
        '''
        :stability: experimental
        :schema: TenantSpec#prometheus
        '''
        result = self._values.get("prometheus")
        return typing.cast(typing.Optional["TenantSpecPrometheus"], result)

    @builtins.property
    def request_auto_cert(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpec#requestAutoCert
        '''
        result = self._values.get("request_auto_cert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def s3(self) -> typing.Optional["TenantSpecS3"]:
        '''
        :stability: experimental
        :schema: TenantSpec#s3
        '''
        result = self._values.get("s3")
        return typing.cast(typing.Optional["TenantSpecS3"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantSpecSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpec#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def side_cars(self) -> typing.Optional["TenantSpecSideCars"]:
        '''
        :stability: experimental
        :schema: TenantSpec#sideCars
        '''
        result = self._values.get("side_cars")
        return typing.cast(typing.Optional["TenantSpecSideCars"], result)

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpec#subPath
        '''
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def users(self) -> typing.Optional[typing.List["TenantSpecUsers"]]:
        '''
        :stability: experimental
        :schema: TenantSpec#users
        '''
        result = self._values.get("users")
        return typing.cast(typing.Optional[typing.List["TenantSpecUsers"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecCertConfig",
    jsii_struct_bases=[],
    name_mapping={
        "common_name": "commonName",
        "dns_names": "dnsNames",
        "organization_name": "organizationName",
    },
)
class TenantSpecCertConfig:
    def __init__(
        self,
        *,
        common_name: typing.Optional[builtins.str] = None,
        dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        organization_name: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param common_name: 
        :param dns_names: 
        :param organization_name: 

        :stability: experimental
        :schema: TenantSpecCertConfig
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecCertConfig.__init__)
            check_type(argname="argument common_name", value=common_name, expected_type=type_hints["common_name"])
            check_type(argname="argument dns_names", value=dns_names, expected_type=type_hints["dns_names"])
            check_type(argname="argument organization_name", value=organization_name, expected_type=type_hints["organization_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if common_name is not None:
            self._values["common_name"] = common_name
        if dns_names is not None:
            self._values["dns_names"] = dns_names
        if organization_name is not None:
            self._values["organization_name"] = organization_name

    @builtins.property
    def common_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecCertConfig#commonName
        '''
        result = self._values.get("common_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecCertConfig#dnsNames
        '''
        result = self._values.get("dns_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def organization_name(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecCertConfig#organizationName
        '''
        result = self._values.get("organization_name")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecCertConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecConfiguration",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecConfiguration:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecConfiguration
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecConfiguration.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecConfiguration#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecCredsSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecCredsSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecCredsSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecCredsSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecCredsSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecCredsSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class TenantSpecEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[typing.Union["TenantSpecEnvValueFrom", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param value: 
        :param value_from: 

        :stability: experimental
        :schema: TenantSpecEnv
        '''
        if isinstance(value_from, dict):
            value_from = TenantSpecEnvValueFrom(**value_from)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnv.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_from", value=value_from, expected_type=type_hints["value_from"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecEnv#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecEnv#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(self) -> typing.Optional["TenantSpecEnvValueFrom"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnv#valueFrom
        '''
        result = self._values.get("value_from")
        return typing.cast(typing.Optional["TenantSpecEnvValueFrom"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class TenantSpecEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[typing.Union["TenantSpecEnvValueFromConfigMapKeyRef", typing.Dict[str, typing.Any]]] = None,
        field_ref: typing.Optional[typing.Union["TenantSpecEnvValueFromFieldRef", typing.Dict[str, typing.Any]]] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantSpecEnvValueFromResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
        secret_key_ref: typing.Optional[typing.Union["TenantSpecEnvValueFromSecretKeyRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_key_ref: 
        :param field_ref: 
        :param resource_field_ref: 
        :param secret_key_ref: 

        :stability: experimental
        :schema: TenantSpecEnvValueFrom
        '''
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = TenantSpecEnvValueFromConfigMapKeyRef(**config_map_key_ref)
        if isinstance(field_ref, dict):
            field_ref = TenantSpecEnvValueFromFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantSpecEnvValueFromResourceFieldRef(**resource_field_ref)
        if isinstance(secret_key_ref, dict):
            secret_key_ref = TenantSpecEnvValueFromSecretKeyRef(**secret_key_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFrom.__init__)
            check_type(argname="argument config_map_key_ref", value=config_map_key_ref, expected_type=type_hints["config_map_key_ref"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
            check_type(argname="argument secret_key_ref", value=secret_key_ref, expected_type=type_hints["secret_key_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional["TenantSpecEnvValueFromConfigMapKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFrom#configMapKeyRef
        '''
        result = self._values.get("config_map_key_ref")
        return typing.cast(typing.Optional["TenantSpecEnvValueFromConfigMapKeyRef"], result)

    @builtins.property
    def field_ref(self) -> typing.Optional["TenantSpecEnvValueFromFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFrom#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantSpecEnvValueFromFieldRef"], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantSpecEnvValueFromResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFrom#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantSpecEnvValueFromResourceFieldRef"], result)

    @builtins.property
    def secret_key_ref(self) -> typing.Optional["TenantSpecEnvValueFromSecretKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFrom#secretKeyRef
        '''
        result = self._values.get("secret_key_ref")
        return typing.cast(typing.Optional["TenantSpecEnvValueFromSecretKeyRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantSpecEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecEnvValueFromConfigMapKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromConfigMapKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromConfigMapKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromConfigMapKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromConfigMapKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnvValueFromConfigMapKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantSpecEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantSpecEnvValueFromFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnvValueFromFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantSpecEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantSpecEnvValueFromResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantSpecEnvValueFromResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantSpecEnvValueFromResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantSpecEnvValueFromResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnvValueFromResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecEnvValueFromResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFromResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantSpecEnvValueFromResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantSpecEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecEnvValueFromSecretKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecEnvValueFromSecretKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromSecretKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromSecretKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecEnvValueFromSecretKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecEnvValueFromSecretKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecExposeServices",
    jsii_struct_bases=[],
    name_mapping={"console": "console", "minio": "minio"},
)
class TenantSpecExposeServices:
    def __init__(
        self,
        *,
        console: typing.Optional[builtins.bool] = None,
        minio: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param console: 
        :param minio: 

        :stability: experimental
        :schema: TenantSpecExposeServices
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecExposeServices.__init__)
            check_type(argname="argument console", value=console, expected_type=type_hints["console"])
            check_type(argname="argument minio", value=minio, expected_type=type_hints["minio"])
        self._values: typing.Dict[str, typing.Any] = {}
        if console is not None:
            self._values["console"] = console
        if minio is not None:
            self._values["minio"] = minio

    @builtins.property
    def console(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecExposeServices#console
        '''
        result = self._values.get("console")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def minio(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecExposeServices#minio
        '''
        result = self._values.get("minio")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecExposeServices(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecExternalCaCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantSpecExternalCaCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecExternalCaCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecExternalCaCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecExternalCaCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecExternalCaCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecExternalCaCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecExternalCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantSpecExternalCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecExternalCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecExternalCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecExternalCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecExternalCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecExternalCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecExternalClientCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantSpecExternalClientCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecExternalClientCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecExternalClientCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecExternalClientCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecExternalClientCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecExternalClientCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecImagePullSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecImagePullSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecImagePullSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecImagePullSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecImagePullSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecImagePullSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKes",
    jsii_struct_bases=[],
    name_mapping={
        "kes_secret": "kesSecret",
        "affinity": "affinity",
        "annotations": "annotations",
        "client_cert_secret": "clientCertSecret",
        "external_cert_secret": "externalCertSecret",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "key_name": "keyName",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "replicas": "replicas",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantSpecKes:
    def __init__(
        self,
        *,
        kes_secret: typing.Union["TenantSpecKesKesSecret", typing.Dict[str, typing.Any]],
        affinity: typing.Optional[typing.Union["TenantSpecKesAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        client_cert_secret: typing.Optional[typing.Union["TenantSpecKesClientCertSecret", typing.Dict[str, typing.Any]]] = None,
        external_cert_secret: typing.Optional[typing.Union["TenantSpecKesExternalCertSecret", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        replicas: typing.Optional[jsii.Number] = None,
        resources: typing.Optional[typing.Union["TenantSpecKesResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecKesSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param kes_secret: 
        :param affinity: 
        :param annotations: 
        :param client_cert_secret: 
        :param external_cert_secret: 
        :param image: 
        :param image_pull_policy: 
        :param key_name: 
        :param labels: 
        :param node_selector: 
        :param replicas: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantSpecKes
        '''
        if isinstance(kes_secret, dict):
            kes_secret = TenantSpecKesKesSecret(**kes_secret)
        if isinstance(affinity, dict):
            affinity = TenantSpecKesAffinity(**affinity)
        if isinstance(client_cert_secret, dict):
            client_cert_secret = TenantSpecKesClientCertSecret(**client_cert_secret)
        if isinstance(external_cert_secret, dict):
            external_cert_secret = TenantSpecKesExternalCertSecret(**external_cert_secret)
        if isinstance(resources, dict):
            resources = TenantSpecKesResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecKesSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKes.__init__)
            check_type(argname="argument kes_secret", value=kes_secret, expected_type=type_hints["kes_secret"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument client_cert_secret", value=client_cert_secret, expected_type=type_hints["client_cert_secret"])
            check_type(argname="argument external_cert_secret", value=external_cert_secret, expected_type=type_hints["external_cert_secret"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument replicas", value=replicas, expected_type=type_hints["replicas"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "kes_secret": kes_secret,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if client_cert_secret is not None:
            self._values["client_cert_secret"] = client_cert_secret
        if external_cert_secret is not None:
            self._values["external_cert_secret"] = external_cert_secret
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if key_name is not None:
            self._values["key_name"] = key_name
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if replicas is not None:
            self._values["replicas"] = replicas
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def kes_secret(self) -> "TenantSpecKesKesSecret":
        '''
        :stability: experimental
        :schema: TenantSpecKes#kesSecret
        '''
        result = self._values.get("kes_secret")
        assert result is not None, "Required property 'kes_secret' is missing"
        return typing.cast("TenantSpecKesKesSecret", result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantSpecKesAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantSpecKesAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def client_cert_secret(self) -> typing.Optional["TenantSpecKesClientCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#clientCertSecret
        '''
        result = self._values.get("client_cert_secret")
        return typing.cast(typing.Optional["TenantSpecKesClientCertSecret"], result)

    @builtins.property
    def external_cert_secret(
        self,
    ) -> typing.Optional["TenantSpecKesExternalCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#externalCertSecret
        '''
        result = self._values.get("external_cert_secret")
        return typing.cast(typing.Optional["TenantSpecKesExternalCertSecret"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#keyName
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def replicas(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#replicas
        '''
        result = self._values.get("replicas")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecKesResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecKesResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantSpecKesSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecKesSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantSpecKesTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKes#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantSpecKesAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantSpecKesAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantSpecKesAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantSpecKesAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantSpecKesAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantSpecKesAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantSpecKesAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantSpecKesAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantSpecKesAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantSpecKesAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantSpecKesAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecKesAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecKesAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecKesAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesClientCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantSpecKesClientCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecKesClientCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesClientCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesClientCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesClientCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesClientCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesExternalCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantSpecKesExternalCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecKesExternalCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesExternalCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesExternalCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesExternalCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesExternalCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesKesSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecKesKesSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecKesKesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesKesSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesKesSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesKesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecKesResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecKesResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecKesResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecKesResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecKesResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecKesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecKesResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecKesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecKesResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecKesResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecKesResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecKesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecKesResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecKesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecKesResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecKesSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecKesSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecKesSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecKesSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecKesSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecKesSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecKesSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecKesSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecKesSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecKesSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecKesSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecKesSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecKesSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecKesSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecKesSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecKesSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecKesSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecKesSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecKesSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecKesSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantSpecKesTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecKesTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantSpecKesTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecKesTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecKesTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecKesTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecKesTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecKesTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLog",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "annotations": "annotations",
        "audit": "audit",
        "db": "db",
        "image": "image",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantSpecLog:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["TenantSpecLogAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        audit: typing.Optional[typing.Union["TenantSpecLogAudit", typing.Dict[str, typing.Any]]] = None,
        db: typing.Optional[typing.Union["TenantSpecLogDb", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantSpecLogResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecLogSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param affinity: 
        :param annotations: 
        :param audit: 
        :param db: 
        :param image: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantSpecLog
        '''
        if isinstance(affinity, dict):
            affinity = TenantSpecLogAffinity(**affinity)
        if isinstance(audit, dict):
            audit = TenantSpecLogAudit(**audit)
        if isinstance(db, dict):
            db = TenantSpecLogDb(**db)
        if isinstance(resources, dict):
            resources = TenantSpecLogResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecLogSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLog.__init__)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument audit", value=audit, expected_type=type_hints["audit"])
            check_type(argname="argument db", value=db, expected_type=type_hints["db"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if audit is not None:
            self._values["audit"] = audit
        if db is not None:
            self._values["db"] = db
        if image is not None:
            self._values["image"] = image
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def affinity(self) -> typing.Optional["TenantSpecLogAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantSpecLogAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def audit(self) -> typing.Optional["TenantSpecLogAudit"]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#audit
        '''
        result = self._values.get("audit")
        return typing.cast(typing.Optional["TenantSpecLogAudit"], result)

    @builtins.property
    def db(self) -> typing.Optional["TenantSpecLogDb"]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#db
        '''
        result = self._values.get("db")
        return typing.cast(typing.Optional["TenantSpecLogDb"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecLogResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecLogResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantSpecLogSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecLogSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantSpecLogTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLog#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantSpecLogAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantSpecLogAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantSpecLogAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantSpecLogAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantSpecLogAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantSpecLogAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantSpecLogAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantSpecLogAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantSpecLogAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantSpecLogAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantSpecLogAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogAudit",
    jsii_struct_bases=[],
    name_mapping={"disk_capacity_gb": "diskCapacityGb"},
)
class TenantSpecLogAudit:
    def __init__(
        self,
        *,
        disk_capacity_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_capacity_gb: 

        :stability: experimental
        :schema: TenantSpecLogAudit
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogAudit.__init__)
            check_type(argname="argument disk_capacity_gb", value=disk_capacity_gb, expected_type=type_hints["disk_capacity_gb"])
        self._values: typing.Dict[str, typing.Any] = {}
        if disk_capacity_gb is not None:
            self._values["disk_capacity_gb"] = disk_capacity_gb

    @builtins.property
    def disk_capacity_gb(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogAudit#diskCapacityGB
        '''
        result = self._values.get("disk_capacity_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogAudit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDb",
    jsii_struct_bases=[],
    name_mapping={
        "volume_claim_template": "volumeClaimTemplate",
        "affinity": "affinity",
        "annotations": "annotations",
        "image": "image",
        "initimage": "initimage",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantSpecLogDb:
    def __init__(
        self,
        *,
        volume_claim_template: typing.Union["TenantSpecLogDbVolumeClaimTemplate", typing.Dict[str, typing.Any]],
        affinity: typing.Optional[typing.Union["TenantSpecLogDbAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        image: typing.Optional[builtins.str] = None,
        initimage: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantSpecLogDbResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecLogDbSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param volume_claim_template: 
        :param affinity: 
        :param annotations: 
        :param image: 
        :param initimage: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantSpecLogDb
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantSpecLogDbVolumeClaimTemplate(**volume_claim_template)
        if isinstance(affinity, dict):
            affinity = TenantSpecLogDbAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantSpecLogDbResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecLogDbSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDb.__init__)
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument initimage", value=initimage, expected_type=type_hints["initimage"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_claim_template": volume_claim_template,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if image is not None:
            self._values["image"] = image
        if initimage is not None:
            self._values["initimage"] = initimage
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def volume_claim_template(self) -> "TenantSpecLogDbVolumeClaimTemplate":
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        assert result is not None, "Required property 'volume_claim_template' is missing"
        return typing.cast("TenantSpecLogDbVolumeClaimTemplate", result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantSpecLogDbAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#initimage
        '''
        result = self._values.get("initimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecLogDbResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecLogDbResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantSpecLogDbSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecLogDbSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantSpecLogDbTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDb#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDb(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantSpecLogDbAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantSpecLogDbAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantSpecLogDbAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantSpecLogDbAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantSpecLogDbAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantSpecLogDbAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantSpecLogDbAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogDbAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogDbAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecLogDbAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecLogDbResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecLogDbResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecLogDbResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogDbResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecLogDbResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecLogDbResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecLogDbResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogDbResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecLogDbResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecLogDbResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecLogDbSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecLogDbSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecLogDbSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecLogDbSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecLogDbSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecLogDbSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecLogDbSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecLogDbSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecLogDbSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecLogDbSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecLogDbSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecLogDbSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecLogDbSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecLogDbSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecLogDbSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecLogDbSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecLogDbSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantSpecLogDbTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecLogDbTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantSpecLogDbTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogDbTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogDbTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogDbTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantSpecLogDbVolumeClaimTemplate:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate
        '''
        if isinstance(metadata, dict):
            metadata = TenantSpecLogDbVolumeClaimTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantSpecLogDbVolumeClaimTemplateSpec(**spec)
        if isinstance(status, dict):
            status = TenantSpecLogDbVolumeClaimTemplateStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplate.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpec"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpec"], result)

    @builtins.property
    def status(self) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateStatus"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplate#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantSpecLogDbVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantSpecLogDbVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantSpecLogDbVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantSpecLogDbVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantSpecLogDbVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantSpecLogDbVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantSpecLogDbVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantSpecLogDbVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecLogDbVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogDbVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantSpecLogDbVolumeClaimTemplateStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogDbVolumeClaimTemplateStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogDbVolumeClaimTemplateStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogDbVolumeClaimTemplateStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogDbVolumeClaimTemplateStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecLogDbVolumeClaimTemplateStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogDbVolumeClaimTemplateStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecLogDbVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecLogDbVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogDbVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogDbVolumeClaimTemplateStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantSpecLogDbVolumeClaimTemplateStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogDbVolumeClaimTemplateStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogDbVolumeClaimTemplateStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogDbVolumeClaimTemplateStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecLogResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecLogResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecLogResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecLogResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecLogResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecLogResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecLogResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecLogResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecLogResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecLogResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecLogResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecLogSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecLogSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecLogSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecLogSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecLogSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecLogSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecLogSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecLogSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecLogSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecLogSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecLogSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecLogSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecLogSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecLogSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecLogSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecLogSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecLogSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecLogSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecLogSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecLogSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantSpecLogTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecLogTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantSpecLogTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecLogTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecLogTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecLogTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecLogTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecLogTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheus",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "annotations": "annotations",
        "disk_capacity_gb": "diskCapacityGb",
        "image": "image",
        "initimage": "initimage",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "sidecarimage": "sidecarimage",
        "storage_class_name": "storageClassName",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantSpecPrometheus:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["TenantSpecPrometheusAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        disk_capacity_gb: typing.Optional[jsii.Number] = None,
        image: typing.Optional[builtins.str] = None,
        initimage: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantSpecPrometheusResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecPrometheusSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        sidecarimage: typing.Optional[builtins.str] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param affinity: 
        :param annotations: 
        :param disk_capacity_gb: 
        :param image: 
        :param initimage: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param sidecarimage: 
        :param storage_class_name: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantSpecPrometheus
        '''
        if isinstance(affinity, dict):
            affinity = TenantSpecPrometheusAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantSpecPrometheusResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecPrometheusSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheus.__init__)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument disk_capacity_gb", value=disk_capacity_gb, expected_type=type_hints["disk_capacity_gb"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument initimage", value=initimage, expected_type=type_hints["initimage"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument sidecarimage", value=sidecarimage, expected_type=type_hints["sidecarimage"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if disk_capacity_gb is not None:
            self._values["disk_capacity_gb"] = disk_capacity_gb
        if image is not None:
            self._values["image"] = image
        if initimage is not None:
            self._values["initimage"] = initimage
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if sidecarimage is not None:
            self._values["sidecarimage"] = sidecarimage
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def affinity(self) -> typing.Optional["TenantSpecPrometheusAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def disk_capacity_gb(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#diskCapacityGB
        '''
        result = self._values.get("disk_capacity_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#initimage
        '''
        result = self._values.get("initimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecPrometheusResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecPrometheusResources"], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["TenantSpecPrometheusSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecPrometheusSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sidecarimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#sidecarimage
        '''
        result = self._values.get("sidecarimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheus#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantSpecPrometheusAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantSpecPrometheusAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantSpecPrometheusAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantSpecPrometheusAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantSpecPrometheusAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecPrometheusAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecPrometheusAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecPrometheusAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecPrometheusResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecPrometheusResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecPrometheusResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecPrometheusResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecPrometheusResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecPrometheusResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecPrometheusResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecPrometheusResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecPrometheusResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecPrometheusResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecPrometheusResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecPrometheusResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecPrometheusResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecPrometheusResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecPrometheusResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecPrometheusSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecPrometheusSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecPrometheusSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecPrometheusSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecPrometheusSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecPrometheusSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecPrometheusSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecPrometheusSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecPrometheusSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecPrometheusSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecPrometheusSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecPrometheusSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecPrometheusSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecPrometheusSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecPrometheusSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecPrometheusSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecPrometheusSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantSpecPrometheusTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecPrometheusTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecPrometheusTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecPrometheusTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecPrometheusTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecPrometheusTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecS3",
    jsii_struct_bases=[],
    name_mapping={"bucket_dns": "bucketDns"},
)
class TenantSpecS3:
    def __init__(self, *, bucket_dns: typing.Optional[builtins.bool] = None) -> None:
        '''
        :param bucket_dns: 

        :stability: experimental
        :schema: TenantSpecS3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecS3.__init__)
            check_type(argname="argument bucket_dns", value=bucket_dns, expected_type=type_hints["bucket_dns"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bucket_dns is not None:
            self._values["bucket_dns"] = bucket_dns

    @builtins.property
    def bucket_dns(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecS3#bucketDNS
        '''
        result = self._values.get("bucket_dns")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecS3(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCars",
    jsii_struct_bases=[],
    name_mapping={
        "containers": "containers",
        "volume_claim_templates": "volumeClaimTemplates",
        "volumes": "volumes",
    },
)
class TenantSpecSideCars:
    def __init__(
        self,
        *,
        containers: typing.Sequence[typing.Union["TenantSpecSideCarsContainers", typing.Dict[str, typing.Any]]],
        volume_claim_templates: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumeClaimTemplates", typing.Dict[str, typing.Any]]]] = None,
        volumes: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumes", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param containers: 
        :param volume_claim_templates: 
        :param volumes: 

        :stability: experimental
        :schema: TenantSpecSideCars
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCars.__init__)
            check_type(argname="argument containers", value=containers, expected_type=type_hints["containers"])
            check_type(argname="argument volume_claim_templates", value=volume_claim_templates, expected_type=type_hints["volume_claim_templates"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[str, typing.Any] = {
            "containers": containers,
        }
        if volume_claim_templates is not None:
            self._values["volume_claim_templates"] = volume_claim_templates
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def containers(self) -> typing.List["TenantSpecSideCarsContainers"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCars#containers
        '''
        result = self._values.get("containers")
        assert result is not None, "Required property 'containers' is missing"
        return typing.cast(typing.List["TenantSpecSideCarsContainers"], result)

    @builtins.property
    def volume_claim_templates(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplates"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCars#volumeClaimTemplates
        '''
        result = self._values.get("volume_claim_templates")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplates"]], result)

    @builtins.property
    def volumes(self) -> typing.Optional[typing.List["TenantSpecSideCarsVolumes"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCars#volumes
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumes"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCars(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainers",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "args": "args",
        "command": "command",
        "env": "env",
        "env_from": "envFrom",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "lifecycle": "lifecycle",
        "liveness_probe": "livenessProbe",
        "ports": "ports",
        "readiness_probe": "readinessProbe",
        "resources": "resources",
        "security_context": "securityContext",
        "startup_probe": "startupProbe",
        "stdin": "stdin",
        "stdin_once": "stdinOnce",
        "termination_message_path": "terminationMessagePath",
        "termination_message_policy": "terminationMessagePolicy",
        "tty": "tty",
        "volume_devices": "volumeDevices",
        "volume_mounts": "volumeMounts",
        "working_dir": "workingDir",
    },
)
class TenantSpecSideCarsContainers:
    def __init__(
        self,
        *,
        name: builtins.str,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersEnv", typing.Dict[str, typing.Any]]]] = None,
        env_from: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersEnvFrom", typing.Dict[str, typing.Any]]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        lifecycle: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecycle", typing.Dict[str, typing.Any]]] = None,
        liveness_probe: typing.Optional[typing.Union["TenantSpecSideCarsContainersLivenessProbe", typing.Dict[str, typing.Any]]] = None,
        ports: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersPorts", typing.Dict[str, typing.Any]]]] = None,
        readiness_probe: typing.Optional[typing.Union["TenantSpecSideCarsContainersReadinessProbe", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantSpecSideCarsContainersResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecSideCarsContainersSecurityContext", typing.Dict[str, typing.Any]]] = None,
        startup_probe: typing.Optional[typing.Union["TenantSpecSideCarsContainersStartupProbe", typing.Dict[str, typing.Any]]] = None,
        stdin: typing.Optional[builtins.bool] = None,
        stdin_once: typing.Optional[builtins.bool] = None,
        termination_message_path: typing.Optional[builtins.str] = None,
        termination_message_policy: typing.Optional[builtins.str] = None,
        tty: typing.Optional[builtins.bool] = None,
        volume_devices: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersVolumeDevices", typing.Dict[str, typing.Any]]]] = None,
        volume_mounts: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersVolumeMounts", typing.Dict[str, typing.Any]]]] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param args: 
        :param command: 
        :param env: 
        :param env_from: 
        :param image: 
        :param image_pull_policy: 
        :param lifecycle: 
        :param liveness_probe: 
        :param ports: 
        :param readiness_probe: 
        :param resources: 
        :param security_context: 
        :param startup_probe: 
        :param stdin: 
        :param stdin_once: 
        :param termination_message_path: 
        :param termination_message_policy: 
        :param tty: 
        :param volume_devices: 
        :param volume_mounts: 
        :param working_dir: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainers
        '''
        if isinstance(lifecycle, dict):
            lifecycle = TenantSpecSideCarsContainersLifecycle(**lifecycle)
        if isinstance(liveness_probe, dict):
            liveness_probe = TenantSpecSideCarsContainersLivenessProbe(**liveness_probe)
        if isinstance(readiness_probe, dict):
            readiness_probe = TenantSpecSideCarsContainersReadinessProbe(**readiness_probe)
        if isinstance(resources, dict):
            resources = TenantSpecSideCarsContainersResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecSideCarsContainersSecurityContext(**security_context)
        if isinstance(startup_probe, dict):
            startup_probe = TenantSpecSideCarsContainersStartupProbe(**startup_probe)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainers.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument env_from", value=env_from, expected_type=type_hints["env_from"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument liveness_probe", value=liveness_probe, expected_type=type_hints["liveness_probe"])
            check_type(argname="argument ports", value=ports, expected_type=type_hints["ports"])
            check_type(argname="argument readiness_probe", value=readiness_probe, expected_type=type_hints["readiness_probe"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument startup_probe", value=startup_probe, expected_type=type_hints["startup_probe"])
            check_type(argname="argument stdin", value=stdin, expected_type=type_hints["stdin"])
            check_type(argname="argument stdin_once", value=stdin_once, expected_type=type_hints["stdin_once"])
            check_type(argname="argument termination_message_path", value=termination_message_path, expected_type=type_hints["termination_message_path"])
            check_type(argname="argument termination_message_policy", value=termination_message_policy, expected_type=type_hints["termination_message_policy"])
            check_type(argname="argument tty", value=tty, expected_type=type_hints["tty"])
            check_type(argname="argument volume_devices", value=volume_devices, expected_type=type_hints["volume_devices"])
            check_type(argname="argument volume_mounts", value=volume_mounts, expected_type=type_hints["volume_mounts"])
            check_type(argname="argument working_dir", value=working_dir, expected_type=type_hints["working_dir"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if args is not None:
            self._values["args"] = args
        if command is not None:
            self._values["command"] = command
        if env is not None:
            self._values["env"] = env
        if env_from is not None:
            self._values["env_from"] = env_from
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if liveness_probe is not None:
            self._values["liveness_probe"] = liveness_probe
        if ports is not None:
            self._values["ports"] = ports
        if readiness_probe is not None:
            self._values["readiness_probe"] = readiness_probe
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if startup_probe is not None:
            self._values["startup_probe"] = startup_probe
        if stdin is not None:
            self._values["stdin"] = stdin
        if stdin_once is not None:
            self._values["stdin_once"] = stdin_once
        if termination_message_path is not None:
            self._values["termination_message_path"] = termination_message_path
        if termination_message_policy is not None:
            self._values["termination_message_policy"] = termination_message_policy
        if tty is not None:
            self._values["tty"] = tty
        if volume_devices is not None:
            self._values["volume_devices"] = volume_devices
        if volume_mounts is not None:
            self._values["volume_mounts"] = volume_mounts
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def args(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#args
        '''
        result = self._values.get("args")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def env(self) -> typing.Optional[typing.List["TenantSpecSideCarsContainersEnv"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#env
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersEnv"]], result)

    @builtins.property
    def env_from(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersEnvFrom"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#envFrom
        '''
        result = self._values.get("env_from")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersEnvFrom"]], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional["TenantSpecSideCarsContainersLifecycle"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#lifecycle
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecycle"], result)

    @builtins.property
    def liveness_probe(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLivenessProbe"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#livenessProbe
        '''
        result = self._values.get("liveness_probe")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLivenessProbe"], result)

    @builtins.property
    def ports(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersPorts"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#ports
        '''
        result = self._values.get("ports")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersPorts"]], result)

    @builtins.property
    def readiness_probe(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersReadinessProbe"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#readinessProbe
        '''
        result = self._values.get("readiness_probe")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersReadinessProbe"], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecSideCarsContainersResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersResources"], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersSecurityContext"], result)

    @builtins.property
    def startup_probe(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersStartupProbe"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#startupProbe
        '''
        result = self._values.get("startup_probe")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersStartupProbe"], result)

    @builtins.property
    def stdin(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#stdin
        '''
        result = self._values.get("stdin")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def stdin_once(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#stdinOnce
        '''
        result = self._values.get("stdin_once")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def termination_message_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#terminationMessagePath
        '''
        result = self._values.get("termination_message_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination_message_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#terminationMessagePolicy
        '''
        result = self._values.get("termination_message_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tty(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#tty
        '''
        result = self._values.get("tty")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_devices(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersVolumeDevices"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#volumeDevices
        '''
        result = self._values.get("volume_devices")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersVolumeDevices"]], result)

    @builtins.property
    def volume_mounts(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersVolumeMounts"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#volumeMounts
        '''
        result = self._values.get("volume_mounts")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersVolumeMounts"]], result)

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainers#workingDir
        '''
        result = self._values.get("working_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class TenantSpecSideCarsContainersEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvValueFrom", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param value: 
        :param value_from: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnv
        '''
        if isinstance(value_from, dict):
            value_from = TenantSpecSideCarsContainersEnvValueFrom(**value_from)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnv.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_from", value=value_from, expected_type=type_hints["value_from"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnv#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnv#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(self) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFrom"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnv#valueFrom
        '''
        result = self._values.get("value_from")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFrom"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_ref": "configMapRef",
        "prefix": "prefix",
        "secret_ref": "secretRef",
    },
)
class TenantSpecSideCarsContainersEnvFrom:
    def __init__(
        self,
        *,
        config_map_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvFromConfigMapRef", typing.Dict[str, typing.Any]]] = None,
        prefix: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvFromSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_ref: 
        :param prefix: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFrom
        '''
        if isinstance(config_map_ref, dict):
            config_map_ref = TenantSpecSideCarsContainersEnvFromConfigMapRef(**config_map_ref)
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsContainersEnvFromSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvFrom.__init__)
            check_type(argname="argument config_map_ref", value=config_map_ref, expected_type=type_hints["config_map_ref"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_ref is not None:
            self._values["config_map_ref"] = config_map_ref
        if prefix is not None:
            self._values["prefix"] = prefix
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def config_map_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvFromConfigMapRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFrom#configMapRef
        '''
        result = self._values.get("config_map_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvFromConfigMapRef"], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFrom#prefix
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvFromSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFrom#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvFromSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvFromConfigMapRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class TenantSpecSideCarsContainersEnvFromConfigMapRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromConfigMapRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvFromConfigMapRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromConfigMapRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromConfigMapRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvFromConfigMapRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvFromSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class TenantSpecSideCarsContainersEnvFromSecretRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvFromSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvFromSecretRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvFromSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class TenantSpecSideCarsContainersEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef", typing.Dict[str, typing.Any]]] = None,
        field_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvValueFromFieldRef", typing.Dict[str, typing.Any]]] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvValueFromResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
        secret_key_ref: typing.Optional[typing.Union["TenantSpecSideCarsContainersEnvValueFromSecretKeyRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_key_ref: 
        :param field_ref: 
        :param resource_field_ref: 
        :param secret_key_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFrom
        '''
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef(**config_map_key_ref)
        if isinstance(field_ref, dict):
            field_ref = TenantSpecSideCarsContainersEnvValueFromFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantSpecSideCarsContainersEnvValueFromResourceFieldRef(**resource_field_ref)
        if isinstance(secret_key_ref, dict):
            secret_key_ref = TenantSpecSideCarsContainersEnvValueFromSecretKeyRef(**secret_key_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFrom.__init__)
            check_type(argname="argument config_map_key_ref", value=config_map_key_ref, expected_type=type_hints["config_map_key_ref"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
            check_type(argname="argument secret_key_ref", value=secret_key_ref, expected_type=type_hints["secret_key_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFrom#configMapKeyRef
        '''
        result = self._values.get("config_map_key_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef"], result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFromFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFrom#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFromFieldRef"], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFromResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFrom#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFromResourceFieldRef"], result)

    @builtins.property
    def secret_key_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFromSecretKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFrom#secretKeyRef
        '''
        result = self._values.get("secret_key_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFromSecretKeyRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantSpecSideCarsContainersEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvValueFromFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantSpecSideCarsContainersEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvValueFromResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantSpecSideCarsContainersEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromSecretKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersEnvValueFromSecretKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromSecretKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromSecretKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersEnvValueFromSecretKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersEnvValueFromSecretKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecycle",
    jsii_struct_bases=[],
    name_mapping={"post_start": "postStart", "pre_stop": "preStop"},
)
class TenantSpecSideCarsContainersLifecycle:
    def __init__(
        self,
        *,
        post_start: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePostStart", typing.Dict[str, typing.Any]]] = None,
        pre_stop: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePreStop", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param post_start: 
        :param pre_stop: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecycle
        '''
        if isinstance(post_start, dict):
            post_start = TenantSpecSideCarsContainersLifecyclePostStart(**post_start)
        if isinstance(pre_stop, dict):
            pre_stop = TenantSpecSideCarsContainersLifecyclePreStop(**pre_stop)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecycle.__init__)
            check_type(argname="argument post_start", value=post_start, expected_type=type_hints["post_start"])
            check_type(argname="argument pre_stop", value=pre_stop, expected_type=type_hints["pre_stop"])
        self._values: typing.Dict[str, typing.Any] = {}
        if post_start is not None:
            self._values["post_start"] = post_start
        if pre_stop is not None:
            self._values["pre_stop"] = pre_stop

    @builtins.property
    def post_start(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePostStart"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecycle#postStart
        '''
        result = self._values.get("post_start")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePostStart"], result)

    @builtins.property
    def pre_stop(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePreStop"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecycle#preStop
        '''
        result = self._values.get("pre_stop")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePreStop"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecycle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStart",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class TenantSpecSideCarsContainersLifecyclePostStart:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePostStartExec", typing.Dict[str, typing.Any]]] = None,
        http_get: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePostStartHttpGet", typing.Dict[str, typing.Any]]] = None,
        tcp_socket: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePostStartTcpSocket", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param exec: 
        :param http_get: 
        :param tcp_socket: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStart
        '''
        if isinstance(exec, dict):
            exec = TenantSpecSideCarsContainersLifecyclePostStartExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantSpecSideCarsContainersLifecyclePostStartHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantSpecSideCarsContainersLifecyclePostStartTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStart.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartExec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStart#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartExec"], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStart#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartHttpGet"], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStart#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePostStartTcpSocket"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePostStart(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantSpecSideCarsContainersLifecyclePostStartExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePostStartExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantSpecSideCarsContainersLifecyclePostStartHttpGet:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePostStartHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantSpecSideCarsContainersLifecyclePostStartTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePostStartTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePostStartTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStop",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class TenantSpecSideCarsContainersLifecyclePreStop:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePreStopExec", typing.Dict[str, typing.Any]]] = None,
        http_get: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePreStopHttpGet", typing.Dict[str, typing.Any]]] = None,
        tcp_socket: typing.Optional[typing.Union["TenantSpecSideCarsContainersLifecyclePreStopTcpSocket", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param exec: 
        :param http_get: 
        :param tcp_socket: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStop
        '''
        if isinstance(exec, dict):
            exec = TenantSpecSideCarsContainersLifecyclePreStopExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantSpecSideCarsContainersLifecyclePreStopHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantSpecSideCarsContainersLifecyclePreStopTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStop.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopExec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStop#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopExec"], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStop#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopHttpGet"], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStop#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLifecyclePreStopTcpSocket"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePreStop(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantSpecSideCarsContainersLifecyclePreStopExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePreStopExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantSpecSideCarsContainersLifecyclePreStopHttpGet:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePreStopHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantSpecSideCarsContainersLifecyclePreStopTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLifecyclePreStopTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLifecyclePreStopTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantSpecSideCarsContainersLivenessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantSpecSideCarsContainersLivenessProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantSpecSideCarsContainersLivenessProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantSpecSideCarsContainersLivenessProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe
        '''
        if isinstance(exec, dict):
            exec = TenantSpecSideCarsContainersLivenessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantSpecSideCarsContainersLivenessProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantSpecSideCarsContainersLivenessProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantSpecSideCarsContainersLivenessProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLivenessProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLivenessProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLivenessProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersLivenessProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersLivenessProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLivenessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantSpecSideCarsContainersLivenessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLivenessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantSpecSideCarsContainersLivenessProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLivenessProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLivenessProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLivenessProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLivenessProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantSpecSideCarsContainersLivenessProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersLivenessProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersLivenessProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersLivenessProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersLivenessProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersLivenessProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersLivenessProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersLivenessProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersLivenessProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersPorts",
    jsii_struct_bases=[],
    name_mapping={
        "container_port": "containerPort",
        "host_ip": "hostIp",
        "host_port": "hostPort",
        "name": "name",
        "protocol": "protocol",
    },
)
class TenantSpecSideCarsContainersPorts:
    def __init__(
        self,
        *,
        container_port: jsii.Number,
        host_ip: typing.Optional[builtins.str] = None,
        host_port: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        protocol: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param container_port: 
        :param host_ip: 
        :param host_port: 
        :param name: 
        :param protocol: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersPorts.__init__)
            check_type(argname="argument container_port", value=container_port, expected_type=type_hints["container_port"])
            check_type(argname="argument host_ip", value=host_ip, expected_type=type_hints["host_ip"])
            check_type(argname="argument host_port", value=host_port, expected_type=type_hints["host_port"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
        self._values: typing.Dict[str, typing.Any] = {
            "container_port": container_port,
        }
        if host_ip is not None:
            self._values["host_ip"] = host_ip
        if host_port is not None:
            self._values["host_port"] = host_port
        if name is not None:
            self._values["name"] = name
        if protocol is not None:
            self._values["protocol"] = protocol

    @builtins.property
    def container_port(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts#containerPort
        '''
        result = self._values.get("container_port")
        assert result is not None, "Required property 'container_port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def host_ip(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts#hostIP
        '''
        result = self._values.get("host_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_port(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts#hostPort
        '''
        result = self._values.get("host_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersPorts#protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersPorts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantSpecSideCarsContainersReadinessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantSpecSideCarsContainersReadinessProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantSpecSideCarsContainersReadinessProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantSpecSideCarsContainersReadinessProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe
        '''
        if isinstance(exec, dict):
            exec = TenantSpecSideCarsContainersReadinessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantSpecSideCarsContainersReadinessProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantSpecSideCarsContainersReadinessProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantSpecSideCarsContainersReadinessProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersReadinessProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersReadinessProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersReadinessProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersReadinessProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersReadinessProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersReadinessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantSpecSideCarsContainersReadinessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersReadinessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantSpecSideCarsContainersReadinessProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersReadinessProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersReadinessProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersReadinessProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersReadinessProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantSpecSideCarsContainersReadinessProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersReadinessProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersReadinessProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersReadinessProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersReadinessProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersReadinessProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersReadinessProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersReadinessProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersReadinessProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecSideCarsContainersResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsContainersResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecSideCarsContainersResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "allow_privilege_escalation": "allowPrivilegeEscalation",
        "capabilities": "capabilities",
        "privileged": "privileged",
        "proc_mount": "procMount",
        "read_only_root_filesystem": "readOnlyRootFilesystem",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecSideCarsContainersSecurityContext:
    def __init__(
        self,
        *,
        allow_privilege_escalation: typing.Optional[builtins.bool] = None,
        capabilities: typing.Optional[typing.Union["TenantSpecSideCarsContainersSecurityContextCapabilities", typing.Dict[str, typing.Any]]] = None,
        privileged: typing.Optional[builtins.bool] = None,
        proc_mount: typing.Optional[builtins.str] = None,
        read_only_root_filesystem: typing.Optional[builtins.bool] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecSideCarsContainersSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecSideCarsContainersSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecSideCarsContainersSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param allow_privilege_escalation: 
        :param capabilities: 
        :param privileged: 
        :param proc_mount: 
        :param read_only_root_filesystem: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext
        '''
        if isinstance(capabilities, dict):
            capabilities = TenantSpecSideCarsContainersSecurityContextCapabilities(**capabilities)
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecSideCarsContainersSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecSideCarsContainersSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecSideCarsContainersSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersSecurityContext.__init__)
            check_type(argname="argument allow_privilege_escalation", value=allow_privilege_escalation, expected_type=type_hints["allow_privilege_escalation"])
            check_type(argname="argument capabilities", value=capabilities, expected_type=type_hints["capabilities"])
            check_type(argname="argument privileged", value=privileged, expected_type=type_hints["privileged"])
            check_type(argname="argument proc_mount", value=proc_mount, expected_type=type_hints["proc_mount"])
            check_type(argname="argument read_only_root_filesystem", value=read_only_root_filesystem, expected_type=type_hints["read_only_root_filesystem"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if allow_privilege_escalation is not None:
            self._values["allow_privilege_escalation"] = allow_privilege_escalation
        if capabilities is not None:
            self._values["capabilities"] = capabilities
        if privileged is not None:
            self._values["privileged"] = privileged
        if proc_mount is not None:
            self._values["proc_mount"] = proc_mount
        if read_only_root_filesystem is not None:
            self._values["read_only_root_filesystem"] = read_only_root_filesystem
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def allow_privilege_escalation(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#allowPrivilegeEscalation
        '''
        result = self._values.get("allow_privilege_escalation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def capabilities(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersSecurityContextCapabilities"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#capabilities
        '''
        result = self._values.get("capabilities")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersSecurityContextCapabilities"], result)

    @builtins.property
    def privileged(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#privileged
        '''
        result = self._values.get("privileged")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def proc_mount(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#procMount
        '''
        result = self._values.get("proc_mount")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only_root_filesystem(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#readOnlyRootFilesystem
        '''
        result = self._values.get("read_only_root_filesystem")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersSecurityContextCapabilities",
    jsii_struct_bases=[],
    name_mapping={"add": "add", "drop": "drop"},
)
class TenantSpecSideCarsContainersSecurityContextCapabilities:
    def __init__(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param add: 
        :param drop: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextCapabilities
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersSecurityContextCapabilities.__init__)
            check_type(argname="argument add", value=add, expected_type=type_hints["add"])
            check_type(argname="argument drop", value=drop, expected_type=type_hints["drop"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add is not None:
            self._values["add"] = add
        if drop is not None:
            self._values["drop"] = drop

    @builtins.property
    def add(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextCapabilities#add
        '''
        result = self._values.get("add")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def drop(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextCapabilities#drop
        '''
        result = self._values.get("drop")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersSecurityContextCapabilities(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecSideCarsContainersSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecSideCarsContainersSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecSideCarsContainersSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantSpecSideCarsContainersStartupProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantSpecSideCarsContainersStartupProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantSpecSideCarsContainersStartupProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantSpecSideCarsContainersStartupProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe
        '''
        if isinstance(exec, dict):
            exec = TenantSpecSideCarsContainersStartupProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantSpecSideCarsContainersStartupProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantSpecSideCarsContainersStartupProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantSpecSideCarsContainersStartupProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersStartupProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersStartupProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersStartupProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantSpecSideCarsContainersStartupProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantSpecSideCarsContainersStartupProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersStartupProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantSpecSideCarsContainersStartupProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersStartupProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantSpecSideCarsContainersStartupProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersStartupProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersStartupProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersStartupProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersStartupProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersStartupProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersStartupProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersStartupProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantSpecSideCarsContainersStartupProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantSpecSideCarsContainersStartupProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantSpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantSpecSideCarsContainersStartupProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersStartupProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersStartupProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsContainersStartupProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersStartupProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsContainersStartupProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersStartupProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersStartupProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsContainersStartupProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersVolumeDevices",
    jsii_struct_bases=[],
    name_mapping={"device_path": "devicePath", "name": "name"},
)
class TenantSpecSideCarsContainersVolumeDevices:
    def __init__(self, *, device_path: builtins.str, name: builtins.str) -> None:
        '''
        :param device_path: 
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeDevices
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersVolumeDevices.__init__)
            check_type(argname="argument device_path", value=device_path, expected_type=type_hints["device_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "device_path": device_path,
            "name": name,
        }

    @builtins.property
    def device_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeDevices#devicePath
        '''
        result = self._values.get("device_path")
        assert result is not None, "Required property 'device_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeDevices#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersVolumeDevices(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsContainersVolumeMounts",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "mount_propagation": "mountPropagation",
        "read_only": "readOnly",
        "sub_path": "subPath",
        "sub_path_expr": "subPathExpr",
    },
)
class TenantSpecSideCarsContainersVolumeMounts:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        name: builtins.str,
        mount_propagation: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        sub_path: typing.Optional[builtins.str] = None,
        sub_path_expr: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param mount_path: 
        :param name: 
        :param mount_propagation: 
        :param read_only: 
        :param sub_path: 
        :param sub_path_expr: 

        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsContainersVolumeMounts.__init__)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument mount_propagation", value=mount_propagation, expected_type=type_hints["mount_propagation"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            check_type(argname="argument sub_path_expr", value=sub_path_expr, expected_type=type_hints["sub_path_expr"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "name": name,
        }
        if mount_propagation is not None:
            self._values["mount_propagation"] = mount_propagation
        if read_only is not None:
            self._values["read_only"] = read_only
        if sub_path is not None:
            self._values["sub_path"] = sub_path
        if sub_path_expr is not None:
            self._values["sub_path_expr"] = sub_path_expr

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_propagation(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#mountPropagation
        '''
        result = self._values.get("mount_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#subPath
        '''
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sub_path_expr(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsContainersVolumeMounts#subPathExpr
        '''
        result = self._values.get("sub_path_expr")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsContainersVolumeMounts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplates",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantSpecSideCarsVolumeClaimTemplates:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates
        '''
        if isinstance(metadata, dict):
            metadata = TenantSpecSideCarsVolumeClaimTemplatesMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantSpecSideCarsVolumeClaimTemplatesSpec(**spec)
        if isinstance(status, dict):
            status = TenantSpecSideCarsVolumeClaimTemplatesStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplates.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesMetadata"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpec"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpec"], result)

    @builtins.property
    def status(self) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesStatus"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplates#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplates(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantSpecSideCarsVolumeClaimTemplatesMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantSpecSideCarsVolumeClaimTemplatesSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantSpecSideCarsVolumeClaimTemplatesSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantSpecSideCarsVolumeClaimTemplatesSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumeClaimTemplatesSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecSideCarsVolumeClaimTemplatesSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecSideCarsVolumeClaimTemplatesSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantSpecSideCarsVolumeClaimTemplatesStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumeClaimTemplatesStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplatesStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumeClaimTemplatesStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumeClaimTemplatesStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantSpecSideCarsVolumeClaimTemplatesStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumeClaimTemplatesStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumeClaimTemplatesStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumeClaimTemplatesStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumes",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "aws_elastic_block_store": "awsElasticBlockStore",
        "azure_disk": "azureDisk",
        "azure_file": "azureFile",
        "cephfs": "cephfs",
        "cinder": "cinder",
        "config_map": "configMap",
        "csi": "csi",
        "downward_api": "downwardApi",
        "empty_dir": "emptyDir",
        "ephemeral": "ephemeral",
        "fc": "fc",
        "flex_volume": "flexVolume",
        "flocker": "flocker",
        "gce_persistent_disk": "gcePersistentDisk",
        "git_repo": "gitRepo",
        "glusterfs": "glusterfs",
        "host_path": "hostPath",
        "iscsi": "iscsi",
        "nfs": "nfs",
        "persistent_volume_claim": "persistentVolumeClaim",
        "photon_persistent_disk": "photonPersistentDisk",
        "portworx_volume": "portworxVolume",
        "projected": "projected",
        "quobyte": "quobyte",
        "rbd": "rbd",
        "scale_io": "scaleIo",
        "secret": "secret",
        "storageos": "storageos",
        "vsphere_volume": "vsphereVolume",
    },
)
class TenantSpecSideCarsVolumes:
    def __init__(
        self,
        *,
        name: builtins.str,
        aws_elastic_block_store: typing.Optional[typing.Union["TenantSpecSideCarsVolumesAwsElasticBlockStore", typing.Dict[str, typing.Any]]] = None,
        azure_disk: typing.Optional[typing.Union["TenantSpecSideCarsVolumesAzureDisk", typing.Dict[str, typing.Any]]] = None,
        azure_file: typing.Optional[typing.Union["TenantSpecSideCarsVolumesAzureFile", typing.Dict[str, typing.Any]]] = None,
        cephfs: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCephfs", typing.Dict[str, typing.Any]]] = None,
        cinder: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCinder", typing.Dict[str, typing.Any]]] = None,
        config_map: typing.Optional[typing.Union["TenantSpecSideCarsVolumesConfigMap", typing.Dict[str, typing.Any]]] = None,
        csi: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCsi", typing.Dict[str, typing.Any]]] = None,
        downward_api: typing.Optional[typing.Union["TenantSpecSideCarsVolumesDownwardApi", typing.Dict[str, typing.Any]]] = None,
        empty_dir: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEmptyDir", typing.Dict[str, typing.Any]]] = None,
        ephemeral: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeral", typing.Dict[str, typing.Any]]] = None,
        fc: typing.Optional[typing.Union["TenantSpecSideCarsVolumesFc", typing.Dict[str, typing.Any]]] = None,
        flex_volume: typing.Optional[typing.Union["TenantSpecSideCarsVolumesFlexVolume", typing.Dict[str, typing.Any]]] = None,
        flocker: typing.Optional[typing.Union["TenantSpecSideCarsVolumesFlocker", typing.Dict[str, typing.Any]]] = None,
        gce_persistent_disk: typing.Optional[typing.Union["TenantSpecSideCarsVolumesGcePersistentDisk", typing.Dict[str, typing.Any]]] = None,
        git_repo: typing.Optional[typing.Union["TenantSpecSideCarsVolumesGitRepo", typing.Dict[str, typing.Any]]] = None,
        glusterfs: typing.Optional[typing.Union["TenantSpecSideCarsVolumesGlusterfs", typing.Dict[str, typing.Any]]] = None,
        host_path: typing.Optional[typing.Union["TenantSpecSideCarsVolumesHostPath", typing.Dict[str, typing.Any]]] = None,
        iscsi: typing.Optional[typing.Union["TenantSpecSideCarsVolumesIscsi", typing.Dict[str, typing.Any]]] = None,
        nfs: typing.Optional[typing.Union["TenantSpecSideCarsVolumesNfs", typing.Dict[str, typing.Any]]] = None,
        persistent_volume_claim: typing.Optional[typing.Union["TenantSpecSideCarsVolumesPersistentVolumeClaim", typing.Dict[str, typing.Any]]] = None,
        photon_persistent_disk: typing.Optional[typing.Union["TenantSpecSideCarsVolumesPhotonPersistentDisk", typing.Dict[str, typing.Any]]] = None,
        portworx_volume: typing.Optional[typing.Union["TenantSpecSideCarsVolumesPortworxVolume", typing.Dict[str, typing.Any]]] = None,
        projected: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjected", typing.Dict[str, typing.Any]]] = None,
        quobyte: typing.Optional[typing.Union["TenantSpecSideCarsVolumesQuobyte", typing.Dict[str, typing.Any]]] = None,
        rbd: typing.Optional[typing.Union["TenantSpecSideCarsVolumesRbd", typing.Dict[str, typing.Any]]] = None,
        scale_io: typing.Optional[typing.Union["TenantSpecSideCarsVolumesScaleIo", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["TenantSpecSideCarsVolumesSecret", typing.Dict[str, typing.Any]]] = None,
        storageos: typing.Optional[typing.Union["TenantSpecSideCarsVolumesStorageos", typing.Dict[str, typing.Any]]] = None,
        vsphere_volume: typing.Optional[typing.Union["TenantSpecSideCarsVolumesVsphereVolume", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param aws_elastic_block_store: 
        :param azure_disk: 
        :param azure_file: 
        :param cephfs: 
        :param cinder: 
        :param config_map: 
        :param csi: 
        :param downward_api: 
        :param empty_dir: 
        :param ephemeral: 
        :param fc: 
        :param flex_volume: 
        :param flocker: 
        :param gce_persistent_disk: 
        :param git_repo: 
        :param glusterfs: 
        :param host_path: 
        :param iscsi: 
        :param nfs: 
        :param persistent_volume_claim: 
        :param photon_persistent_disk: 
        :param portworx_volume: 
        :param projected: 
        :param quobyte: 
        :param rbd: 
        :param scale_io: 
        :param secret: 
        :param storageos: 
        :param vsphere_volume: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumes
        '''
        if isinstance(aws_elastic_block_store, dict):
            aws_elastic_block_store = TenantSpecSideCarsVolumesAwsElasticBlockStore(**aws_elastic_block_store)
        if isinstance(azure_disk, dict):
            azure_disk = TenantSpecSideCarsVolumesAzureDisk(**azure_disk)
        if isinstance(azure_file, dict):
            azure_file = TenantSpecSideCarsVolumesAzureFile(**azure_file)
        if isinstance(cephfs, dict):
            cephfs = TenantSpecSideCarsVolumesCephfs(**cephfs)
        if isinstance(cinder, dict):
            cinder = TenantSpecSideCarsVolumesCinder(**cinder)
        if isinstance(config_map, dict):
            config_map = TenantSpecSideCarsVolumesConfigMap(**config_map)
        if isinstance(csi, dict):
            csi = TenantSpecSideCarsVolumesCsi(**csi)
        if isinstance(downward_api, dict):
            downward_api = TenantSpecSideCarsVolumesDownwardApi(**downward_api)
        if isinstance(empty_dir, dict):
            empty_dir = TenantSpecSideCarsVolumesEmptyDir(**empty_dir)
        if isinstance(ephemeral, dict):
            ephemeral = TenantSpecSideCarsVolumesEphemeral(**ephemeral)
        if isinstance(fc, dict):
            fc = TenantSpecSideCarsVolumesFc(**fc)
        if isinstance(flex_volume, dict):
            flex_volume = TenantSpecSideCarsVolumesFlexVolume(**flex_volume)
        if isinstance(flocker, dict):
            flocker = TenantSpecSideCarsVolumesFlocker(**flocker)
        if isinstance(gce_persistent_disk, dict):
            gce_persistent_disk = TenantSpecSideCarsVolumesGcePersistentDisk(**gce_persistent_disk)
        if isinstance(git_repo, dict):
            git_repo = TenantSpecSideCarsVolumesGitRepo(**git_repo)
        if isinstance(glusterfs, dict):
            glusterfs = TenantSpecSideCarsVolumesGlusterfs(**glusterfs)
        if isinstance(host_path, dict):
            host_path = TenantSpecSideCarsVolumesHostPath(**host_path)
        if isinstance(iscsi, dict):
            iscsi = TenantSpecSideCarsVolumesIscsi(**iscsi)
        if isinstance(nfs, dict):
            nfs = TenantSpecSideCarsVolumesNfs(**nfs)
        if isinstance(persistent_volume_claim, dict):
            persistent_volume_claim = TenantSpecSideCarsVolumesPersistentVolumeClaim(**persistent_volume_claim)
        if isinstance(photon_persistent_disk, dict):
            photon_persistent_disk = TenantSpecSideCarsVolumesPhotonPersistentDisk(**photon_persistent_disk)
        if isinstance(portworx_volume, dict):
            portworx_volume = TenantSpecSideCarsVolumesPortworxVolume(**portworx_volume)
        if isinstance(projected, dict):
            projected = TenantSpecSideCarsVolumesProjected(**projected)
        if isinstance(quobyte, dict):
            quobyte = TenantSpecSideCarsVolumesQuobyte(**quobyte)
        if isinstance(rbd, dict):
            rbd = TenantSpecSideCarsVolumesRbd(**rbd)
        if isinstance(scale_io, dict):
            scale_io = TenantSpecSideCarsVolumesScaleIo(**scale_io)
        if isinstance(secret, dict):
            secret = TenantSpecSideCarsVolumesSecret(**secret)
        if isinstance(storageos, dict):
            storageos = TenantSpecSideCarsVolumesStorageos(**storageos)
        if isinstance(vsphere_volume, dict):
            vsphere_volume = TenantSpecSideCarsVolumesVsphereVolume(**vsphere_volume)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumes.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument aws_elastic_block_store", value=aws_elastic_block_store, expected_type=type_hints["aws_elastic_block_store"])
            check_type(argname="argument azure_disk", value=azure_disk, expected_type=type_hints["azure_disk"])
            check_type(argname="argument azure_file", value=azure_file, expected_type=type_hints["azure_file"])
            check_type(argname="argument cephfs", value=cephfs, expected_type=type_hints["cephfs"])
            check_type(argname="argument cinder", value=cinder, expected_type=type_hints["cinder"])
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument csi", value=csi, expected_type=type_hints["csi"])
            check_type(argname="argument downward_api", value=downward_api, expected_type=type_hints["downward_api"])
            check_type(argname="argument empty_dir", value=empty_dir, expected_type=type_hints["empty_dir"])
            check_type(argname="argument ephemeral", value=ephemeral, expected_type=type_hints["ephemeral"])
            check_type(argname="argument fc", value=fc, expected_type=type_hints["fc"])
            check_type(argname="argument flex_volume", value=flex_volume, expected_type=type_hints["flex_volume"])
            check_type(argname="argument flocker", value=flocker, expected_type=type_hints["flocker"])
            check_type(argname="argument gce_persistent_disk", value=gce_persistent_disk, expected_type=type_hints["gce_persistent_disk"])
            check_type(argname="argument git_repo", value=git_repo, expected_type=type_hints["git_repo"])
            check_type(argname="argument glusterfs", value=glusterfs, expected_type=type_hints["glusterfs"])
            check_type(argname="argument host_path", value=host_path, expected_type=type_hints["host_path"])
            check_type(argname="argument iscsi", value=iscsi, expected_type=type_hints["iscsi"])
            check_type(argname="argument nfs", value=nfs, expected_type=type_hints["nfs"])
            check_type(argname="argument persistent_volume_claim", value=persistent_volume_claim, expected_type=type_hints["persistent_volume_claim"])
            check_type(argname="argument photon_persistent_disk", value=photon_persistent_disk, expected_type=type_hints["photon_persistent_disk"])
            check_type(argname="argument portworx_volume", value=portworx_volume, expected_type=type_hints["portworx_volume"])
            check_type(argname="argument projected", value=projected, expected_type=type_hints["projected"])
            check_type(argname="argument quobyte", value=quobyte, expected_type=type_hints["quobyte"])
            check_type(argname="argument rbd", value=rbd, expected_type=type_hints["rbd"])
            check_type(argname="argument scale_io", value=scale_io, expected_type=type_hints["scale_io"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument storageos", value=storageos, expected_type=type_hints["storageos"])
            check_type(argname="argument vsphere_volume", value=vsphere_volume, expected_type=type_hints["vsphere_volume"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if aws_elastic_block_store is not None:
            self._values["aws_elastic_block_store"] = aws_elastic_block_store
        if azure_disk is not None:
            self._values["azure_disk"] = azure_disk
        if azure_file is not None:
            self._values["azure_file"] = azure_file
        if cephfs is not None:
            self._values["cephfs"] = cephfs
        if cinder is not None:
            self._values["cinder"] = cinder
        if config_map is not None:
            self._values["config_map"] = config_map
        if csi is not None:
            self._values["csi"] = csi
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if empty_dir is not None:
            self._values["empty_dir"] = empty_dir
        if ephemeral is not None:
            self._values["ephemeral"] = ephemeral
        if fc is not None:
            self._values["fc"] = fc
        if flex_volume is not None:
            self._values["flex_volume"] = flex_volume
        if flocker is not None:
            self._values["flocker"] = flocker
        if gce_persistent_disk is not None:
            self._values["gce_persistent_disk"] = gce_persistent_disk
        if git_repo is not None:
            self._values["git_repo"] = git_repo
        if glusterfs is not None:
            self._values["glusterfs"] = glusterfs
        if host_path is not None:
            self._values["host_path"] = host_path
        if iscsi is not None:
            self._values["iscsi"] = iscsi
        if nfs is not None:
            self._values["nfs"] = nfs
        if persistent_volume_claim is not None:
            self._values["persistent_volume_claim"] = persistent_volume_claim
        if photon_persistent_disk is not None:
            self._values["photon_persistent_disk"] = photon_persistent_disk
        if portworx_volume is not None:
            self._values["portworx_volume"] = portworx_volume
        if projected is not None:
            self._values["projected"] = projected
        if quobyte is not None:
            self._values["quobyte"] = quobyte
        if rbd is not None:
            self._values["rbd"] = rbd
        if scale_io is not None:
            self._values["scale_io"] = scale_io
        if secret is not None:
            self._values["secret"] = secret
        if storageos is not None:
            self._values["storageos"] = storageos
        if vsphere_volume is not None:
            self._values["vsphere_volume"] = vsphere_volume

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aws_elastic_block_store(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesAwsElasticBlockStore"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#awsElasticBlockStore
        '''
        result = self._values.get("aws_elastic_block_store")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesAwsElasticBlockStore"], result)

    @builtins.property
    def azure_disk(self) -> typing.Optional["TenantSpecSideCarsVolumesAzureDisk"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#azureDisk
        '''
        result = self._values.get("azure_disk")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesAzureDisk"], result)

    @builtins.property
    def azure_file(self) -> typing.Optional["TenantSpecSideCarsVolumesAzureFile"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#azureFile
        '''
        result = self._values.get("azure_file")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesAzureFile"], result)

    @builtins.property
    def cephfs(self) -> typing.Optional["TenantSpecSideCarsVolumesCephfs"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#cephfs
        '''
        result = self._values.get("cephfs")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCephfs"], result)

    @builtins.property
    def cinder(self) -> typing.Optional["TenantSpecSideCarsVolumesCinder"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#cinder
        '''
        result = self._values.get("cinder")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCinder"], result)

    @builtins.property
    def config_map(self) -> typing.Optional["TenantSpecSideCarsVolumesConfigMap"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesConfigMap"], result)

    @builtins.property
    def csi(self) -> typing.Optional["TenantSpecSideCarsVolumesCsi"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#csi
        '''
        result = self._values.get("csi")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCsi"], result)

    @builtins.property
    def downward_api(self) -> typing.Optional["TenantSpecSideCarsVolumesDownwardApi"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#downwardAPI
        '''
        result = self._values.get("downward_api")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesDownwardApi"], result)

    @builtins.property
    def empty_dir(self) -> typing.Optional["TenantSpecSideCarsVolumesEmptyDir"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#emptyDir
        '''
        result = self._values.get("empty_dir")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEmptyDir"], result)

    @builtins.property
    def ephemeral(self) -> typing.Optional["TenantSpecSideCarsVolumesEphemeral"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#ephemeral
        '''
        result = self._values.get("ephemeral")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeral"], result)

    @builtins.property
    def fc(self) -> typing.Optional["TenantSpecSideCarsVolumesFc"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#fc
        '''
        result = self._values.get("fc")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesFc"], result)

    @builtins.property
    def flex_volume(self) -> typing.Optional["TenantSpecSideCarsVolumesFlexVolume"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#flexVolume
        '''
        result = self._values.get("flex_volume")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesFlexVolume"], result)

    @builtins.property
    def flocker(self) -> typing.Optional["TenantSpecSideCarsVolumesFlocker"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#flocker
        '''
        result = self._values.get("flocker")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesFlocker"], result)

    @builtins.property
    def gce_persistent_disk(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesGcePersistentDisk"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#gcePersistentDisk
        '''
        result = self._values.get("gce_persistent_disk")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesGcePersistentDisk"], result)

    @builtins.property
    def git_repo(self) -> typing.Optional["TenantSpecSideCarsVolumesGitRepo"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#gitRepo
        '''
        result = self._values.get("git_repo")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesGitRepo"], result)

    @builtins.property
    def glusterfs(self) -> typing.Optional["TenantSpecSideCarsVolumesGlusterfs"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#glusterfs
        '''
        result = self._values.get("glusterfs")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesGlusterfs"], result)

    @builtins.property
    def host_path(self) -> typing.Optional["TenantSpecSideCarsVolumesHostPath"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#hostPath
        '''
        result = self._values.get("host_path")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesHostPath"], result)

    @builtins.property
    def iscsi(self) -> typing.Optional["TenantSpecSideCarsVolumesIscsi"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#iscsi
        '''
        result = self._values.get("iscsi")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesIscsi"], result)

    @builtins.property
    def nfs(self) -> typing.Optional["TenantSpecSideCarsVolumesNfs"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#nfs
        '''
        result = self._values.get("nfs")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesNfs"], result)

    @builtins.property
    def persistent_volume_claim(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesPersistentVolumeClaim"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#persistentVolumeClaim
        '''
        result = self._values.get("persistent_volume_claim")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesPersistentVolumeClaim"], result)

    @builtins.property
    def photon_persistent_disk(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesPhotonPersistentDisk"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#photonPersistentDisk
        '''
        result = self._values.get("photon_persistent_disk")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesPhotonPersistentDisk"], result)

    @builtins.property
    def portworx_volume(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesPortworxVolume"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#portworxVolume
        '''
        result = self._values.get("portworx_volume")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesPortworxVolume"], result)

    @builtins.property
    def projected(self) -> typing.Optional["TenantSpecSideCarsVolumesProjected"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#projected
        '''
        result = self._values.get("projected")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjected"], result)

    @builtins.property
    def quobyte(self) -> typing.Optional["TenantSpecSideCarsVolumesQuobyte"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#quobyte
        '''
        result = self._values.get("quobyte")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesQuobyte"], result)

    @builtins.property
    def rbd(self) -> typing.Optional["TenantSpecSideCarsVolumesRbd"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#rbd
        '''
        result = self._values.get("rbd")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesRbd"], result)

    @builtins.property
    def scale_io(self) -> typing.Optional["TenantSpecSideCarsVolumesScaleIo"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#scaleIO
        '''
        result = self._values.get("scale_io")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesScaleIo"], result)

    @builtins.property
    def secret(self) -> typing.Optional["TenantSpecSideCarsVolumesSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesSecret"], result)

    @builtins.property
    def storageos(self) -> typing.Optional["TenantSpecSideCarsVolumesStorageos"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#storageos
        '''
        result = self._values.get("storageos")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesStorageos"], result)

    @builtins.property
    def vsphere_volume(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesVsphereVolume"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumes#vsphereVolume
        '''
        result = self._values.get("vsphere_volume")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesVsphereVolume"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesAwsElasticBlockStore",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class TenantSpecSideCarsVolumesAwsElasticBlockStore:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param partition: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAwsElasticBlockStore
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesAwsElasticBlockStore.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument partition", value=partition, expected_type=type_hints["partition"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAwsElasticBlockStore#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAwsElasticBlockStore#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAwsElasticBlockStore#partition
        '''
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAwsElasticBlockStore#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesAwsElasticBlockStore(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesAzureDisk",
    jsii_struct_bases=[],
    name_mapping={
        "disk_name": "diskName",
        "disk_uri": "diskUri",
        "caching_mode": "cachingMode",
        "fs_type": "fsType",
        "kind": "kind",
        "read_only": "readOnly",
    },
)
class TenantSpecSideCarsVolumesAzureDisk:
    def __init__(
        self,
        *,
        disk_name: builtins.str,
        disk_uri: builtins.str,
        caching_mode: typing.Optional[builtins.str] = None,
        fs_type: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param disk_name: 
        :param disk_uri: 
        :param caching_mode: 
        :param fs_type: 
        :param kind: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesAzureDisk.__init__)
            check_type(argname="argument disk_name", value=disk_name, expected_type=type_hints["disk_name"])
            check_type(argname="argument disk_uri", value=disk_uri, expected_type=type_hints["disk_uri"])
            check_type(argname="argument caching_mode", value=caching_mode, expected_type=type_hints["caching_mode"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "disk_name": disk_name,
            "disk_uri": disk_uri,
        }
        if caching_mode is not None:
            self._values["caching_mode"] = caching_mode
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if kind is not None:
            self._values["kind"] = kind
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def disk_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#diskName
        '''
        result = self._values.get("disk_name")
        assert result is not None, "Required property 'disk_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disk_uri(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#diskURI
        '''
        result = self._values.get("disk_uri")
        assert result is not None, "Required property 'disk_uri' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def caching_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#cachingMode
        '''
        result = self._values.get("caching_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureDisk#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesAzureDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesAzureFile",
    jsii_struct_bases=[],
    name_mapping={
        "secret_name": "secretName",
        "share_name": "shareName",
        "read_only": "readOnly",
    },
)
class TenantSpecSideCarsVolumesAzureFile:
    def __init__(
        self,
        *,
        secret_name: builtins.str,
        share_name: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param secret_name: 
        :param share_name: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureFile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesAzureFile.__init__)
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument share_name", value=share_name, expected_type=type_hints["share_name"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_name": secret_name,
            "share_name": share_name,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def secret_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureFile#secretName
        '''
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def share_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureFile#shareName
        '''
        result = self._values.get("share_name")
        assert result is not None, "Required property 'share_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesAzureFile#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesAzureFile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCephfs",
    jsii_struct_bases=[],
    name_mapping={
        "monitors": "monitors",
        "path": "path",
        "read_only": "readOnly",
        "secret_file": "secretFile",
        "secret_ref": "secretRef",
        "user": "user",
    },
)
class TenantSpecSideCarsVolumesCephfs:
    def __init__(
        self,
        *,
        monitors: typing.Sequence[builtins.str],
        path: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_file: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCephfsSecretRef", typing.Dict[str, typing.Any]]] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param monitors: 
        :param path: 
        :param read_only: 
        :param secret_file: 
        :param secret_ref: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesCephfsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCephfs.__init__)
            check_type(argname="argument monitors", value=monitors, expected_type=type_hints["monitors"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_file", value=secret_file, expected_type=type_hints["secret_file"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "monitors": monitors,
        }
        if path is not None:
            self._values["path"] = path
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_file is not None:
            self._values["secret_file"] = secret_file
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def monitors(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#monitors
        '''
        result = self._values.get("monitors")
        assert result is not None, "Required property 'monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_file(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#secretFile
        '''
        result = self._values.get("secret_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["TenantSpecSideCarsVolumesCephfsSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCephfsSecretRef"], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfs#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCephfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCephfsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesCephfsSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCephfsSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCephfsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCephfsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCinder",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantSpecSideCarsVolumesCinder:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCinderSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinder
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesCinderSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCinder.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinder#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinder#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinder#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["TenantSpecSideCarsVolumesCinderSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinder#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCinderSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCinder(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCinderSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesCinderSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinderSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCinderSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCinderSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCinderSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesConfigMap",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "name": "name",
        "optional": "optional",
    },
)
class TenantSpecSideCarsVolumesConfigMap:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesConfigMapItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesConfigMap.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMap#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesConfigMapItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMap#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesConfigMapItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMap#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMap#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantSpecSideCarsVolumesConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesConfigMapItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMapItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesConfigMapItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCsi",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "node_publish_secret_ref": "nodePublishSecretRef",
        "read_only": "readOnly",
        "volume_attributes": "volumeAttributes",
    },
)
class TenantSpecSideCarsVolumesCsi:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        node_publish_secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesCsiNodePublishSecretRef", typing.Dict[str, typing.Any]]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        volume_attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param driver: 
        :param fs_type: 
        :param node_publish_secret_ref: 
        :param read_only: 
        :param volume_attributes: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi
        '''
        if isinstance(node_publish_secret_ref, dict):
            node_publish_secret_ref = TenantSpecSideCarsVolumesCsiNodePublishSecretRef(**node_publish_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCsi.__init__)
            check_type(argname="argument driver", value=driver, expected_type=type_hints["driver"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument node_publish_secret_ref", value=node_publish_secret_ref, expected_type=type_hints["node_publish_secret_ref"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument volume_attributes", value=volume_attributes, expected_type=type_hints["volume_attributes"])
        self._values: typing.Dict[str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if node_publish_secret_ref is not None:
            self._values["node_publish_secret_ref"] = node_publish_secret_ref
        if read_only is not None:
            self._values["read_only"] = read_only
        if volume_attributes is not None:
            self._values["volume_attributes"] = volume_attributes

    @builtins.property
    def driver(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi#driver
        '''
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_publish_secret_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesCsiNodePublishSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi#nodePublishSecretRef
        '''
        result = self._values.get("node_publish_secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesCsiNodePublishSecretRef"], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_attributes(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsi#volumeAttributes
        '''
        result = self._values.get("volume_attributes")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesCsiNodePublishSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesCsiNodePublishSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsiNodePublishSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesCsiNodePublishSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesCsiNodePublishSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesCsiNodePublishSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"default_mode": "defaultMode", "items": "items"},
)
class TenantSpecSideCarsVolumesDownwardApi:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesDownwardApiItems", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApi
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApi.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApi#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesDownwardApiItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApi#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesDownwardApiItems"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesDownwardApi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "field_ref": "fieldRef",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class TenantSpecSideCarsVolumesDownwardApiItems:
    def __init__(
        self,
        *,
        path: builtins.str,
        field_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesDownwardApiItemsFieldRef", typing.Dict[str, typing.Any]]] = None,
        mode: typing.Optional[jsii.Number] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param path: 
        :param field_ref: 
        :param mode: 
        :param resource_field_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItems
        '''
        if isinstance(field_ref, dict):
            field_ref = TenantSpecSideCarsVolumesDownwardApiItemsFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef(**resource_field_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApiItems.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItems#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsFieldRef"], result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItems#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesDownwardApiItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantSpecSideCarsVolumesDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApiItemsFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesDownwardApiItemsFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEmptyDir",
    jsii_struct_bases=[],
    name_mapping={"medium": "medium", "size_limit": "sizeLimit"},
)
class TenantSpecSideCarsVolumesEmptyDir:
    def __init__(
        self,
        *,
        medium: typing.Optional[builtins.str] = None,
        size_limit: typing.Optional["TenantSpecSideCarsVolumesEmptyDirSizeLimit"] = None,
    ) -> None:
        '''
        :param medium: 
        :param size_limit: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEmptyDir
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEmptyDir.__init__)
            check_type(argname="argument medium", value=medium, expected_type=type_hints["medium"])
            check_type(argname="argument size_limit", value=size_limit, expected_type=type_hints["size_limit"])
        self._values: typing.Dict[str, typing.Any] = {}
        if medium is not None:
            self._values["medium"] = medium
        if size_limit is not None:
            self._values["size_limit"] = size_limit

    @builtins.property
    def medium(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEmptyDir#medium
        '''
        result = self._values.get("medium")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def size_limit(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEmptyDirSizeLimit"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEmptyDir#sizeLimit
        '''
        result = self._values.get("size_limit")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEmptyDirSizeLimit"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEmptyDir(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumesEmptyDirSizeLimit(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEmptyDirSizeLimit",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumesEmptyDirSizeLimit
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumesEmptyDirSizeLimit":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEmptyDirSizeLimit.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEmptyDirSizeLimit", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumesEmptyDirSizeLimit":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEmptyDirSizeLimit.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEmptyDirSizeLimit", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeral",
    jsii_struct_bases=[],
    name_mapping={
        "read_only": "readOnly",
        "volume_claim_template": "volumeClaimTemplate",
    },
)
class TenantSpecSideCarsVolumesEphemeral:
    def __init__(
        self,
        *,
        read_only: typing.Optional[builtins.bool] = None,
        volume_claim_template: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param read_only: 
        :param volume_claim_template: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeral
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate(**volume_claim_template)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeral.__init__)
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
        self._values: typing.Dict[str, typing.Any] = {}
        if read_only is not None:
            self._values["read_only"] = read_only
        if volume_claim_template is not None:
            self._values["volume_claim_template"] = volume_claim_template

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeral#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_claim_template(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeral#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeral(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata"},
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate:
    def __init__(
        self,
        *,
        spec: typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param spec: 
        :param metadata: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate
        '''
        if isinstance(spec, dict):
            spec = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec(**spec)
        if isinstance(metadata, dict):
            metadata = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate.__init__)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def spec(self) -> "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec", result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesFc",
    jsii_struct_bases=[],
    name_mapping={
        "fs_type": "fsType",
        "lun": "lun",
        "read_only": "readOnly",
        "target_ww_ns": "targetWwNs",
        "wwids": "wwids",
    },
)
class TenantSpecSideCarsVolumesFc:
    def __init__(
        self,
        *,
        fs_type: typing.Optional[builtins.str] = None,
        lun: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
        target_ww_ns: typing.Optional[typing.Sequence[builtins.str]] = None,
        wwids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fs_type: 
        :param lun: 
        :param read_only: 
        :param target_ww_ns: 
        :param wwids: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesFc.__init__)
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument lun", value=lun, expected_type=type_hints["lun"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument target_ww_ns", value=target_ww_ns, expected_type=type_hints["target_ww_ns"])
            check_type(argname="argument wwids", value=wwids, expected_type=type_hints["wwids"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if lun is not None:
            self._values["lun"] = lun
        if read_only is not None:
            self._values["read_only"] = read_only
        if target_ww_ns is not None:
            self._values["target_ww_ns"] = target_ww_ns
        if wwids is not None:
            self._values["wwids"] = wwids

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lun(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc#lun
        '''
        result = self._values.get("lun")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def target_ww_ns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc#targetWWNs
        '''
        result = self._values.get("target_ww_ns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def wwids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFc#wwids
        '''
        result = self._values.get("wwids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesFc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesFlexVolume",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "options": "options",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantSpecSideCarsVolumesFlexVolume:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        options: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesFlexVolumeSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param driver: 
        :param fs_type: 
        :param options: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesFlexVolumeSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesFlexVolume.__init__)
            check_type(argname="argument driver", value=driver, expected_type=type_hints["driver"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if options is not None:
            self._values["options"] = options
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def driver(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume#driver
        '''
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def options(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume#options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesFlexVolumeSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolume#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesFlexVolumeSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesFlexVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesFlexVolumeSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesFlexVolumeSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolumeSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesFlexVolumeSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlexVolumeSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesFlexVolumeSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesFlocker",
    jsii_struct_bases=[],
    name_mapping={"dataset_name": "datasetName", "dataset_uuid": "datasetUuid"},
)
class TenantSpecSideCarsVolumesFlocker:
    def __init__(
        self,
        *,
        dataset_name: typing.Optional[builtins.str] = None,
        dataset_uuid: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param dataset_name: 
        :param dataset_uuid: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlocker
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesFlocker.__init__)
            check_type(argname="argument dataset_name", value=dataset_name, expected_type=type_hints["dataset_name"])
            check_type(argname="argument dataset_uuid", value=dataset_uuid, expected_type=type_hints["dataset_uuid"])
        self._values: typing.Dict[str, typing.Any] = {}
        if dataset_name is not None:
            self._values["dataset_name"] = dataset_name
        if dataset_uuid is not None:
            self._values["dataset_uuid"] = dataset_uuid

    @builtins.property
    def dataset_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlocker#datasetName
        '''
        result = self._values.get("dataset_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dataset_uuid(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesFlocker#datasetUUID
        '''
        result = self._values.get("dataset_uuid")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesFlocker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesGcePersistentDisk",
    jsii_struct_bases=[],
    name_mapping={
        "pd_name": "pdName",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class TenantSpecSideCarsVolumesGcePersistentDisk:
    def __init__(
        self,
        *,
        pd_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param pd_name: 
        :param fs_type: 
        :param partition: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGcePersistentDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesGcePersistentDisk.__init__)
            check_type(argname="argument pd_name", value=pd_name, expected_type=type_hints["pd_name"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument partition", value=partition, expected_type=type_hints["partition"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "pd_name": pd_name,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def pd_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGcePersistentDisk#pdName
        '''
        result = self._values.get("pd_name")
        assert result is not None, "Required property 'pd_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGcePersistentDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGcePersistentDisk#partition
        '''
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGcePersistentDisk#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesGcePersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesGitRepo",
    jsii_struct_bases=[],
    name_mapping={
        "repository": "repository",
        "directory": "directory",
        "revision": "revision",
    },
)
class TenantSpecSideCarsVolumesGitRepo:
    def __init__(
        self,
        *,
        repository: builtins.str,
        directory: typing.Optional[builtins.str] = None,
        revision: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param repository: 
        :param directory: 
        :param revision: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGitRepo
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesGitRepo.__init__)
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument directory", value=directory, expected_type=type_hints["directory"])
            check_type(argname="argument revision", value=revision, expected_type=type_hints["revision"])
        self._values: typing.Dict[str, typing.Any] = {
            "repository": repository,
        }
        if directory is not None:
            self._values["directory"] = directory
        if revision is not None:
            self._values["revision"] = revision

    @builtins.property
    def repository(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGitRepo#repository
        '''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def directory(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGitRepo#directory
        '''
        result = self._values.get("directory")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def revision(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGitRepo#revision
        '''
        result = self._values.get("revision")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesGitRepo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesGlusterfs",
    jsii_struct_bases=[],
    name_mapping={"endpoints": "endpoints", "path": "path", "read_only": "readOnly"},
)
class TenantSpecSideCarsVolumesGlusterfs:
    def __init__(
        self,
        *,
        endpoints: builtins.str,
        path: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param endpoints: 
        :param path: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGlusterfs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesGlusterfs.__init__)
            check_type(argname="argument endpoints", value=endpoints, expected_type=type_hints["endpoints"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "endpoints": endpoints,
            "path": path,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def endpoints(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGlusterfs#endpoints
        '''
        result = self._values.get("endpoints")
        assert result is not None, "Required property 'endpoints' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGlusterfs#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesGlusterfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesGlusterfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesHostPath",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "type": "type"},
)
class TenantSpecSideCarsVolumesHostPath:
    def __init__(
        self,
        *,
        path: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param path: 
        :param type: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesHostPath
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesHostPath.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesHostPath#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesHostPath#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesHostPath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesIscsi",
    jsii_struct_bases=[],
    name_mapping={
        "iqn": "iqn",
        "lun": "lun",
        "target_portal": "targetPortal",
        "chap_auth_discovery": "chapAuthDiscovery",
        "chap_auth_session": "chapAuthSession",
        "fs_type": "fsType",
        "initiator_name": "initiatorName",
        "iscsi_interface": "iscsiInterface",
        "portals": "portals",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantSpecSideCarsVolumesIscsi:
    def __init__(
        self,
        *,
        iqn: builtins.str,
        lun: jsii.Number,
        target_portal: builtins.str,
        chap_auth_discovery: typing.Optional[builtins.bool] = None,
        chap_auth_session: typing.Optional[builtins.bool] = None,
        fs_type: typing.Optional[builtins.str] = None,
        initiator_name: typing.Optional[builtins.str] = None,
        iscsi_interface: typing.Optional[builtins.str] = None,
        portals: typing.Optional[typing.Sequence[builtins.str]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesIscsiSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param iqn: 
        :param lun: 
        :param target_portal: 
        :param chap_auth_discovery: 
        :param chap_auth_session: 
        :param fs_type: 
        :param initiator_name: 
        :param iscsi_interface: 
        :param portals: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesIscsiSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesIscsi.__init__)
            check_type(argname="argument iqn", value=iqn, expected_type=type_hints["iqn"])
            check_type(argname="argument lun", value=lun, expected_type=type_hints["lun"])
            check_type(argname="argument target_portal", value=target_portal, expected_type=type_hints["target_portal"])
            check_type(argname="argument chap_auth_discovery", value=chap_auth_discovery, expected_type=type_hints["chap_auth_discovery"])
            check_type(argname="argument chap_auth_session", value=chap_auth_session, expected_type=type_hints["chap_auth_session"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument initiator_name", value=initiator_name, expected_type=type_hints["initiator_name"])
            check_type(argname="argument iscsi_interface", value=iscsi_interface, expected_type=type_hints["iscsi_interface"])
            check_type(argname="argument portals", value=portals, expected_type=type_hints["portals"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "iqn": iqn,
            "lun": lun,
            "target_portal": target_portal,
        }
        if chap_auth_discovery is not None:
            self._values["chap_auth_discovery"] = chap_auth_discovery
        if chap_auth_session is not None:
            self._values["chap_auth_session"] = chap_auth_session
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if initiator_name is not None:
            self._values["initiator_name"] = initiator_name
        if iscsi_interface is not None:
            self._values["iscsi_interface"] = iscsi_interface
        if portals is not None:
            self._values["portals"] = portals
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def iqn(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#iqn
        '''
        result = self._values.get("iqn")
        assert result is not None, "Required property 'iqn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def lun(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#lun
        '''
        result = self._values.get("lun")
        assert result is not None, "Required property 'lun' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def target_portal(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#targetPortal
        '''
        result = self._values.get("target_portal")
        assert result is not None, "Required property 'target_portal' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def chap_auth_discovery(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#chapAuthDiscovery
        '''
        result = self._values.get("chap_auth_discovery")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def chap_auth_session(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#chapAuthSession
        '''
        result = self._values.get("chap_auth_session")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initiator_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#initiatorName
        '''
        result = self._values.get("initiator_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iscsi_interface(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#iscsiInterface
        '''
        result = self._values.get("iscsi_interface")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def portals(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#portals
        '''
        result = self._values.get("portals")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["TenantSpecSideCarsVolumesIscsiSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsi#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesIscsiSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesIscsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesIscsiSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesIscsiSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsiSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesIscsiSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesIscsiSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesIscsiSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesNfs",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "server": "server", "read_only": "readOnly"},
)
class TenantSpecSideCarsVolumesNfs:
    def __init__(
        self,
        *,
        path: builtins.str,
        server: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param path: 
        :param server: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesNfs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesNfs.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "server": server,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesNfs#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesNfs#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesNfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesNfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesPersistentVolumeClaim",
    jsii_struct_bases=[],
    name_mapping={"claim_name": "claimName", "read_only": "readOnly"},
)
class TenantSpecSideCarsVolumesPersistentVolumeClaim:
    def __init__(
        self,
        *,
        claim_name: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param claim_name: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPersistentVolumeClaim
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesPersistentVolumeClaim.__init__)
            check_type(argname="argument claim_name", value=claim_name, expected_type=type_hints["claim_name"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "claim_name": claim_name,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def claim_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPersistentVolumeClaim#claimName
        '''
        result = self._values.get("claim_name")
        assert result is not None, "Required property 'claim_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPersistentVolumeClaim#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesPersistentVolumeClaim(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesPhotonPersistentDisk",
    jsii_struct_bases=[],
    name_mapping={"pd_id": "pdId", "fs_type": "fsType"},
)
class TenantSpecSideCarsVolumesPhotonPersistentDisk:
    def __init__(
        self,
        *,
        pd_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param pd_id: 
        :param fs_type: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPhotonPersistentDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesPhotonPersistentDisk.__init__)
            check_type(argname="argument pd_id", value=pd_id, expected_type=type_hints["pd_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
        self._values: typing.Dict[str, typing.Any] = {
            "pd_id": pd_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type

    @builtins.property
    def pd_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPhotonPersistentDisk#pdID
        '''
        result = self._values.get("pd_id")
        assert result is not None, "Required property 'pd_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPhotonPersistentDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesPhotonPersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesPortworxVolume",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "read_only": "readOnly",
    },
)
class TenantSpecSideCarsVolumesPortworxVolume:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param read_only: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPortworxVolume
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesPortworxVolume.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPortworxVolume#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPortworxVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesPortworxVolume#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesPortworxVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjected",
    jsii_struct_bases=[],
    name_mapping={"default_mode": "defaultMode", "sources": "sources"},
)
class TenantSpecSideCarsVolumesProjected:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        sources: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesProjectedSources", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param sources: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjected
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjected.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument sources", value=sources, expected_type=type_hints["sources"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if sources is not None:
            self._values["sources"] = sources

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjected#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sources(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSources"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjected#sources
        '''
        result = self._values.get("sources")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSources"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjected(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSources",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "downward_api": "downwardApi",
        "secret": "secret",
        "service_account_token": "serviceAccountToken",
    },
)
class TenantSpecSideCarsVolumesProjectedSources:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesConfigMap", typing.Dict[str, typing.Any]]] = None,
        downward_api: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesDownwardApi", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesSecret", typing.Dict[str, typing.Any]]] = None,
        service_account_token: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param downward_api: 
        :param secret: 
        :param service_account_token: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSources
        '''
        if isinstance(config_map, dict):
            config_map = TenantSpecSideCarsVolumesProjectedSourcesConfigMap(**config_map)
        if isinstance(downward_api, dict):
            downward_api = TenantSpecSideCarsVolumesProjectedSourcesDownwardApi(**downward_api)
        if isinstance(secret, dict):
            secret = TenantSpecSideCarsVolumesProjectedSourcesSecret(**secret)
        if isinstance(service_account_token, dict):
            service_account_token = TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken(**service_account_token)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSources.__init__)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument downward_api", value=downward_api, expected_type=type_hints["downward_api"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument service_account_token", value=service_account_token, expected_type=type_hints["service_account_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if secret is not None:
            self._values["secret"] = secret
        if service_account_token is not None:
            self._values["service_account_token"] = service_account_token

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesConfigMap"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSources#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesConfigMap"], result)

    @builtins.property
    def downward_api(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApi"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSources#downwardAPI
        '''
        result = self._values.get("downward_api")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApi"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesSecret"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSources#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesSecret"], result)

    @builtins.property
    def service_account_token(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSources#serviceAccountToken
        '''
        result = self._values.get("service_account_token")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class TenantSpecSideCarsVolumesProjectedSourcesConfigMap:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesConfigMap.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMap#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMap#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMap#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"items": "items"},
)
class TenantSpecSideCarsVolumesProjectedSourcesDownwardApi:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param items: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApi
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApi.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApi#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesDownwardApi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "field_ref": "fieldRef",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems:
    def __init__(
        self,
        *,
        path: builtins.str,
        field_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef", typing.Dict[str, typing.Any]]] = None,
        mode: typing.Optional[jsii.Number] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param path: 
        :param field_ref: 
        :param mode: 
        :param resource_field_ref: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems
        '''
        if isinstance(field_ref, dict):
            field_ref = TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(**resource_field_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef"], result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class TenantSpecSideCarsVolumesProjectedSourcesSecret:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesProjectedSourcesSecretItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesSecret.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesSecretItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecret#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesProjectedSourcesSecretItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecret#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantSpecSideCarsVolumesProjectedSourcesSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesSecretItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecretItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesSecretItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "audience": "audience",
        "expiration_seconds": "expirationSeconds",
    },
)
class TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken:
    def __init__(
        self,
        *,
        path: builtins.str,
        audience: typing.Optional[builtins.str] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param path: 
        :param audience: 
        :param expiration_seconds: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument audience", value=audience, expected_type=type_hints["audience"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if audience is not None:
            self._values["audience"] = audience
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audience(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken#audience
        '''
        result = self._values.get("audience")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesQuobyte",
    jsii_struct_bases=[],
    name_mapping={
        "registry": "registry",
        "volume": "volume",
        "group": "group",
        "read_only": "readOnly",
        "tenant": "tenant",
        "user": "user",
    },
)
class TenantSpecSideCarsVolumesQuobyte:
    def __init__(
        self,
        *,
        registry: builtins.str,
        volume: builtins.str,
        group: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        tenant: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry: 
        :param volume: 
        :param group: 
        :param read_only: 
        :param tenant: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesQuobyte.__init__)
            check_type(argname="argument registry", value=registry, expected_type=type_hints["registry"])
            check_type(argname="argument volume", value=volume, expected_type=type_hints["volume"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument tenant", value=tenant, expected_type=type_hints["tenant"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "registry": registry,
            "volume": volume,
        }
        if group is not None:
            self._values["group"] = group
        if read_only is not None:
            self._values["read_only"] = read_only
        if tenant is not None:
            self._values["tenant"] = tenant
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def registry(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#registry
        '''
        result = self._values.get("registry")
        assert result is not None, "Required property 'registry' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#volume
        '''
        result = self._values.get("volume")
        assert result is not None, "Required property 'volume' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tenant(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#tenant
        '''
        result = self._values.get("tenant")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesQuobyte#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesQuobyte(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesRbd",
    jsii_struct_bases=[],
    name_mapping={
        "image": "image",
        "monitors": "monitors",
        "fs_type": "fsType",
        "keyring": "keyring",
        "pool": "pool",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
        "user": "user",
    },
)
class TenantSpecSideCarsVolumesRbd:
    def __init__(
        self,
        *,
        image: builtins.str,
        monitors: typing.Sequence[builtins.str],
        fs_type: typing.Optional[builtins.str] = None,
        keyring: typing.Optional[builtins.str] = None,
        pool: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesRbdSecretRef", typing.Dict[str, typing.Any]]] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param image: 
        :param monitors: 
        :param fs_type: 
        :param keyring: 
        :param pool: 
        :param read_only: 
        :param secret_ref: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesRbdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesRbd.__init__)
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument monitors", value=monitors, expected_type=type_hints["monitors"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument keyring", value=keyring, expected_type=type_hints["keyring"])
            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "image": image,
            "monitors": monitors,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if keyring is not None:
            self._values["keyring"] = keyring
        if pool is not None:
            self._values["pool"] = pool
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def image(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#image
        '''
        result = self._values.get("image")
        assert result is not None, "Required property 'image' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def monitors(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#monitors
        '''
        result = self._values.get("monitors")
        assert result is not None, "Required property 'monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def keyring(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#keyring
        '''
        result = self._values.get("keyring")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pool(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#pool
        '''
        result = self._values.get("pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["TenantSpecSideCarsVolumesRbdSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesRbdSecretRef"], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbd#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesRbd(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesRbdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesRbdSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesRbdSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesRbdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesRbdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesScaleIo",
    jsii_struct_bases=[],
    name_mapping={
        "gateway": "gateway",
        "secret_ref": "secretRef",
        "system": "system",
        "fs_type": "fsType",
        "protection_domain": "protectionDomain",
        "read_only": "readOnly",
        "ssl_enabled": "sslEnabled",
        "storage_mode": "storageMode",
        "storage_pool": "storagePool",
        "volume_name": "volumeName",
    },
)
class TenantSpecSideCarsVolumesScaleIo:
    def __init__(
        self,
        *,
        gateway: builtins.str,
        secret_ref: typing.Union["TenantSpecSideCarsVolumesScaleIoSecretRef", typing.Dict[str, typing.Any]],
        system: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        protection_domain: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        ssl_enabled: typing.Optional[builtins.bool] = None,
        storage_mode: typing.Optional[builtins.str] = None,
        storage_pool: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gateway: 
        :param secret_ref: 
        :param system: 
        :param fs_type: 
        :param protection_domain: 
        :param read_only: 
        :param ssl_enabled: 
        :param storage_mode: 
        :param storage_pool: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesScaleIoSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesScaleIo.__init__)
            check_type(argname="argument gateway", value=gateway, expected_type=type_hints["gateway"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument system", value=system, expected_type=type_hints["system"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument protection_domain", value=protection_domain, expected_type=type_hints["protection_domain"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument ssl_enabled", value=ssl_enabled, expected_type=type_hints["ssl_enabled"])
            check_type(argname="argument storage_mode", value=storage_mode, expected_type=type_hints["storage_mode"])
            check_type(argname="argument storage_pool", value=storage_pool, expected_type=type_hints["storage_pool"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "gateway": gateway,
            "secret_ref": secret_ref,
            "system": system,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if protection_domain is not None:
            self._values["protection_domain"] = protection_domain
        if read_only is not None:
            self._values["read_only"] = read_only
        if ssl_enabled is not None:
            self._values["ssl_enabled"] = ssl_enabled
        if storage_mode is not None:
            self._values["storage_mode"] = storage_mode
        if storage_pool is not None:
            self._values["storage_pool"] = storage_pool
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def gateway(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#gateway
        '''
        result = self._values.get("gateway")
        assert result is not None, "Required property 'gateway' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "TenantSpecSideCarsVolumesScaleIoSecretRef":
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("TenantSpecSideCarsVolumesScaleIoSecretRef", result)

    @builtins.property
    def system(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#system
        '''
        result = self._values.get("system")
        assert result is not None, "Required property 'system' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protection_domain(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#protectionDomain
        '''
        result = self._values.get("protection_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ssl_enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#sslEnabled
        '''
        result = self._values.get("ssl_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#storageMode
        '''
        result = self._values.get("storage_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_pool(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#storagePool
        '''
        result = self._values.get("storage_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIo#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesScaleIo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesScaleIoSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesScaleIoSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIoSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesScaleIoSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesScaleIoSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesScaleIoSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesSecret",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "optional": "optional",
        "secret_name": "secretName",
    },
)
class TenantSpecSideCarsVolumesSecret:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantSpecSideCarsVolumesSecretItems", typing.Dict[str, typing.Any]]]] = None,
        optional: typing.Optional[builtins.bool] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 
        :param optional: 
        :param secret_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesSecret.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if optional is not None:
            self._values["optional"] = optional
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecret#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantSpecSideCarsVolumesSecretItems"]]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecret#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantSpecSideCarsVolumesSecretItems"]], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecret#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecret#secretName
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantSpecSideCarsVolumesSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesSecretItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecretItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesSecretItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesStorageos",
    jsii_struct_bases=[],
    name_mapping={
        "fs_type": "fsType",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
        "volume_name": "volumeName",
        "volume_namespace": "volumeNamespace",
    },
)
class TenantSpecSideCarsVolumesStorageos:
    def __init__(
        self,
        *,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantSpecSideCarsVolumesStorageosSecretRef", typing.Dict[str, typing.Any]]] = None,
        volume_name: typing.Optional[builtins.str] = None,
        volume_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param fs_type: 
        :param read_only: 
        :param secret_ref: 
        :param volume_name: 
        :param volume_namespace: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantSpecSideCarsVolumesStorageosSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesStorageos.__init__)
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
            check_type(argname="argument volume_namespace", value=volume_namespace, expected_type=type_hints["volume_namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if volume_name is not None:
            self._values["volume_name"] = volume_name
        if volume_namespace is not None:
            self._values["volume_namespace"] = volume_namespace

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantSpecSideCarsVolumesStorageosSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantSpecSideCarsVolumesStorageosSecretRef"], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageos#volumeNamespace
        '''
        result = self._values.get("volume_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesStorageos(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesStorageosSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecSideCarsVolumesStorageosSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageosSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesStorageosSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesStorageosSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesStorageosSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecSideCarsVolumesVsphereVolume",
    jsii_struct_bases=[],
    name_mapping={
        "volume_path": "volumePath",
        "fs_type": "fsType",
        "storage_policy_id": "storagePolicyId",
        "storage_policy_name": "storagePolicyName",
    },
)
class TenantSpecSideCarsVolumesVsphereVolume:
    def __init__(
        self,
        *,
        volume_path: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        storage_policy_id: typing.Optional[builtins.str] = None,
        storage_policy_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param volume_path: 
        :param fs_type: 
        :param storage_policy_id: 
        :param storage_policy_name: 

        :stability: experimental
        :schema: TenantSpecSideCarsVolumesVsphereVolume
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecSideCarsVolumesVsphereVolume.__init__)
            check_type(argname="argument volume_path", value=volume_path, expected_type=type_hints["volume_path"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument storage_policy_id", value=storage_policy_id, expected_type=type_hints["storage_policy_id"])
            check_type(argname="argument storage_policy_name", value=storage_policy_name, expected_type=type_hints["storage_policy_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_path": volume_path,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if storage_policy_id is not None:
            self._values["storage_policy_id"] = storage_policy_id
        if storage_policy_name is not None:
            self._values["storage_policy_name"] = storage_policy_name

    @builtins.property
    def volume_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesVsphereVolume#volumePath
        '''
        result = self._values.get("volume_path")
        assert result is not None, "Required property 'volume_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesVsphereVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_policy_id(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesVsphereVolume#storagePolicyID
        '''
        result = self._values.get("storage_policy_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_policy_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecSideCarsVolumesVsphereVolume#storagePolicyName
        '''
        result = self._values.get("storage_policy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecSideCarsVolumesVsphereVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecUsers",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantSpecUsers:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantSpecUsers
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecUsers.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecUsers#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecUsers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZones",
    jsii_struct_bases=[],
    name_mapping={
        "servers": "servers",
        "volume_claim_template": "volumeClaimTemplate",
        "volumes_per_server": "volumesPerServer",
        "affinity": "affinity",
        "annotations": "annotations",
        "labels": "labels",
        "name": "name",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantSpecZones:
    def __init__(
        self,
        *,
        servers: jsii.Number,
        volume_claim_template: typing.Union["TenantSpecZonesVolumeClaimTemplate", typing.Dict[str, typing.Any]],
        volumes_per_server: jsii.Number,
        affinity: typing.Optional[typing.Union["TenantSpecZonesAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantSpecZonesResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantSpecZonesSecurityContext", typing.Dict[str, typing.Any]]] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param servers: 
        :param volume_claim_template: 
        :param volumes_per_server: 
        :param affinity: 
        :param annotations: 
        :param labels: 
        :param name: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantSpecZones
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantSpecZonesVolumeClaimTemplate(**volume_claim_template)
        if isinstance(affinity, dict):
            affinity = TenantSpecZonesAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantSpecZonesResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantSpecZonesSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZones.__init__)
            check_type(argname="argument servers", value=servers, expected_type=type_hints["servers"])
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
            check_type(argname="argument volumes_per_server", value=volumes_per_server, expected_type=type_hints["volumes_per_server"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "servers": servers,
            "volume_claim_template": volume_claim_template,
            "volumes_per_server": volumes_per_server,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def servers(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZones#servers
        '''
        result = self._values.get("servers")
        assert result is not None, "Required property 'servers' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def volume_claim_template(self) -> "TenantSpecZonesVolumeClaimTemplate":
        '''
        :stability: experimental
        :schema: TenantSpecZones#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        assert result is not None, "Required property 'volume_claim_template' is missing"
        return typing.cast("TenantSpecZonesVolumeClaimTemplate", result)

    @builtins.property
    def volumes_per_server(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZones#volumesPerServer
        '''
        result = self._values.get("volumes_per_server")
        assert result is not None, "Required property 'volumes_per_server' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantSpecZonesAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantSpecZonesAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantSpecZonesResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecZonesResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantSpecZonesSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantSpecZonesSecurityContext"], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantSpecZonesTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZones#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZones(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantSpecZonesAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantSpecZonesAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantSpecZonesAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantSpecZonesAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantSpecZonesAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantSpecZonesAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantSpecZonesAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantSpecZonesAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecZonesAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecZonesAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantSpecZonesAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecZonesResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecZonesResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecZonesResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecZonesResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecZonesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecZonesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecZonesResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecZonesResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantSpecZonesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantSpecZonesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantSpecZonesSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantSpecZonesSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantSpecZonesSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantSpecZonesSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantSpecZonesSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantSpecZonesSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantSpecZonesSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantSpecZonesSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantSpecZonesSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantSpecZonesSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantSpecZonesSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantSpecZonesSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantSpecZonesSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantSpecZonesSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantSpecZonesSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantSpecZonesSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantSpecZonesSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantSpecZonesSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantSpecZonesSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantSpecZonesTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantSpecZonesTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantSpecZonesTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantSpecZonesTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantSpecZonesTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantSpecZonesTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantSpecZonesTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantSpecZonesVolumeClaimTemplate:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate
        '''
        if isinstance(metadata, dict):
            metadata = TenantSpecZonesVolumeClaimTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantSpecZonesVolumeClaimTemplateSpec(**spec)
        if isinstance(status, dict):
            status = TenantSpecZonesVolumeClaimTemplateStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplate.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateSpec"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateSpec"], result)

    @builtins.property
    def status(self) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateStatus"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplate#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantSpecZonesVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantSpecZonesVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantSpecZonesVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantSpecZonesVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantSpecZonesVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantSpecZonesVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantSpecZonesVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantSpecZonesVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantSpecZonesVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantSpecZonesVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantSpecZonesVolumeClaimTemplateStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantSpecZonesVolumeClaimTemplateStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantSpecZonesVolumeClaimTemplateStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantSpecZonesVolumeClaimTemplateStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantSpecZonesVolumeClaimTemplateStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantSpecZonesVolumeClaimTemplateStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantSpecZonesVolumeClaimTemplateStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantSpecZonesVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantSpecZonesVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantSpecZonesVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantSpecZonesVolumeClaimTemplateStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantSpecZonesVolumeClaimTemplateStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantSpecZonesVolumeClaimTemplateStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantSpecZonesVolumeClaimTemplateStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantSpecZonesVolumeClaimTemplateStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2",
):
    '''
    :stability: experimental
    :schema: TenantV2
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        spec: typing.Union["TenantV2Spec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantV2Scheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Defines a "TenantV2" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = TenantV2Props(spec=spec, metadata=metadata, scheduler=scheduler)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest") # type: ignore[misc]
    @builtins.classmethod
    def manifest(
        cls,
        *,
        spec: typing.Union["TenantV2Spec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantV2Scheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''(experimental) Renders a Kubernetes manifest for "TenantV2".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        '''
        props = TenantV2Props(spec=spec, metadata=metadata, scheduler=scheduler)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''(experimental) Renders the object to Kubernetes JSON.

        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''(experimental) Returns the apiVersion and kind for "TenantV2".

        :stability: experimental
        '''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2Props",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata", "scheduler": "scheduler"},
)
class TenantV2Props:
    def __init__(
        self,
        *,
        spec: typing.Union["TenantV2Spec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        scheduler: typing.Optional[typing.Union["TenantV2Scheduler", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param spec: 
        :param metadata: 
        :param scheduler: 

        :stability: experimental
        :schema: TenantV2
        '''
        if isinstance(spec, dict):
            spec = TenantV2Spec(**spec)
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(scheduler, dict):
            scheduler = TenantV2Scheduler(**scheduler)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2Props.__init__)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument scheduler", value=scheduler, expected_type=type_hints["scheduler"])
        self._values: typing.Dict[str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata
        if scheduler is not None:
            self._values["scheduler"] = scheduler

    @builtins.property
    def spec(self) -> "TenantV2Spec":
        '''
        :stability: experimental
        :schema: TenantV2#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("TenantV2Spec", result)

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :stability: experimental
        :schema: TenantV2#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def scheduler(self) -> typing.Optional["TenantV2Scheduler"]:
        '''
        :stability: experimental
        :schema: TenantV2#scheduler
        '''
        result = self._values.get("scheduler")
        return typing.cast(typing.Optional["TenantV2Scheduler"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2Scheduler",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2Scheduler:
    def __init__(self, *, name: builtins.str) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2Scheduler
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2Scheduler.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2Scheduler#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2Scheduler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2Spec",
    jsii_struct_bases=[],
    name_mapping={
        "pools": "pools",
        "buckets": "buckets",
        "cert_config": "certConfig",
        "configuration": "configuration",
        "creds_secret": "credsSecret",
        "env": "env",
        "expose_services": "exposeServices",
        "external_ca_cert_secret": "externalCaCertSecret",
        "external_cert_secret": "externalCertSecret",
        "external_client_cert_secret": "externalClientCertSecret",
        "features": "features",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "image_pull_secret": "imagePullSecret",
        "kes": "kes",
        "liveness": "liveness",
        "log": "log",
        "logging": "logging",
        "mount_path": "mountPath",
        "pod_management_policy": "podManagementPolicy",
        "priority_class_name": "priorityClassName",
        "prometheus": "prometheus",
        "prometheus_operator": "prometheusOperator",
        "readiness": "readiness",
        "request_auto_cert": "requestAutoCert",
        "s3": "s3",
        "service_account_name": "serviceAccountName",
        "service_metadata": "serviceMetadata",
        "side_cars": "sideCars",
        "sub_path": "subPath",
        "users": "users",
    },
)
class TenantV2Spec:
    def __init__(
        self,
        *,
        pools: typing.Sequence[typing.Union["TenantV2SpecPools", typing.Dict[str, typing.Any]]],
        buckets: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecBuckets", typing.Dict[str, typing.Any]]]] = None,
        cert_config: typing.Optional[typing.Union["TenantV2SpecCertConfig", typing.Dict[str, typing.Any]]] = None,
        configuration: typing.Optional[typing.Union["TenantV2SpecConfiguration", typing.Dict[str, typing.Any]]] = None,
        creds_secret: typing.Optional[typing.Union["TenantV2SpecCredsSecret", typing.Dict[str, typing.Any]]] = None,
        env: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecEnv", typing.Dict[str, typing.Any]]]] = None,
        expose_services: typing.Optional[typing.Union["TenantV2SpecExposeServices", typing.Dict[str, typing.Any]]] = None,
        external_ca_cert_secret: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecExternalCaCertSecret", typing.Dict[str, typing.Any]]]] = None,
        external_cert_secret: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecExternalCertSecret", typing.Dict[str, typing.Any]]]] = None,
        external_client_cert_secret: typing.Optional[typing.Union["TenantV2SpecExternalClientCertSecret", typing.Dict[str, typing.Any]]] = None,
        features: typing.Optional[typing.Union["TenantV2SpecFeatures", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        image_pull_secret: typing.Optional[typing.Union["TenantV2SpecImagePullSecret", typing.Dict[str, typing.Any]]] = None,
        kes: typing.Optional[typing.Union["TenantV2SpecKes", typing.Dict[str, typing.Any]]] = None,
        liveness: typing.Optional[typing.Union["TenantV2SpecLiveness", typing.Dict[str, typing.Any]]] = None,
        log: typing.Optional[typing.Union["TenantV2SpecLog", typing.Dict[str, typing.Any]]] = None,
        logging: typing.Optional[typing.Union["TenantV2SpecLogging", typing.Dict[str, typing.Any]]] = None,
        mount_path: typing.Optional[builtins.str] = None,
        pod_management_policy: typing.Optional[builtins.str] = None,
        priority_class_name: typing.Optional[builtins.str] = None,
        prometheus: typing.Optional[typing.Union["TenantV2SpecPrometheus", typing.Dict[str, typing.Any]]] = None,
        prometheus_operator: typing.Optional[builtins.bool] = None,
        readiness: typing.Optional[typing.Union["TenantV2SpecReadiness", typing.Dict[str, typing.Any]]] = None,
        request_auto_cert: typing.Optional[builtins.bool] = None,
        s3: typing.Optional[typing.Union["TenantV2SpecS3", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        service_metadata: typing.Optional[typing.Union["TenantV2SpecServiceMetadata", typing.Dict[str, typing.Any]]] = None,
        side_cars: typing.Optional[typing.Union["TenantV2SpecSideCars", typing.Dict[str, typing.Any]]] = None,
        sub_path: typing.Optional[builtins.str] = None,
        users: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecUsers", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param pools: 
        :param buckets: 
        :param cert_config: 
        :param configuration: 
        :param creds_secret: 
        :param env: 
        :param expose_services: 
        :param external_ca_cert_secret: 
        :param external_cert_secret: 
        :param external_client_cert_secret: 
        :param features: 
        :param image: 
        :param image_pull_policy: 
        :param image_pull_secret: 
        :param kes: 
        :param liveness: 
        :param log: 
        :param logging: 
        :param mount_path: 
        :param pod_management_policy: 
        :param priority_class_name: 
        :param prometheus: 
        :param prometheus_operator: 
        :param readiness: 
        :param request_auto_cert: 
        :param s3: 
        :param service_account_name: 
        :param service_metadata: 
        :param side_cars: 
        :param sub_path: 
        :param users: 

        :stability: experimental
        :schema: TenantV2Spec
        '''
        if isinstance(cert_config, dict):
            cert_config = TenantV2SpecCertConfig(**cert_config)
        if isinstance(configuration, dict):
            configuration = TenantV2SpecConfiguration(**configuration)
        if isinstance(creds_secret, dict):
            creds_secret = TenantV2SpecCredsSecret(**creds_secret)
        if isinstance(expose_services, dict):
            expose_services = TenantV2SpecExposeServices(**expose_services)
        if isinstance(external_client_cert_secret, dict):
            external_client_cert_secret = TenantV2SpecExternalClientCertSecret(**external_client_cert_secret)
        if isinstance(features, dict):
            features = TenantV2SpecFeatures(**features)
        if isinstance(image_pull_secret, dict):
            image_pull_secret = TenantV2SpecImagePullSecret(**image_pull_secret)
        if isinstance(kes, dict):
            kes = TenantV2SpecKes(**kes)
        if isinstance(liveness, dict):
            liveness = TenantV2SpecLiveness(**liveness)
        if isinstance(log, dict):
            log = TenantV2SpecLog(**log)
        if isinstance(logging, dict):
            logging = TenantV2SpecLogging(**logging)
        if isinstance(prometheus, dict):
            prometheus = TenantV2SpecPrometheus(**prometheus)
        if isinstance(readiness, dict):
            readiness = TenantV2SpecReadiness(**readiness)
        if isinstance(s3, dict):
            s3 = TenantV2SpecS3(**s3)
        if isinstance(service_metadata, dict):
            service_metadata = TenantV2SpecServiceMetadata(**service_metadata)
        if isinstance(side_cars, dict):
            side_cars = TenantV2SpecSideCars(**side_cars)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2Spec.__init__)
            check_type(argname="argument pools", value=pools, expected_type=type_hints["pools"])
            check_type(argname="argument buckets", value=buckets, expected_type=type_hints["buckets"])
            check_type(argname="argument cert_config", value=cert_config, expected_type=type_hints["cert_config"])
            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
            check_type(argname="argument creds_secret", value=creds_secret, expected_type=type_hints["creds_secret"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument expose_services", value=expose_services, expected_type=type_hints["expose_services"])
            check_type(argname="argument external_ca_cert_secret", value=external_ca_cert_secret, expected_type=type_hints["external_ca_cert_secret"])
            check_type(argname="argument external_cert_secret", value=external_cert_secret, expected_type=type_hints["external_cert_secret"])
            check_type(argname="argument external_client_cert_secret", value=external_client_cert_secret, expected_type=type_hints["external_client_cert_secret"])
            check_type(argname="argument features", value=features, expected_type=type_hints["features"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument image_pull_secret", value=image_pull_secret, expected_type=type_hints["image_pull_secret"])
            check_type(argname="argument kes", value=kes, expected_type=type_hints["kes"])
            check_type(argname="argument liveness", value=liveness, expected_type=type_hints["liveness"])
            check_type(argname="argument log", value=log, expected_type=type_hints["log"])
            check_type(argname="argument logging", value=logging, expected_type=type_hints["logging"])
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument pod_management_policy", value=pod_management_policy, expected_type=type_hints["pod_management_policy"])
            check_type(argname="argument priority_class_name", value=priority_class_name, expected_type=type_hints["priority_class_name"])
            check_type(argname="argument prometheus", value=prometheus, expected_type=type_hints["prometheus"])
            check_type(argname="argument prometheus_operator", value=prometheus_operator, expected_type=type_hints["prometheus_operator"])
            check_type(argname="argument readiness", value=readiness, expected_type=type_hints["readiness"])
            check_type(argname="argument request_auto_cert", value=request_auto_cert, expected_type=type_hints["request_auto_cert"])
            check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument service_metadata", value=service_metadata, expected_type=type_hints["service_metadata"])
            check_type(argname="argument side_cars", value=side_cars, expected_type=type_hints["side_cars"])
            check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            check_type(argname="argument users", value=users, expected_type=type_hints["users"])
        self._values: typing.Dict[str, typing.Any] = {
            "pools": pools,
        }
        if buckets is not None:
            self._values["buckets"] = buckets
        if cert_config is not None:
            self._values["cert_config"] = cert_config
        if configuration is not None:
            self._values["configuration"] = configuration
        if creds_secret is not None:
            self._values["creds_secret"] = creds_secret
        if env is not None:
            self._values["env"] = env
        if expose_services is not None:
            self._values["expose_services"] = expose_services
        if external_ca_cert_secret is not None:
            self._values["external_ca_cert_secret"] = external_ca_cert_secret
        if external_cert_secret is not None:
            self._values["external_cert_secret"] = external_cert_secret
        if external_client_cert_secret is not None:
            self._values["external_client_cert_secret"] = external_client_cert_secret
        if features is not None:
            self._values["features"] = features
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if image_pull_secret is not None:
            self._values["image_pull_secret"] = image_pull_secret
        if kes is not None:
            self._values["kes"] = kes
        if liveness is not None:
            self._values["liveness"] = liveness
        if log is not None:
            self._values["log"] = log
        if logging is not None:
            self._values["logging"] = logging
        if mount_path is not None:
            self._values["mount_path"] = mount_path
        if pod_management_policy is not None:
            self._values["pod_management_policy"] = pod_management_policy
        if priority_class_name is not None:
            self._values["priority_class_name"] = priority_class_name
        if prometheus is not None:
            self._values["prometheus"] = prometheus
        if prometheus_operator is not None:
            self._values["prometheus_operator"] = prometheus_operator
        if readiness is not None:
            self._values["readiness"] = readiness
        if request_auto_cert is not None:
            self._values["request_auto_cert"] = request_auto_cert
        if s3 is not None:
            self._values["s3"] = s3
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if service_metadata is not None:
            self._values["service_metadata"] = service_metadata
        if side_cars is not None:
            self._values["side_cars"] = side_cars
        if sub_path is not None:
            self._values["sub_path"] = sub_path
        if users is not None:
            self._values["users"] = users

    @builtins.property
    def pools(self) -> typing.List["TenantV2SpecPools"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#pools
        '''
        result = self._values.get("pools")
        assert result is not None, "Required property 'pools' is missing"
        return typing.cast(typing.List["TenantV2SpecPools"], result)

    @builtins.property
    def buckets(self) -> typing.Optional[typing.List["TenantV2SpecBuckets"]]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#buckets
        '''
        result = self._values.get("buckets")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecBuckets"]], result)

    @builtins.property
    def cert_config(self) -> typing.Optional["TenantV2SpecCertConfig"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#certConfig
        '''
        result = self._values.get("cert_config")
        return typing.cast(typing.Optional["TenantV2SpecCertConfig"], result)

    @builtins.property
    def configuration(self) -> typing.Optional["TenantV2SpecConfiguration"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#configuration
        '''
        result = self._values.get("configuration")
        return typing.cast(typing.Optional["TenantV2SpecConfiguration"], result)

    @builtins.property
    def creds_secret(self) -> typing.Optional["TenantV2SpecCredsSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#credsSecret
        '''
        result = self._values.get("creds_secret")
        return typing.cast(typing.Optional["TenantV2SpecCredsSecret"], result)

    @builtins.property
    def env(self) -> typing.Optional[typing.List["TenantV2SpecEnv"]]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#env
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecEnv"]], result)

    @builtins.property
    def expose_services(self) -> typing.Optional["TenantV2SpecExposeServices"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#exposeServices
        '''
        result = self._values.get("expose_services")
        return typing.cast(typing.Optional["TenantV2SpecExposeServices"], result)

    @builtins.property
    def external_ca_cert_secret(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecExternalCaCertSecret"]]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#externalCaCertSecret
        '''
        result = self._values.get("external_ca_cert_secret")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecExternalCaCertSecret"]], result)

    @builtins.property
    def external_cert_secret(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecExternalCertSecret"]]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#externalCertSecret
        '''
        result = self._values.get("external_cert_secret")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecExternalCertSecret"]], result)

    @builtins.property
    def external_client_cert_secret(
        self,
    ) -> typing.Optional["TenantV2SpecExternalClientCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#externalClientCertSecret
        '''
        result = self._values.get("external_client_cert_secret")
        return typing.cast(typing.Optional["TenantV2SpecExternalClientCertSecret"], result)

    @builtins.property
    def features(self) -> typing.Optional["TenantV2SpecFeatures"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#features
        '''
        result = self._values.get("features")
        return typing.cast(typing.Optional["TenantV2SpecFeatures"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_secret(self) -> typing.Optional["TenantV2SpecImagePullSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#imagePullSecret
        '''
        result = self._values.get("image_pull_secret")
        return typing.cast(typing.Optional["TenantV2SpecImagePullSecret"], result)

    @builtins.property
    def kes(self) -> typing.Optional["TenantV2SpecKes"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#kes
        '''
        result = self._values.get("kes")
        return typing.cast(typing.Optional["TenantV2SpecKes"], result)

    @builtins.property
    def liveness(self) -> typing.Optional["TenantV2SpecLiveness"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#liveness
        '''
        result = self._values.get("liveness")
        return typing.cast(typing.Optional["TenantV2SpecLiveness"], result)

    @builtins.property
    def log(self) -> typing.Optional["TenantV2SpecLog"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#log
        '''
        result = self._values.get("log")
        return typing.cast(typing.Optional["TenantV2SpecLog"], result)

    @builtins.property
    def logging(self) -> typing.Optional["TenantV2SpecLogging"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#logging
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional["TenantV2SpecLogging"], result)

    @builtins.property
    def mount_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#mountPath
        '''
        result = self._values.get("mount_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pod_management_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#podManagementPolicy
        '''
        result = self._values.get("pod_management_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def priority_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#priorityClassName
        '''
        result = self._values.get("priority_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prometheus(self) -> typing.Optional["TenantV2SpecPrometheus"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#prometheus
        '''
        result = self._values.get("prometheus")
        return typing.cast(typing.Optional["TenantV2SpecPrometheus"], result)

    @builtins.property
    def prometheus_operator(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#prometheusOperator
        '''
        result = self._values.get("prometheus_operator")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def readiness(self) -> typing.Optional["TenantV2SpecReadiness"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#readiness
        '''
        result = self._values.get("readiness")
        return typing.cast(typing.Optional["TenantV2SpecReadiness"], result)

    @builtins.property
    def request_auto_cert(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#requestAutoCert
        '''
        result = self._values.get("request_auto_cert")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def s3(self) -> typing.Optional["TenantV2SpecS3"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#s3
        '''
        result = self._values.get("s3")
        return typing.cast(typing.Optional["TenantV2SpecS3"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_metadata(self) -> typing.Optional["TenantV2SpecServiceMetadata"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#serviceMetadata
        '''
        result = self._values.get("service_metadata")
        return typing.cast(typing.Optional["TenantV2SpecServiceMetadata"], result)

    @builtins.property
    def side_cars(self) -> typing.Optional["TenantV2SpecSideCars"]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#sideCars
        '''
        result = self._values.get("side_cars")
        return typing.cast(typing.Optional["TenantV2SpecSideCars"], result)

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#subPath
        '''
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def users(self) -> typing.Optional[typing.List["TenantV2SpecUsers"]]:
        '''
        :stability: experimental
        :schema: TenantV2Spec#users
        '''
        result = self._values.get("users")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecUsers"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecBuckets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "object_lock": "objectLock", "region": "region"},
)
class TenantV2SpecBuckets:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        object_lock: typing.Optional[builtins.bool] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param object_lock: 
        :param region: 

        :stability: experimental
        :schema: TenantV2SpecBuckets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecBuckets.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument object_lock", value=object_lock, expected_type=type_hints["object_lock"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if object_lock is not None:
            self._values["object_lock"] = object_lock
        if region is not None:
            self._values["region"] = region

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecBuckets#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def object_lock(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecBuckets#objectLock
        '''
        result = self._values.get("object_lock")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecBuckets#region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecBuckets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecCertConfig",
    jsii_struct_bases=[],
    name_mapping={
        "common_name": "commonName",
        "dns_names": "dnsNames",
        "organization_name": "organizationName",
    },
)
class TenantV2SpecCertConfig:
    def __init__(
        self,
        *,
        common_name: typing.Optional[builtins.str] = None,
        dns_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        organization_name: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param common_name: 
        :param dns_names: 
        :param organization_name: 

        :stability: experimental
        :schema: TenantV2SpecCertConfig
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecCertConfig.__init__)
            check_type(argname="argument common_name", value=common_name, expected_type=type_hints["common_name"])
            check_type(argname="argument dns_names", value=dns_names, expected_type=type_hints["dns_names"])
            check_type(argname="argument organization_name", value=organization_name, expected_type=type_hints["organization_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if common_name is not None:
            self._values["common_name"] = common_name
        if dns_names is not None:
            self._values["dns_names"] = dns_names
        if organization_name is not None:
            self._values["organization_name"] = organization_name

    @builtins.property
    def common_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecCertConfig#commonName
        '''
        result = self._values.get("common_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecCertConfig#dnsNames
        '''
        result = self._values.get("dns_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def organization_name(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecCertConfig#organizationName
        '''
        result = self._values.get("organization_name")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecCertConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecConfiguration",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecConfiguration:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecConfiguration
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecConfiguration.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecConfiguration#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecCredsSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecCredsSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecCredsSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecCredsSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecCredsSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecCredsSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class TenantV2SpecEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[typing.Union["TenantV2SpecEnvValueFrom", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param value: 
        :param value_from: 

        :stability: experimental
        :schema: TenantV2SpecEnv
        '''
        if isinstance(value_from, dict):
            value_from = TenantV2SpecEnvValueFrom(**value_from)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnv.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_from", value=value_from, expected_type=type_hints["value_from"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnv#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnv#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(self) -> typing.Optional["TenantV2SpecEnvValueFrom"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnv#valueFrom
        '''
        result = self._values.get("value_from")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFrom"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class TenantV2SpecEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[typing.Union["TenantV2SpecEnvValueFromConfigMapKeyRef", typing.Dict[str, typing.Any]]] = None,
        field_ref: typing.Optional[typing.Union["TenantV2SpecEnvValueFromFieldRef", typing.Dict[str, typing.Any]]] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantV2SpecEnvValueFromResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
        secret_key_ref: typing.Optional[typing.Union["TenantV2SpecEnvValueFromSecretKeyRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_key_ref: 
        :param field_ref: 
        :param resource_field_ref: 
        :param secret_key_ref: 

        :stability: experimental
        :schema: TenantV2SpecEnvValueFrom
        '''
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = TenantV2SpecEnvValueFromConfigMapKeyRef(**config_map_key_ref)
        if isinstance(field_ref, dict):
            field_ref = TenantV2SpecEnvValueFromFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantV2SpecEnvValueFromResourceFieldRef(**resource_field_ref)
        if isinstance(secret_key_ref, dict):
            secret_key_ref = TenantV2SpecEnvValueFromSecretKeyRef(**secret_key_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFrom.__init__)
            check_type(argname="argument config_map_key_ref", value=config_map_key_ref, expected_type=type_hints["config_map_key_ref"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
            check_type(argname="argument secret_key_ref", value=secret_key_ref, expected_type=type_hints["secret_key_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional["TenantV2SpecEnvValueFromConfigMapKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFrom#configMapKeyRef
        '''
        result = self._values.get("config_map_key_ref")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFromConfigMapKeyRef"], result)

    @builtins.property
    def field_ref(self) -> typing.Optional["TenantV2SpecEnvValueFromFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFrom#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFromFieldRef"], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecEnvValueFromResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFrom#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFromResourceFieldRef"], result)

    @builtins.property
    def secret_key_ref(self) -> typing.Optional["TenantV2SpecEnvValueFromSecretKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFrom#secretKeyRef
        '''
        result = self._values.get("secret_key_ref")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFromSecretKeyRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantV2SpecEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecEnvValueFromConfigMapKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromConfigMapKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromConfigMapKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromConfigMapKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromConfigMapKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnvValueFromConfigMapKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantV2SpecEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantV2SpecEnvValueFromFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnvValueFromFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantV2SpecEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantV2SpecEnvValueFromResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantV2SpecEnvValueFromResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantV2SpecEnvValueFromResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantV2SpecEnvValueFromResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnvValueFromResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecEnvValueFromResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFromResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecEnvValueFromResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantV2SpecEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecEnvValueFromSecretKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecEnvValueFromSecretKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromSecretKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromSecretKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecEnvValueFromSecretKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecEnvValueFromSecretKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecExposeServices",
    jsii_struct_bases=[],
    name_mapping={"console": "console", "minio": "minio"},
)
class TenantV2SpecExposeServices:
    def __init__(
        self,
        *,
        console: typing.Optional[builtins.bool] = None,
        minio: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param console: 
        :param minio: 

        :stability: experimental
        :schema: TenantV2SpecExposeServices
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecExposeServices.__init__)
            check_type(argname="argument console", value=console, expected_type=type_hints["console"])
            check_type(argname="argument minio", value=minio, expected_type=type_hints["minio"])
        self._values: typing.Dict[str, typing.Any] = {}
        if console is not None:
            self._values["console"] = console
        if minio is not None:
            self._values["minio"] = minio

    @builtins.property
    def console(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecExposeServices#console
        '''
        result = self._values.get("console")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def minio(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecExposeServices#minio
        '''
        result = self._values.get("minio")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecExposeServices(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecExternalCaCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantV2SpecExternalCaCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecExternalCaCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecExternalCaCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalCaCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalCaCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecExternalCaCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecExternalCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantV2SpecExternalCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecExternalCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecExternalCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecExternalCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecExternalClientCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantV2SpecExternalClientCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecExternalClientCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecExternalClientCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalClientCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecExternalClientCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecExternalClientCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecFeatures",
    jsii_struct_bases=[],
    name_mapping={"bucket_dns": "bucketDns", "domains": "domains"},
)
class TenantV2SpecFeatures:
    def __init__(
        self,
        *,
        bucket_dns: typing.Optional[builtins.bool] = None,
        domains: typing.Optional[typing.Union["TenantV2SpecFeaturesDomains", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param bucket_dns: 
        :param domains: 

        :stability: experimental
        :schema: TenantV2SpecFeatures
        '''
        if isinstance(domains, dict):
            domains = TenantV2SpecFeaturesDomains(**domains)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecFeatures.__init__)
            check_type(argname="argument bucket_dns", value=bucket_dns, expected_type=type_hints["bucket_dns"])
            check_type(argname="argument domains", value=domains, expected_type=type_hints["domains"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bucket_dns is not None:
            self._values["bucket_dns"] = bucket_dns
        if domains is not None:
            self._values["domains"] = domains

    @builtins.property
    def bucket_dns(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecFeatures#bucketDNS
        '''
        result = self._values.get("bucket_dns")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def domains(self) -> typing.Optional["TenantV2SpecFeaturesDomains"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecFeatures#domains
        '''
        result = self._values.get("domains")
        return typing.cast(typing.Optional["TenantV2SpecFeaturesDomains"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecFeatures(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecFeaturesDomains",
    jsii_struct_bases=[],
    name_mapping={"console": "console", "minio": "minio"},
)
class TenantV2SpecFeaturesDomains:
    def __init__(
        self,
        *,
        console: typing.Optional[builtins.str] = None,
        minio: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param console: 
        :param minio: 

        :stability: experimental
        :schema: TenantV2SpecFeaturesDomains
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecFeaturesDomains.__init__)
            check_type(argname="argument console", value=console, expected_type=type_hints["console"])
            check_type(argname="argument minio", value=minio, expected_type=type_hints["minio"])
        self._values: typing.Dict[str, typing.Any] = {}
        if console is not None:
            self._values["console"] = console
        if minio is not None:
            self._values["minio"] = minio

    @builtins.property
    def console(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecFeaturesDomains#console
        '''
        result = self._values.get("console")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def minio(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecFeaturesDomains#minio
        '''
        result = self._values.get("minio")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecFeaturesDomains(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecImagePullSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecImagePullSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecImagePullSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecImagePullSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecImagePullSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecImagePullSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKes",
    jsii_struct_bases=[],
    name_mapping={
        "kes_secret": "kesSecret",
        "affinity": "affinity",
        "annotations": "annotations",
        "client_cert_secret": "clientCertSecret",
        "external_cert_secret": "externalCertSecret",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "key_name": "keyName",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "replicas": "replicas",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantV2SpecKes:
    def __init__(
        self,
        *,
        kes_secret: typing.Union["TenantV2SpecKesKesSecret", typing.Dict[str, typing.Any]],
        affinity: typing.Optional[typing.Union["TenantV2SpecKesAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        client_cert_secret: typing.Optional[typing.Union["TenantV2SpecKesClientCertSecret", typing.Dict[str, typing.Any]]] = None,
        external_cert_secret: typing.Optional[typing.Union["TenantV2SpecKesExternalCertSecret", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        replicas: typing.Optional[jsii.Number] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecKesResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecKesSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param kes_secret: 
        :param affinity: 
        :param annotations: 
        :param client_cert_secret: 
        :param external_cert_secret: 
        :param image: 
        :param image_pull_policy: 
        :param key_name: 
        :param labels: 
        :param node_selector: 
        :param replicas: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantV2SpecKes
        '''
        if isinstance(kes_secret, dict):
            kes_secret = TenantV2SpecKesKesSecret(**kes_secret)
        if isinstance(affinity, dict):
            affinity = TenantV2SpecKesAffinity(**affinity)
        if isinstance(client_cert_secret, dict):
            client_cert_secret = TenantV2SpecKesClientCertSecret(**client_cert_secret)
        if isinstance(external_cert_secret, dict):
            external_cert_secret = TenantV2SpecKesExternalCertSecret(**external_cert_secret)
        if isinstance(resources, dict):
            resources = TenantV2SpecKesResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecKesSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKes.__init__)
            check_type(argname="argument kes_secret", value=kes_secret, expected_type=type_hints["kes_secret"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument client_cert_secret", value=client_cert_secret, expected_type=type_hints["client_cert_secret"])
            check_type(argname="argument external_cert_secret", value=external_cert_secret, expected_type=type_hints["external_cert_secret"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument replicas", value=replicas, expected_type=type_hints["replicas"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "kes_secret": kes_secret,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if client_cert_secret is not None:
            self._values["client_cert_secret"] = client_cert_secret
        if external_cert_secret is not None:
            self._values["external_cert_secret"] = external_cert_secret
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if key_name is not None:
            self._values["key_name"] = key_name
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if replicas is not None:
            self._values["replicas"] = replicas
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def kes_secret(self) -> "TenantV2SpecKesKesSecret":
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#kesSecret
        '''
        result = self._values.get("kes_secret")
        assert result is not None, "Required property 'kes_secret' is missing"
        return typing.cast("TenantV2SpecKesKesSecret", result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantV2SpecKesAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def client_cert_secret(self) -> typing.Optional["TenantV2SpecKesClientCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#clientCertSecret
        '''
        result = self._values.get("client_cert_secret")
        return typing.cast(typing.Optional["TenantV2SpecKesClientCertSecret"], result)

    @builtins.property
    def external_cert_secret(
        self,
    ) -> typing.Optional["TenantV2SpecKesExternalCertSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#externalCertSecret
        '''
        result = self._values.get("external_cert_secret")
        return typing.cast(typing.Optional["TenantV2SpecKesExternalCertSecret"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#keyName
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def replicas(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#replicas
        '''
        result = self._values.get("replicas")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecKesResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecKesResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantV2SpecKesSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecKesSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantV2SpecKesTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKes#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantV2SpecKesAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantV2SpecKesAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantV2SpecKesAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantV2SpecKesAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantV2SpecKesAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantV2SpecKesAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantV2SpecKesAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecKesAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecKesAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecKesAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesClientCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantV2SpecKesClientCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecKesClientCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesClientCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesClientCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesClientCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesClientCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesExternalCertSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "type": "type"},
)
class TenantV2SpecKesExternalCertSecret:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecKesExternalCertSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesExternalCertSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesExternalCertSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesExternalCertSecret#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesExternalCertSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesKesSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecKesKesSecret:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecKesKesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesKesSecret.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesKesSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesKesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecKesResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecKesResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecKesResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecKesResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecKesResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecKesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecKesResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecKesResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecKesResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecKesResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecKesResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecKesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecKesResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecKesResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecKesResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecKesSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecKesSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecKesSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecKesSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecKesSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecKesSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecKesSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecKesSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecKesSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecKesSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecKesSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecKesSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecKesSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecKesSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecKesSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecKesSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecKesSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantV2SpecKesTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecKesTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantV2SpecKesTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecKesTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecKesTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecKesTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecKesTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecKesTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLiveness",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantV2SpecLiveness:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecLivenessExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecLivenessHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecLivenessTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantV2SpecLiveness
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecLivenessExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecLivenessHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecLivenessTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLiveness.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantV2SpecLivenessExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecLivenessExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(self) -> typing.Optional["TenantV2SpecLivenessHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecLivenessHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(self) -> typing.Optional["TenantV2SpecLivenessTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecLivenessTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLiveness#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLiveness(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecLivenessExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecLivenessExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLivenessExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecLivenessHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecLivenessHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLivenessHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecLivenessHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecLivenessHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLivenessHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLivenessHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLivenessHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecLivenessHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLivenessHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLivenessHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLivenessHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLivenessHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLivenessHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLivenessHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLivenessHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecLivenessTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecLivenessTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecLivenessTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecLivenessTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecLivenessTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLivenessTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLivenessTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLivenessTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLivenessTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLivenessTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLivenessTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLivenessTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLivenessTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLivenessTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLivenessTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLog",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "annotations": "annotations",
        "audit": "audit",
        "db": "db",
        "image": "image",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantV2SpecLog:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["TenantV2SpecLogAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        audit: typing.Optional[typing.Union["TenantV2SpecLogAudit", typing.Dict[str, typing.Any]]] = None,
        db: typing.Optional[typing.Union["TenantV2SpecLogDb", typing.Dict[str, typing.Any]]] = None,
        image: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecLogResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecLogSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param affinity: 
        :param annotations: 
        :param audit: 
        :param db: 
        :param image: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantV2SpecLog
        '''
        if isinstance(affinity, dict):
            affinity = TenantV2SpecLogAffinity(**affinity)
        if isinstance(audit, dict):
            audit = TenantV2SpecLogAudit(**audit)
        if isinstance(db, dict):
            db = TenantV2SpecLogDb(**db)
        if isinstance(resources, dict):
            resources = TenantV2SpecLogResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecLogSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLog.__init__)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument audit", value=audit, expected_type=type_hints["audit"])
            check_type(argname="argument db", value=db, expected_type=type_hints["db"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if audit is not None:
            self._values["audit"] = audit
        if db is not None:
            self._values["db"] = db
        if image is not None:
            self._values["image"] = image
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def affinity(self) -> typing.Optional["TenantV2SpecLogAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def audit(self) -> typing.Optional["TenantV2SpecLogAudit"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#audit
        '''
        result = self._values.get("audit")
        return typing.cast(typing.Optional["TenantV2SpecLogAudit"], result)

    @builtins.property
    def db(self) -> typing.Optional["TenantV2SpecLogDb"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#db
        '''
        result = self._values.get("db")
        return typing.cast(typing.Optional["TenantV2SpecLogDb"], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecLogResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecLogResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantV2SpecLogSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecLogSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(self) -> typing.Optional[typing.List["TenantV2SpecLogTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLog#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLog(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantV2SpecLogAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantV2SpecLogAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantV2SpecLogAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantV2SpecLogAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantV2SpecLogAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantV2SpecLogAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantV2SpecLogAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogAudit",
    jsii_struct_bases=[],
    name_mapping={"disk_capacity_gb": "diskCapacityGb"},
)
class TenantV2SpecLogAudit:
    def __init__(
        self,
        *,
        disk_capacity_gb: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param disk_capacity_gb: 

        :stability: experimental
        :schema: TenantV2SpecLogAudit
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogAudit.__init__)
            check_type(argname="argument disk_capacity_gb", value=disk_capacity_gb, expected_type=type_hints["disk_capacity_gb"])
        self._values: typing.Dict[str, typing.Any] = {}
        if disk_capacity_gb is not None:
            self._values["disk_capacity_gb"] = disk_capacity_gb

    @builtins.property
    def disk_capacity_gb(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogAudit#diskCapacityGB
        '''
        result = self._values.get("disk_capacity_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogAudit(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDb",
    jsii_struct_bases=[],
    name_mapping={
        "volume_claim_template": "volumeClaimTemplate",
        "affinity": "affinity",
        "annotations": "annotations",
        "image": "image",
        "initimage": "initimage",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantV2SpecLogDb:
    def __init__(
        self,
        *,
        volume_claim_template: typing.Union["TenantV2SpecLogDbVolumeClaimTemplate", typing.Dict[str, typing.Any]],
        affinity: typing.Optional[typing.Union["TenantV2SpecLogDbAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        image: typing.Optional[builtins.str] = None,
        initimage: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecLogDbResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecLogDbSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param volume_claim_template: 
        :param affinity: 
        :param annotations: 
        :param image: 
        :param initimage: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantV2SpecLogDb
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantV2SpecLogDbVolumeClaimTemplate(**volume_claim_template)
        if isinstance(affinity, dict):
            affinity = TenantV2SpecLogDbAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantV2SpecLogDbResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecLogDbSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDb.__init__)
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument initimage", value=initimage, expected_type=type_hints["initimage"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_claim_template": volume_claim_template,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if image is not None:
            self._values["image"] = image
        if initimage is not None:
            self._values["initimage"] = initimage
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def volume_claim_template(self) -> "TenantV2SpecLogDbVolumeClaimTemplate":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        assert result is not None, "Required property 'volume_claim_template' is missing"
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplate", result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantV2SpecLogDbAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#initimage
        '''
        result = self._values.get("initimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecLogDbResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecLogDbResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantV2SpecLogDbSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecLogDbSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDb#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDb(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantV2SpecLogDbAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantV2SpecLogDbAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantV2SpecLogDbAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantV2SpecLogDbAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantV2SpecLogDbAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantV2SpecLogDbAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogDbAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogDbAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecLogDbAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecLogDbResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecLogDbResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLogDbResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogDbResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLogDbResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLogDbResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecLogDbResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogDbResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLogDbResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLogDbResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecLogDbSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecLogDbSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecLogDbSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecLogDbSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecLogDbSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecLogDbSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecLogDbSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecLogDbSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecLogDbSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecLogDbSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecLogDbSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecLogDbSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecLogDbSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecLogDbSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantV2SpecLogDbTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantV2SpecLogDbTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplate:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate
        '''
        if isinstance(metadata, dict):
            metadata = TenantV2SpecLogDbVolumeClaimTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantV2SpecLogDbVolumeClaimTemplateSpec(**spec)
        if isinstance(status, dict):
            status = TenantV2SpecLogDbVolumeClaimTemplateStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplate.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpec"], result)

    @builtins.property
    def status(self) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateStatus"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplate#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantV2SpecLogDbVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantV2SpecLogDbVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantV2SpecLogDbVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecLogDbVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplateStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogDbVolumeClaimTemplateStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogDbVolumeClaimTemplateStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogDbVolumeClaimTemplateStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogDbVolumeClaimTemplateStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantV2SpecLogDbVolumeClaimTemplateStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogDbVolumeClaimTemplateStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogDbVolumeClaimTemplateStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogDbVolumeClaimTemplateStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecLogResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecLogResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecLogResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecLogResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLogResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLogResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecLogResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecLogResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecLogResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecLogResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecLogResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecLogSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecLogSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecLogSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecLogSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecLogSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecLogSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecLogSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecLogSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecLogSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecLogSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecLogSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecLogSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecLogSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecLogSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecLogSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecLogSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecLogSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantV2SpecLogTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecLogTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantV2SpecLogTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecLogTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecLogTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecLogTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecLogTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecLogTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecLogging",
    jsii_struct_bases=[],
    name_mapping={"anonymous": "anonymous", "json": "json", "quiet": "quiet"},
)
class TenantV2SpecLogging:
    def __init__(
        self,
        *,
        anonymous: typing.Optional[builtins.bool] = None,
        json: typing.Optional[builtins.bool] = None,
        quiet: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param anonymous: 
        :param json: 
        :param quiet: 

        :stability: experimental
        :schema: TenantV2SpecLogging
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecLogging.__init__)
            check_type(argname="argument anonymous", value=anonymous, expected_type=type_hints["anonymous"])
            check_type(argname="argument json", value=json, expected_type=type_hints["json"])
            check_type(argname="argument quiet", value=quiet, expected_type=type_hints["quiet"])
        self._values: typing.Dict[str, typing.Any] = {}
        if anonymous is not None:
            self._values["anonymous"] = anonymous
        if json is not None:
            self._values["json"] = json
        if quiet is not None:
            self._values["quiet"] = quiet

    @builtins.property
    def anonymous(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogging#anonymous
        '''
        result = self._values.get("anonymous")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def json(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogging#json
        '''
        result = self._values.get("json")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def quiet(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecLogging#quiet
        '''
        result = self._values.get("quiet")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecLogging(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPools",
    jsii_struct_bases=[],
    name_mapping={
        "servers": "servers",
        "volume_claim_template": "volumeClaimTemplate",
        "volumes_per_server": "volumesPerServer",
        "affinity": "affinity",
        "annotations": "annotations",
        "labels": "labels",
        "name": "name",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "tolerations": "tolerations",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantV2SpecPools:
    def __init__(
        self,
        *,
        servers: jsii.Number,
        volume_claim_template: typing.Union["TenantV2SpecPoolsVolumeClaimTemplate", typing.Dict[str, typing.Any]],
        volumes_per_server: jsii.Number,
        affinity: typing.Optional[typing.Union["TenantV2SpecPoolsAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecPoolsResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecPoolsSecurityContext", typing.Dict[str, typing.Any]]] = None,
        tolerations: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsTolerations", typing.Dict[str, typing.Any]]]] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param servers: 
        :param volume_claim_template: 
        :param volumes_per_server: 
        :param affinity: 
        :param annotations: 
        :param labels: 
        :param name: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param tolerations: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantV2SpecPools
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantV2SpecPoolsVolumeClaimTemplate(**volume_claim_template)
        if isinstance(affinity, dict):
            affinity = TenantV2SpecPoolsAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantV2SpecPoolsResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecPoolsSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPools.__init__)
            check_type(argname="argument servers", value=servers, expected_type=type_hints["servers"])
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
            check_type(argname="argument volumes_per_server", value=volumes_per_server, expected_type=type_hints["volumes_per_server"])
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument tolerations", value=tolerations, expected_type=type_hints["tolerations"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {
            "servers": servers,
            "volume_claim_template": volume_claim_template,
            "volumes_per_server": volumes_per_server,
        }
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if tolerations is not None:
            self._values["tolerations"] = tolerations
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def servers(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#servers
        '''
        result = self._values.get("servers")
        assert result is not None, "Required property 'servers' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def volume_claim_template(self) -> "TenantV2SpecPoolsVolumeClaimTemplate":
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        assert result is not None, "Required property 'volume_claim_template' is missing"
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplate", result)

    @builtins.property
    def volumes_per_server(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#volumesPerServer
        '''
        result = self._values.get("volumes_per_server")
        assert result is not None, "Required property 'volumes_per_server' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def affinity(self) -> typing.Optional["TenantV2SpecPoolsAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecPoolsResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecPoolsResources"], result)

    @builtins.property
    def security_context(self) -> typing.Optional["TenantV2SpecPoolsSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecPoolsSecurityContext"], result)

    @builtins.property
    def tolerations(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsTolerations"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#tolerations
        '''
        result = self._values.get("tolerations")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsTolerations"]], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPools#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPools(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantV2SpecPoolsAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantV2SpecPoolsAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantV2SpecPoolsAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantV2SpecPoolsAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(self) -> typing.Optional["TenantV2SpecPoolsAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(self) -> typing.Optional["TenantV2SpecPoolsAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPoolsAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPoolsAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPoolsAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecPoolsResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecPoolsResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecPoolsResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPoolsResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecPoolsResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecPoolsResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecPoolsResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPoolsResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecPoolsResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecPoolsResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecPoolsSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecPoolsSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecPoolsSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecPoolsSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecPoolsSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecPoolsSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecPoolsSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecPoolsSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecPoolsSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecPoolsSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecPoolsSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecPoolsSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecPoolsSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecPoolsSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsTolerations",
    jsii_struct_bases=[],
    name_mapping={
        "effect": "effect",
        "key": "key",
        "operator": "operator",
        "toleration_seconds": "tolerationSeconds",
        "value": "value",
    },
)
class TenantV2SpecPoolsTolerations:
    def __init__(
        self,
        *,
        effect: typing.Optional[builtins.str] = None,
        key: typing.Optional[builtins.str] = None,
        operator: typing.Optional[builtins.str] = None,
        toleration_seconds: typing.Optional[jsii.Number] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param effect: 
        :param key: 
        :param operator: 
        :param toleration_seconds: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsTolerations.__init__)
            check_type(argname="argument effect", value=effect, expected_type=type_hints["effect"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument toleration_seconds", value=toleration_seconds, expected_type=type_hints["toleration_seconds"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {}
        if effect is not None:
            self._values["effect"] = effect
        if key is not None:
            self._values["key"] = key
        if operator is not None:
            self._values["operator"] = operator
        if toleration_seconds is not None:
            self._values["toleration_seconds"] = toleration_seconds
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def effect(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations#effect
        '''
        result = self._values.get("effect")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations#operator
        '''
        result = self._values.get("operator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def toleration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations#tolerationSeconds
        '''
        result = self._values.get("toleration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTolerations#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsTolerations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantV2SpecPoolsTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplate:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate
        '''
        if isinstance(metadata, dict):
            metadata = TenantV2SpecPoolsVolumeClaimTemplateMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantV2SpecPoolsVolumeClaimTemplateSpec(**spec)
        if isinstance(status, dict):
            status = TenantV2SpecPoolsVolumeClaimTemplateStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplate.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpec"], result)

    @builtins.property
    def status(self) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateStatus"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplate#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantV2SpecPoolsVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantV2SpecPoolsVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantV2SpecPoolsVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecPoolsVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplateStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPoolsVolumeClaimTemplateStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPoolsVolumeClaimTemplateStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPoolsVolumeClaimTemplateStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPoolsVolumeClaimTemplateStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantV2SpecPoolsVolumeClaimTemplateStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPoolsVolumeClaimTemplateStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPoolsVolumeClaimTemplateStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPoolsVolumeClaimTemplateStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheus",
    jsii_struct_bases=[],
    name_mapping={
        "affinity": "affinity",
        "annotations": "annotations",
        "disk_capacity_gb": "diskCapacityGb",
        "image": "image",
        "initimage": "initimage",
        "labels": "labels",
        "node_selector": "nodeSelector",
        "resources": "resources",
        "security_context": "securityContext",
        "service_account_name": "serviceAccountName",
        "sidecarimage": "sidecarimage",
        "storage_class_name": "storageClassName",
        "topology_spread_constraints": "topologySpreadConstraints",
    },
)
class TenantV2SpecPrometheus:
    def __init__(
        self,
        *,
        affinity: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinity", typing.Dict[str, typing.Any]]] = None,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        disk_capacity_gb: typing.Optional[jsii.Number] = None,
        image: typing.Optional[builtins.str] = None,
        initimage: typing.Optional[builtins.str] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        node_selector: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecPrometheusResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecPrometheusSecurityContext", typing.Dict[str, typing.Any]]] = None,
        service_account_name: typing.Optional[builtins.str] = None,
        sidecarimage: typing.Optional[builtins.str] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        topology_spread_constraints: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusTopologySpreadConstraints", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param affinity: 
        :param annotations: 
        :param disk_capacity_gb: 
        :param image: 
        :param initimage: 
        :param labels: 
        :param node_selector: 
        :param resources: 
        :param security_context: 
        :param service_account_name: 
        :param sidecarimage: 
        :param storage_class_name: 
        :param topology_spread_constraints: 

        :stability: experimental
        :schema: TenantV2SpecPrometheus
        '''
        if isinstance(affinity, dict):
            affinity = TenantV2SpecPrometheusAffinity(**affinity)
        if isinstance(resources, dict):
            resources = TenantV2SpecPrometheusResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecPrometheusSecurityContext(**security_context)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheus.__init__)
            check_type(argname="argument affinity", value=affinity, expected_type=type_hints["affinity"])
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument disk_capacity_gb", value=disk_capacity_gb, expected_type=type_hints["disk_capacity_gb"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument initimage", value=initimage, expected_type=type_hints["initimage"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument node_selector", value=node_selector, expected_type=type_hints["node_selector"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument service_account_name", value=service_account_name, expected_type=type_hints["service_account_name"])
            check_type(argname="argument sidecarimage", value=sidecarimage, expected_type=type_hints["sidecarimage"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument topology_spread_constraints", value=topology_spread_constraints, expected_type=type_hints["topology_spread_constraints"])
        self._values: typing.Dict[str, typing.Any] = {}
        if affinity is not None:
            self._values["affinity"] = affinity
        if annotations is not None:
            self._values["annotations"] = annotations
        if disk_capacity_gb is not None:
            self._values["disk_capacity_gb"] = disk_capacity_gb
        if image is not None:
            self._values["image"] = image
        if initimage is not None:
            self._values["initimage"] = initimage
        if labels is not None:
            self._values["labels"] = labels
        if node_selector is not None:
            self._values["node_selector"] = node_selector
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if service_account_name is not None:
            self._values["service_account_name"] = service_account_name
        if sidecarimage is not None:
            self._values["sidecarimage"] = sidecarimage
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if topology_spread_constraints is not None:
            self._values["topology_spread_constraints"] = topology_spread_constraints

    @builtins.property
    def affinity(self) -> typing.Optional["TenantV2SpecPrometheusAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinity"], result)

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def disk_capacity_gb(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#diskCapacityGB
        '''
        result = self._values.get("disk_capacity_gb")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#initimage
        '''
        result = self._values.get("initimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def node_selector(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#nodeSelector
        '''
        result = self._values.get("node_selector")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecPrometheusResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusResources"], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusSecurityContext"], result)

    @builtins.property
    def service_account_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#serviceAccountName
        '''
        result = self._values.get("service_account_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sidecarimage(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#sidecarimage
        '''
        result = self._values.get("sidecarimage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topology_spread_constraints(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusTopologySpreadConstraints"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheus#topologySpreadConstraints
        '''
        result = self._values.get("topology_spread_constraints")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusTopologySpreadConstraints"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "node_affinity": "nodeAffinity",
        "pod_affinity": "podAffinity",
        "pod_anti_affinity": "podAntiAffinity",
    },
)
class TenantV2SpecPrometheusAffinity:
    def __init__(
        self,
        *,
        node_affinity: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_affinity: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAffinity", typing.Dict[str, typing.Any]]] = None,
        pod_anti_affinity: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param node_affinity: 
        :param pod_affinity: 
        :param pod_anti_affinity: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinity
        '''
        if isinstance(node_affinity, dict):
            node_affinity = TenantV2SpecPrometheusAffinityNodeAffinity(**node_affinity)
        if isinstance(pod_affinity, dict):
            pod_affinity = TenantV2SpecPrometheusAffinityPodAffinity(**pod_affinity)
        if isinstance(pod_anti_affinity, dict):
            pod_anti_affinity = TenantV2SpecPrometheusAffinityPodAntiAffinity(**pod_anti_affinity)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinity.__init__)
            check_type(argname="argument node_affinity", value=node_affinity, expected_type=type_hints["node_affinity"])
            check_type(argname="argument pod_affinity", value=pod_affinity, expected_type=type_hints["pod_affinity"])
            check_type(argname="argument pod_anti_affinity", value=pod_anti_affinity, expected_type=type_hints["pod_anti_affinity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if node_affinity is not None:
            self._values["node_affinity"] = node_affinity
        if pod_affinity is not None:
            self._values["pod_affinity"] = pod_affinity
        if pod_anti_affinity is not None:
            self._values["pod_anti_affinity"] = pod_anti_affinity

    @builtins.property
    def node_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityNodeAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinity#nodeAffinity
        '''
        result = self._values.get("node_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityNodeAffinity"], result)

    @builtins.property
    def pod_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinity#podAffinity
        '''
        result = self._values.get("pod_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAffinity"], result)

    @builtins.property
    def pod_anti_affinity(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinity"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinity#podAntiAffinity
        '''
        result = self._values.get("pod_anti_affinity")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPrometheusAffinityNodeAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinity
        '''
        if isinstance(required_during_scheduling_ignored_during_execution, dict):
            required_during_scheduling_ignored_during_execution = TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(**required_during_scheduling_ignored_during_execution)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"preference": "preference", "weight": "weight"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        preference: typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param preference: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(preference, dict):
            preference = TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(**preference)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument preference", value=preference, expected_type=type_hints["preference"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "preference": preference,
            "weight": weight,
        }

    @builtins.property
    def preference(
        self,
    ) -> "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference":
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
        '''
        result = self._values.get("preference")
        assert result is not None, "Required property 'preference' is missing"
        return typing.cast("TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"node_selector_terms": "nodeSelectorTerms"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        node_selector_terms: typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param node_selector_terms: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument node_selector_terms", value=node_selector_terms, expected_type=type_hints["node_selector_terms"])
        self._values: typing.Dict[str, typing.Any] = {
            "node_selector_terms": node_selector_terms,
        }

    @builtins.property
    def node_selector_terms(
        self,
    ) -> typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
        '''
        result = self._values.get("node_selector_terms")
        assert result is not None, "Required property 'node_selector_terms' is missing"
        return typing.cast(typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_fields": "matchFields",
    },
)
class TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_fields: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_fields: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_fields", value=match_fields, expected_type=type_hints["match_fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_fields is not None:
            self._values["match_fields"] = match_fields

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions"]], result)

    @builtins.property
    def match_fields(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
        '''
        result = self._values.get("match_fields")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPrometheusAffinityPodAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinity",
    jsii_struct_bases=[],
    name_mapping={
        "preferred_during_scheduling_ignored_during_execution": "preferredDuringSchedulingIgnoredDuringExecution",
        "required_during_scheduling_ignored_during_execution": "requiredDuringSchedulingIgnoredDuringExecution",
    },
)
class TenantV2SpecPrometheusAffinityPodAntiAffinity:
    def __init__(
        self,
        *,
        preferred_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
        required_during_scheduling_ignored_during_execution: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param preferred_during_scheduling_ignored_during_execution: 
        :param required_during_scheduling_ignored_during_execution: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinity
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinity.__init__)
            check_type(argname="argument preferred_during_scheduling_ignored_during_execution", value=preferred_during_scheduling_ignored_during_execution, expected_type=type_hints["preferred_during_scheduling_ignored_during_execution"])
            check_type(argname="argument required_during_scheduling_ignored_during_execution", value=required_during_scheduling_ignored_during_execution, expected_type=type_hints["required_during_scheduling_ignored_during_execution"])
        self._values: typing.Dict[str, typing.Any] = {}
        if preferred_during_scheduling_ignored_during_execution is not None:
            self._values["preferred_during_scheduling_ignored_during_execution"] = preferred_during_scheduling_ignored_during_execution
        if required_during_scheduling_ignored_during_execution is not None:
            self._values["required_during_scheduling_ignored_during_execution"] = required_during_scheduling_ignored_during_execution

    @builtins.property
    def preferred_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("preferred_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution"]], result)

    @builtins.property
    def required_during_scheduling_ignored_during_execution(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
        '''
        result = self._values.get("required_during_scheduling_ignored_during_execution")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={"pod_affinity_term": "podAffinityTerm", "weight": "weight"},
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        pod_affinity_term: typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", typing.Dict[str, typing.Any]],
        weight: jsii.Number,
    ) -> None:
        '''
        :param pod_affinity_term: 
        :param weight: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(pod_affinity_term, dict):
            pod_affinity_term = TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(**pod_affinity_term)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument pod_affinity_term", value=pod_affinity_term, expected_type=type_hints["pod_affinity_term"])
            check_type(argname="argument weight", value=weight, expected_type=type_hints["weight"])
        self._values: typing.Dict[str, typing.Any] = {
            "pod_affinity_term": pod_affinity_term,
            "weight": weight,
        }

    @builtins.property
    def pod_affinity_term(
        self,
    ) -> "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm":
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
        '''
        result = self._values.get("pod_affinity_term")
        assert result is not None, "Required property 'pod_affinity_term' is missing"
        return typing.cast("TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm", result)

    @builtins.property
    def weight(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
        '''
        result = self._values.get("weight")
        assert result is not None, "Required property 'weight' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    jsii_struct_bases=[],
    name_mapping={
        "topology_key": "topologyKey",
        "label_selector": "labelSelector",
        "namespaces": "namespaces",
    },
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution:
    def __init__(
        self,
        *,
        topology_key: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector", typing.Dict[str, typing.Any]]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param topology_key: 
        :param label_selector: 
        :param namespaces: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__init__)
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
        self._values: typing.Dict[str, typing.Any] = {
            "topology_key": topology_key,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if namespaces is not None:
            self._values["namespaces"] = namespaces

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector"], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecPrometheusResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecPrometheusResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecPrometheusResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPrometheusResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecPrometheusResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPrometheusResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecPrometheusResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPrometheusResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecPrometheusResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecPrometheusResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecPrometheusResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPrometheusResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecPrometheusResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecPrometheusResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "fs_group": "fsGroup",
        "fs_group_change_policy": "fsGroupChangePolicy",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "supplemental_groups": "supplementalGroups",
        "sysctls": "sysctls",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecPrometheusSecurityContext:
    def __init__(
        self,
        *,
        fs_group: typing.Optional[jsii.Number] = None,
        fs_group_change_policy: typing.Optional[builtins.str] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecPrometheusSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecPrometheusSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        supplemental_groups: typing.Optional[typing.Sequence[jsii.Number]] = None,
        sysctls: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusSecurityContextSysctls", typing.Dict[str, typing.Any]]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecPrometheusSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fs_group: 
        :param fs_group_change_policy: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param supplemental_groups: 
        :param sysctls: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext
        '''
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecPrometheusSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecPrometheusSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecPrometheusSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusSecurityContext.__init__)
            check_type(argname="argument fs_group", value=fs_group, expected_type=type_hints["fs_group"])
            check_type(argname="argument fs_group_change_policy", value=fs_group_change_policy, expected_type=type_hints["fs_group_change_policy"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument supplemental_groups", value=supplemental_groups, expected_type=type_hints["supplemental_groups"])
            check_type(argname="argument sysctls", value=sysctls, expected_type=type_hints["sysctls"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_group is not None:
            self._values["fs_group"] = fs_group
        if fs_group_change_policy is not None:
            self._values["fs_group_change_policy"] = fs_group_change_policy
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if supplemental_groups is not None:
            self._values["supplemental_groups"] = supplemental_groups
        if sysctls is not None:
            self._values["sysctls"] = sysctls
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def fs_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#fsGroup
        '''
        result = self._values.get("fs_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fs_group_change_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#fsGroupChangePolicy
        '''
        result = self._values.get("fs_group_change_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def supplemental_groups(self) -> typing.Optional[typing.List[jsii.Number]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#supplementalGroups
        '''
        result = self._values.get("supplemental_groups")
        return typing.cast(typing.Optional[typing.List[jsii.Number]], result)

    @builtins.property
    def sysctls(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusSecurityContextSysctls"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#sysctls
        '''
        result = self._values.get("sysctls")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusSecurityContextSysctls"]], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecPrometheusSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecPrometheusSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusSecurityContextSysctls",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecPrometheusSecurityContextSysctls:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSysctls
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusSecurityContextSysctls.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSysctls#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextSysctls#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusSecurityContextSysctls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecPrometheusSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusTopologySpreadConstraints",
    jsii_struct_bases=[],
    name_mapping={
        "max_skew": "maxSkew",
        "topology_key": "topologyKey",
        "when_unsatisfiable": "whenUnsatisfiable",
        "label_selector": "labelSelector",
    },
)
class TenantV2SpecPrometheusTopologySpreadConstraints:
    def __init__(
        self,
        *,
        max_skew: jsii.Number,
        topology_key: builtins.str,
        when_unsatisfiable: builtins.str,
        label_selector: typing.Optional[typing.Union["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param max_skew: 
        :param topology_key: 
        :param when_unsatisfiable: 
        :param label_selector: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraints
        '''
        if isinstance(label_selector, dict):
            label_selector = TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusTopologySpreadConstraints.__init__)
            check_type(argname="argument max_skew", value=max_skew, expected_type=type_hints["max_skew"])
            check_type(argname="argument topology_key", value=topology_key, expected_type=type_hints["topology_key"])
            check_type(argname="argument when_unsatisfiable", value=when_unsatisfiable, expected_type=type_hints["when_unsatisfiable"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_skew": max_skew,
            "topology_key": topology_key,
            "when_unsatisfiable": when_unsatisfiable,
        }
        if label_selector is not None:
            self._values["label_selector"] = label_selector

    @builtins.property
    def max_skew(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraints#maxSkew
        '''
        result = self._values.get("max_skew")
        assert result is not None, "Required property 'max_skew' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def topology_key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraints#topologyKey
        '''
        result = self._values.get("topology_key")
        assert result is not None, "Required property 'topology_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def when_unsatisfiable(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraints#whenUnsatisfiable
        '''
        result = self._values.get("when_unsatisfiable")
        assert result is not None, "Required property 'when_unsatisfiable' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraints#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusTopologySpreadConstraints(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadiness",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantV2SpecReadiness:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecReadinessExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecReadinessHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecReadinessTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantV2SpecReadiness
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecReadinessExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecReadinessHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecReadinessTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadiness.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantV2SpecReadinessExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecReadinessExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(self) -> typing.Optional["TenantV2SpecReadinessHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecReadinessHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(self) -> typing.Optional["TenantV2SpecReadinessTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecReadinessTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadiness#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecReadiness(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecReadinessExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecReadinessExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecReadinessExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecReadinessHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecReadinessHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecReadinessHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecReadinessHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecReadinessHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecReadinessHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecReadinessHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecReadinessHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecReadinessHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecReadinessHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecReadinessHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecReadinessHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecReadinessHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecReadinessHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecReadinessHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecReadinessHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecReadinessTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecReadinessTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecReadinessTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecReadinessTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecReadinessTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecReadinessTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecReadinessTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecReadinessTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecReadinessTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecReadinessTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(cls, value: jsii.Number) -> "TenantV2SpecReadinessTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecReadinessTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(cls, value: builtins.str) -> "TenantV2SpecReadinessTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecReadinessTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecReadinessTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecS3",
    jsii_struct_bases=[],
    name_mapping={"bucket_dns": "bucketDns"},
)
class TenantV2SpecS3:
    def __init__(self, *, bucket_dns: typing.Optional[builtins.bool] = None) -> None:
        '''
        :param bucket_dns: 

        :stability: experimental
        :schema: TenantV2SpecS3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecS3.__init__)
            check_type(argname="argument bucket_dns", value=bucket_dns, expected_type=type_hints["bucket_dns"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bucket_dns is not None:
            self._values["bucket_dns"] = bucket_dns

    @builtins.property
    def bucket_dns(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecS3#bucketDNS
        '''
        result = self._values.get("bucket_dns")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecS3(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecServiceMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "console_service_annotations": "consoleServiceAnnotations",
        "console_service_labels": "consoleServiceLabels",
        "minio_service_annotations": "minioServiceAnnotations",
        "minio_service_labels": "minioServiceLabels",
    },
)
class TenantV2SpecServiceMetadata:
    def __init__(
        self,
        *,
        console_service_annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        console_service_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        minio_service_annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        minio_service_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param console_service_annotations: 
        :param console_service_labels: 
        :param minio_service_annotations: 
        :param minio_service_labels: 

        :stability: experimental
        :schema: TenantV2SpecServiceMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecServiceMetadata.__init__)
            check_type(argname="argument console_service_annotations", value=console_service_annotations, expected_type=type_hints["console_service_annotations"])
            check_type(argname="argument console_service_labels", value=console_service_labels, expected_type=type_hints["console_service_labels"])
            check_type(argname="argument minio_service_annotations", value=minio_service_annotations, expected_type=type_hints["minio_service_annotations"])
            check_type(argname="argument minio_service_labels", value=minio_service_labels, expected_type=type_hints["minio_service_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if console_service_annotations is not None:
            self._values["console_service_annotations"] = console_service_annotations
        if console_service_labels is not None:
            self._values["console_service_labels"] = console_service_labels
        if minio_service_annotations is not None:
            self._values["minio_service_annotations"] = minio_service_annotations
        if minio_service_labels is not None:
            self._values["minio_service_labels"] = minio_service_labels

    @builtins.property
    def console_service_annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecServiceMetadata#consoleServiceAnnotations
        '''
        result = self._values.get("console_service_annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def console_service_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecServiceMetadata#consoleServiceLabels
        '''
        result = self._values.get("console_service_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def minio_service_annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecServiceMetadata#minioServiceAnnotations
        '''
        result = self._values.get("minio_service_annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def minio_service_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecServiceMetadata#minioServiceLabels
        '''
        result = self._values.get("minio_service_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecServiceMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCars",
    jsii_struct_bases=[],
    name_mapping={
        "containers": "containers",
        "volume_claim_templates": "volumeClaimTemplates",
        "volumes": "volumes",
    },
)
class TenantV2SpecSideCars:
    def __init__(
        self,
        *,
        containers: typing.Sequence[typing.Union["TenantV2SpecSideCarsContainers", typing.Dict[str, typing.Any]]],
        volume_claim_templates: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplates", typing.Dict[str, typing.Any]]]] = None,
        volumes: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumes", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param containers: 
        :param volume_claim_templates: 
        :param volumes: 

        :stability: experimental
        :schema: TenantV2SpecSideCars
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCars.__init__)
            check_type(argname="argument containers", value=containers, expected_type=type_hints["containers"])
            check_type(argname="argument volume_claim_templates", value=volume_claim_templates, expected_type=type_hints["volume_claim_templates"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[str, typing.Any] = {
            "containers": containers,
        }
        if volume_claim_templates is not None:
            self._values["volume_claim_templates"] = volume_claim_templates
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def containers(self) -> typing.List["TenantV2SpecSideCarsContainers"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCars#containers
        '''
        result = self._values.get("containers")
        assert result is not None, "Required property 'containers' is missing"
        return typing.cast(typing.List["TenantV2SpecSideCarsContainers"], result)

    @builtins.property
    def volume_claim_templates(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplates"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCars#volumeClaimTemplates
        '''
        result = self._values.get("volume_claim_templates")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplates"]], result)

    @builtins.property
    def volumes(self) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumes"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCars#volumes
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumes"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCars(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainers",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "args": "args",
        "command": "command",
        "env": "env",
        "env_from": "envFrom",
        "image": "image",
        "image_pull_policy": "imagePullPolicy",
        "lifecycle": "lifecycle",
        "liveness_probe": "livenessProbe",
        "ports": "ports",
        "readiness_probe": "readinessProbe",
        "resources": "resources",
        "security_context": "securityContext",
        "startup_probe": "startupProbe",
        "stdin": "stdin",
        "stdin_once": "stdinOnce",
        "termination_message_path": "terminationMessagePath",
        "termination_message_policy": "terminationMessagePolicy",
        "tty": "tty",
        "volume_devices": "volumeDevices",
        "volume_mounts": "volumeMounts",
        "working_dir": "workingDir",
    },
)
class TenantV2SpecSideCarsContainers:
    def __init__(
        self,
        *,
        name: builtins.str,
        args: typing.Optional[typing.Sequence[builtins.str]] = None,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        env: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersEnv", typing.Dict[str, typing.Any]]]] = None,
        env_from: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersEnvFrom", typing.Dict[str, typing.Any]]]] = None,
        image: typing.Optional[builtins.str] = None,
        image_pull_policy: typing.Optional[builtins.str] = None,
        lifecycle: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecycle", typing.Dict[str, typing.Any]]] = None,
        liveness_probe: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLivenessProbe", typing.Dict[str, typing.Any]]] = None,
        ports: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersPorts", typing.Dict[str, typing.Any]]]] = None,
        readiness_probe: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersReadinessProbe", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersResources", typing.Dict[str, typing.Any]]] = None,
        security_context: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersSecurityContext", typing.Dict[str, typing.Any]]] = None,
        startup_probe: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersStartupProbe", typing.Dict[str, typing.Any]]] = None,
        stdin: typing.Optional[builtins.bool] = None,
        stdin_once: typing.Optional[builtins.bool] = None,
        termination_message_path: typing.Optional[builtins.str] = None,
        termination_message_policy: typing.Optional[builtins.str] = None,
        tty: typing.Optional[builtins.bool] = None,
        volume_devices: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersVolumeDevices", typing.Dict[str, typing.Any]]]] = None,
        volume_mounts: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersVolumeMounts", typing.Dict[str, typing.Any]]]] = None,
        working_dir: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: 
        :param args: 
        :param command: 
        :param env: 
        :param env_from: 
        :param image: 
        :param image_pull_policy: 
        :param lifecycle: 
        :param liveness_probe: 
        :param ports: 
        :param readiness_probe: 
        :param resources: 
        :param security_context: 
        :param startup_probe: 
        :param stdin: 
        :param stdin_once: 
        :param termination_message_path: 
        :param termination_message_policy: 
        :param tty: 
        :param volume_devices: 
        :param volume_mounts: 
        :param working_dir: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers
        '''
        if isinstance(lifecycle, dict):
            lifecycle = TenantV2SpecSideCarsContainersLifecycle(**lifecycle)
        if isinstance(liveness_probe, dict):
            liveness_probe = TenantV2SpecSideCarsContainersLivenessProbe(**liveness_probe)
        if isinstance(readiness_probe, dict):
            readiness_probe = TenantV2SpecSideCarsContainersReadinessProbe(**readiness_probe)
        if isinstance(resources, dict):
            resources = TenantV2SpecSideCarsContainersResources(**resources)
        if isinstance(security_context, dict):
            security_context = TenantV2SpecSideCarsContainersSecurityContext(**security_context)
        if isinstance(startup_probe, dict):
            startup_probe = TenantV2SpecSideCarsContainersStartupProbe(**startup_probe)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainers.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument env", value=env, expected_type=type_hints["env"])
            check_type(argname="argument env_from", value=env_from, expected_type=type_hints["env_from"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument image_pull_policy", value=image_pull_policy, expected_type=type_hints["image_pull_policy"])
            check_type(argname="argument lifecycle", value=lifecycle, expected_type=type_hints["lifecycle"])
            check_type(argname="argument liveness_probe", value=liveness_probe, expected_type=type_hints["liveness_probe"])
            check_type(argname="argument ports", value=ports, expected_type=type_hints["ports"])
            check_type(argname="argument readiness_probe", value=readiness_probe, expected_type=type_hints["readiness_probe"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument security_context", value=security_context, expected_type=type_hints["security_context"])
            check_type(argname="argument startup_probe", value=startup_probe, expected_type=type_hints["startup_probe"])
            check_type(argname="argument stdin", value=stdin, expected_type=type_hints["stdin"])
            check_type(argname="argument stdin_once", value=stdin_once, expected_type=type_hints["stdin_once"])
            check_type(argname="argument termination_message_path", value=termination_message_path, expected_type=type_hints["termination_message_path"])
            check_type(argname="argument termination_message_policy", value=termination_message_policy, expected_type=type_hints["termination_message_policy"])
            check_type(argname="argument tty", value=tty, expected_type=type_hints["tty"])
            check_type(argname="argument volume_devices", value=volume_devices, expected_type=type_hints["volume_devices"])
            check_type(argname="argument volume_mounts", value=volume_mounts, expected_type=type_hints["volume_mounts"])
            check_type(argname="argument working_dir", value=working_dir, expected_type=type_hints["working_dir"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if args is not None:
            self._values["args"] = args
        if command is not None:
            self._values["command"] = command
        if env is not None:
            self._values["env"] = env
        if env_from is not None:
            self._values["env_from"] = env_from
        if image is not None:
            self._values["image"] = image
        if image_pull_policy is not None:
            self._values["image_pull_policy"] = image_pull_policy
        if lifecycle is not None:
            self._values["lifecycle"] = lifecycle
        if liveness_probe is not None:
            self._values["liveness_probe"] = liveness_probe
        if ports is not None:
            self._values["ports"] = ports
        if readiness_probe is not None:
            self._values["readiness_probe"] = readiness_probe
        if resources is not None:
            self._values["resources"] = resources
        if security_context is not None:
            self._values["security_context"] = security_context
        if startup_probe is not None:
            self._values["startup_probe"] = startup_probe
        if stdin is not None:
            self._values["stdin"] = stdin
        if stdin_once is not None:
            self._values["stdin_once"] = stdin_once
        if termination_message_path is not None:
            self._values["termination_message_path"] = termination_message_path
        if termination_message_policy is not None:
            self._values["termination_message_policy"] = termination_message_policy
        if tty is not None:
            self._values["tty"] = tty
        if volume_devices is not None:
            self._values["volume_devices"] = volume_devices
        if volume_mounts is not None:
            self._values["volume_mounts"] = volume_mounts
        if working_dir is not None:
            self._values["working_dir"] = working_dir

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def args(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#args
        '''
        result = self._values.get("args")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def env(self) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersEnv"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#env
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersEnv"]], result)

    @builtins.property
    def env_from(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersEnvFrom"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#envFrom
        '''
        result = self._values.get("env_from")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersEnvFrom"]], result)

    @builtins.property
    def image(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#image
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_pull_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#imagePullPolicy
        '''
        result = self._values.get("image_pull_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lifecycle(self) -> typing.Optional["TenantV2SpecSideCarsContainersLifecycle"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#lifecycle
        '''
        result = self._values.get("lifecycle")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecycle"], result)

    @builtins.property
    def liveness_probe(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLivenessProbe"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#livenessProbe
        '''
        result = self._values.get("liveness_probe")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLivenessProbe"], result)

    @builtins.property
    def ports(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersPorts"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#ports
        '''
        result = self._values.get("ports")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersPorts"]], result)

    @builtins.property
    def readiness_probe(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersReadinessProbe"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#readinessProbe
        '''
        result = self._values.get("readiness_probe")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersReadinessProbe"], result)

    @builtins.property
    def resources(self) -> typing.Optional["TenantV2SpecSideCarsContainersResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersResources"], result)

    @builtins.property
    def security_context(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersSecurityContext"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#securityContext
        '''
        result = self._values.get("security_context")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersSecurityContext"], result)

    @builtins.property
    def startup_probe(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersStartupProbe"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#startupProbe
        '''
        result = self._values.get("startup_probe")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersStartupProbe"], result)

    @builtins.property
    def stdin(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#stdin
        '''
        result = self._values.get("stdin")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def stdin_once(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#stdinOnce
        '''
        result = self._values.get("stdin_once")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def termination_message_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#terminationMessagePath
        '''
        result = self._values.get("termination_message_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def termination_message_policy(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#terminationMessagePolicy
        '''
        result = self._values.get("termination_message_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tty(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#tty
        '''
        result = self._values.get("tty")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_devices(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersVolumeDevices"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#volumeDevices
        '''
        result = self._values.get("volume_devices")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersVolumeDevices"]], result)

    @builtins.property
    def volume_mounts(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersVolumeMounts"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#volumeMounts
        '''
        result = self._values.get("volume_mounts")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersVolumeMounts"]], result)

    @builtins.property
    def working_dir(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainers#workingDir
        '''
        result = self._values.get("working_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnv",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value", "value_from": "valueFrom"},
)
class TenantV2SpecSideCarsContainersEnv:
    def __init__(
        self,
        *,
        name: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_from: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvValueFrom", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param value: 
        :param value_from: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnv
        '''
        if isinstance(value_from, dict):
            value_from = TenantV2SpecSideCarsContainersEnvValueFrom(**value_from)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnv.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_from", value=value_from, expected_type=type_hints["value_from"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if value is not None:
            self._values["value"] = value
        if value_from is not None:
            self._values["value_from"] = value_from

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnv#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnv#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_from(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFrom"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnv#valueFrom
        '''
        result = self._values.get("value_from")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFrom"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_ref": "configMapRef",
        "prefix": "prefix",
        "secret_ref": "secretRef",
    },
)
class TenantV2SpecSideCarsContainersEnvFrom:
    def __init__(
        self,
        *,
        config_map_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvFromConfigMapRef", typing.Dict[str, typing.Any]]] = None,
        prefix: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvFromSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_ref: 
        :param prefix: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFrom
        '''
        if isinstance(config_map_ref, dict):
            config_map_ref = TenantV2SpecSideCarsContainersEnvFromConfigMapRef(**config_map_ref)
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsContainersEnvFromSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvFrom.__init__)
            check_type(argname="argument config_map_ref", value=config_map_ref, expected_type=type_hints["config_map_ref"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_ref is not None:
            self._values["config_map_ref"] = config_map_ref
        if prefix is not None:
            self._values["prefix"] = prefix
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def config_map_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvFromConfigMapRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFrom#configMapRef
        '''
        result = self._values.get("config_map_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvFromConfigMapRef"], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFrom#prefix
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvFromSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFrom#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvFromSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvFromConfigMapRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsContainersEnvFromConfigMapRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromConfigMapRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvFromConfigMapRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromConfigMapRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromConfigMapRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvFromConfigMapRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvFromSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsContainersEnvFromSecretRef:
    def __init__(
        self,
        *,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvFromSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvFromSecretRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvFromSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map_key_ref": "configMapKeyRef",
        "field_ref": "fieldRef",
        "resource_field_ref": "resourceFieldRef",
        "secret_key_ref": "secretKeyRef",
    },
)
class TenantV2SpecSideCarsContainersEnvValueFrom:
    def __init__(
        self,
        *,
        config_map_key_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef", typing.Dict[str, typing.Any]]] = None,
        field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvValueFromFieldRef", typing.Dict[str, typing.Any]]] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
        secret_key_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map_key_ref: 
        :param field_ref: 
        :param resource_field_ref: 
        :param secret_key_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFrom
        '''
        if isinstance(config_map_key_ref, dict):
            config_map_key_ref = TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef(**config_map_key_ref)
        if isinstance(field_ref, dict):
            field_ref = TenantV2SpecSideCarsContainersEnvValueFromFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef(**resource_field_ref)
        if isinstance(secret_key_ref, dict):
            secret_key_ref = TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef(**secret_key_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFrom.__init__)
            check_type(argname="argument config_map_key_ref", value=config_map_key_ref, expected_type=type_hints["config_map_key_ref"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
            check_type(argname="argument secret_key_ref", value=secret_key_ref, expected_type=type_hints["secret_key_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map_key_ref is not None:
            self._values["config_map_key_ref"] = config_map_key_ref
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref
        if secret_key_ref is not None:
            self._values["secret_key_ref"] = secret_key_ref

    @builtins.property
    def config_map_key_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFrom#configMapKeyRef
        '''
        result = self._values.get("config_map_key_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef"], result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFrom#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromFieldRef"], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFrom#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef"], result)

    @builtins.property
    def secret_key_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFrom#secretKeyRef
        '''
        result = self._values.get("secret_key_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvValueFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFromFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantV2SpecSideCarsContainersEnvValueFromFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvValueFromFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param key: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecycle",
    jsii_struct_bases=[],
    name_mapping={"post_start": "postStart", "pre_stop": "preStop"},
)
class TenantV2SpecSideCarsContainersLifecycle:
    def __init__(
        self,
        *,
        post_start: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePostStart", typing.Dict[str, typing.Any]]] = None,
        pre_stop: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePreStop", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param post_start: 
        :param pre_stop: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecycle
        '''
        if isinstance(post_start, dict):
            post_start = TenantV2SpecSideCarsContainersLifecyclePostStart(**post_start)
        if isinstance(pre_stop, dict):
            pre_stop = TenantV2SpecSideCarsContainersLifecyclePreStop(**pre_stop)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecycle.__init__)
            check_type(argname="argument post_start", value=post_start, expected_type=type_hints["post_start"])
            check_type(argname="argument pre_stop", value=pre_stop, expected_type=type_hints["pre_stop"])
        self._values: typing.Dict[str, typing.Any] = {}
        if post_start is not None:
            self._values["post_start"] = post_start
        if pre_stop is not None:
            self._values["pre_stop"] = pre_stop

    @builtins.property
    def post_start(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStart"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecycle#postStart
        '''
        result = self._values.get("post_start")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStart"], result)

    @builtins.property
    def pre_stop(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStop"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecycle#preStop
        '''
        result = self._values.get("pre_stop")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStop"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecycle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStart",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class TenantV2SpecSideCarsContainersLifecyclePostStart:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePostStartExec", typing.Dict[str, typing.Any]]] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet", typing.Dict[str, typing.Any]]] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param exec: 
        :param http_get: 
        :param tcp_socket: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStart
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecSideCarsContainersLifecyclePostStartExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStart.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStart#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartExec"], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStart#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet"], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStart#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePostStart(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecSideCarsContainersLifecyclePostStartExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePostStartExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStop",
    jsii_struct_bases=[],
    name_mapping={"exec": "exec", "http_get": "httpGet", "tcp_socket": "tcpSocket"},
)
class TenantV2SpecSideCarsContainersLifecyclePreStop:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePreStopExec", typing.Dict[str, typing.Any]]] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet", typing.Dict[str, typing.Any]]] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param exec: 
        :param http_get: 
        :param tcp_socket: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStop
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecSideCarsContainersLifecyclePreStopExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStop.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if http_get is not None:
            self._values["http_get"] = http_get
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStop#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopExec"], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStop#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet"], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStop#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePreStop(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecSideCarsContainersLifecyclePreStopExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePreStopExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantV2SpecSideCarsContainersLivenessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLivenessProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLivenessProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersLivenessProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecSideCarsContainersLivenessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecSideCarsContainersLivenessProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecSideCarsContainersLivenessProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersLivenessProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLivenessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecSideCarsContainersLivenessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLivenessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecSideCarsContainersLivenessProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLivenessProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecSideCarsContainersLivenessProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersLivenessProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersLivenessProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersPorts",
    jsii_struct_bases=[],
    name_mapping={
        "container_port": "containerPort",
        "host_ip": "hostIp",
        "host_port": "hostPort",
        "name": "name",
        "protocol": "protocol",
    },
)
class TenantV2SpecSideCarsContainersPorts:
    def __init__(
        self,
        *,
        container_port: jsii.Number,
        host_ip: typing.Optional[builtins.str] = None,
        host_port: typing.Optional[jsii.Number] = None,
        name: typing.Optional[builtins.str] = None,
        protocol: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param container_port: 
        :param host_ip: 
        :param host_port: 
        :param name: 
        :param protocol: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersPorts.__init__)
            check_type(argname="argument container_port", value=container_port, expected_type=type_hints["container_port"])
            check_type(argname="argument host_ip", value=host_ip, expected_type=type_hints["host_ip"])
            check_type(argname="argument host_port", value=host_port, expected_type=type_hints["host_port"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument protocol", value=protocol, expected_type=type_hints["protocol"])
        self._values: typing.Dict[str, typing.Any] = {
            "container_port": container_port,
        }
        if host_ip is not None:
            self._values["host_ip"] = host_ip
        if host_port is not None:
            self._values["host_port"] = host_port
        if name is not None:
            self._values["name"] = name
        if protocol is not None:
            self._values["protocol"] = protocol

    @builtins.property
    def container_port(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts#containerPort
        '''
        result = self._values.get("container_port")
        assert result is not None, "Required property 'container_port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def host_ip(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts#hostIP
        '''
        result = self._values.get("host_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_port(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts#hostPort
        '''
        result = self._values.get("host_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersPorts#protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersPorts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantV2SpecSideCarsContainersReadinessProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersReadinessProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersReadinessProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersReadinessProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecSideCarsContainersReadinessProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecSideCarsContainersReadinessProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecSideCarsContainersReadinessProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersReadinessProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersReadinessProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecSideCarsContainersReadinessProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersReadinessProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecSideCarsContainersReadinessProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersReadinessProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecSideCarsContainersReadinessProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersReadinessProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersReadinessProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecSideCarsContainersResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsContainersResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecSideCarsContainersResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersSecurityContext",
    jsii_struct_bases=[],
    name_mapping={
        "allow_privilege_escalation": "allowPrivilegeEscalation",
        "capabilities": "capabilities",
        "privileged": "privileged",
        "proc_mount": "procMount",
        "read_only_root_filesystem": "readOnlyRootFilesystem",
        "run_as_group": "runAsGroup",
        "run_as_non_root": "runAsNonRoot",
        "run_as_user": "runAsUser",
        "seccomp_profile": "seccompProfile",
        "se_linux_options": "seLinuxOptions",
        "windows_options": "windowsOptions",
    },
)
class TenantV2SpecSideCarsContainersSecurityContext:
    def __init__(
        self,
        *,
        allow_privilege_escalation: typing.Optional[builtins.bool] = None,
        capabilities: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersSecurityContextCapabilities", typing.Dict[str, typing.Any]]] = None,
        privileged: typing.Optional[builtins.bool] = None,
        proc_mount: typing.Optional[builtins.str] = None,
        read_only_root_filesystem: typing.Optional[builtins.bool] = None,
        run_as_group: typing.Optional[jsii.Number] = None,
        run_as_non_root: typing.Optional[builtins.bool] = None,
        run_as_user: typing.Optional[jsii.Number] = None,
        seccomp_profile: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersSecurityContextSeccompProfile", typing.Dict[str, typing.Any]]] = None,
        se_linux_options: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions", typing.Dict[str, typing.Any]]] = None,
        windows_options: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersSecurityContextWindowsOptions", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param allow_privilege_escalation: 
        :param capabilities: 
        :param privileged: 
        :param proc_mount: 
        :param read_only_root_filesystem: 
        :param run_as_group: 
        :param run_as_non_root: 
        :param run_as_user: 
        :param seccomp_profile: 
        :param se_linux_options: 
        :param windows_options: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext
        '''
        if isinstance(capabilities, dict):
            capabilities = TenantV2SpecSideCarsContainersSecurityContextCapabilities(**capabilities)
        if isinstance(seccomp_profile, dict):
            seccomp_profile = TenantV2SpecSideCarsContainersSecurityContextSeccompProfile(**seccomp_profile)
        if isinstance(se_linux_options, dict):
            se_linux_options = TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions(**se_linux_options)
        if isinstance(windows_options, dict):
            windows_options = TenantV2SpecSideCarsContainersSecurityContextWindowsOptions(**windows_options)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersSecurityContext.__init__)
            check_type(argname="argument allow_privilege_escalation", value=allow_privilege_escalation, expected_type=type_hints["allow_privilege_escalation"])
            check_type(argname="argument capabilities", value=capabilities, expected_type=type_hints["capabilities"])
            check_type(argname="argument privileged", value=privileged, expected_type=type_hints["privileged"])
            check_type(argname="argument proc_mount", value=proc_mount, expected_type=type_hints["proc_mount"])
            check_type(argname="argument read_only_root_filesystem", value=read_only_root_filesystem, expected_type=type_hints["read_only_root_filesystem"])
            check_type(argname="argument run_as_group", value=run_as_group, expected_type=type_hints["run_as_group"])
            check_type(argname="argument run_as_non_root", value=run_as_non_root, expected_type=type_hints["run_as_non_root"])
            check_type(argname="argument run_as_user", value=run_as_user, expected_type=type_hints["run_as_user"])
            check_type(argname="argument seccomp_profile", value=seccomp_profile, expected_type=type_hints["seccomp_profile"])
            check_type(argname="argument se_linux_options", value=se_linux_options, expected_type=type_hints["se_linux_options"])
            check_type(argname="argument windows_options", value=windows_options, expected_type=type_hints["windows_options"])
        self._values: typing.Dict[str, typing.Any] = {}
        if allow_privilege_escalation is not None:
            self._values["allow_privilege_escalation"] = allow_privilege_escalation
        if capabilities is not None:
            self._values["capabilities"] = capabilities
        if privileged is not None:
            self._values["privileged"] = privileged
        if proc_mount is not None:
            self._values["proc_mount"] = proc_mount
        if read_only_root_filesystem is not None:
            self._values["read_only_root_filesystem"] = read_only_root_filesystem
        if run_as_group is not None:
            self._values["run_as_group"] = run_as_group
        if run_as_non_root is not None:
            self._values["run_as_non_root"] = run_as_non_root
        if run_as_user is not None:
            self._values["run_as_user"] = run_as_user
        if seccomp_profile is not None:
            self._values["seccomp_profile"] = seccomp_profile
        if se_linux_options is not None:
            self._values["se_linux_options"] = se_linux_options
        if windows_options is not None:
            self._values["windows_options"] = windows_options

    @builtins.property
    def allow_privilege_escalation(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#allowPrivilegeEscalation
        '''
        result = self._values.get("allow_privilege_escalation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def capabilities(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersSecurityContextCapabilities"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#capabilities
        '''
        result = self._values.get("capabilities")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersSecurityContextCapabilities"], result)

    @builtins.property
    def privileged(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#privileged
        '''
        result = self._values.get("privileged")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def proc_mount(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#procMount
        '''
        result = self._values.get("proc_mount")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only_root_filesystem(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#readOnlyRootFilesystem
        '''
        result = self._values.get("read_only_root_filesystem")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_group(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#runAsGroup
        '''
        result = self._values.get("run_as_group")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def run_as_non_root(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#runAsNonRoot
        '''
        result = self._values.get("run_as_non_root")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def run_as_user(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#runAsUser
        '''
        result = self._values.get("run_as_user")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def seccomp_profile(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersSecurityContextSeccompProfile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#seccompProfile
        '''
        result = self._values.get("seccomp_profile")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersSecurityContextSeccompProfile"], result)

    @builtins.property
    def se_linux_options(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#seLinuxOptions
        '''
        result = self._values.get("se_linux_options")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions"], result)

    @builtins.property
    def windows_options(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersSecurityContextWindowsOptions"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContext#windowsOptions
        '''
        result = self._values.get("windows_options")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersSecurityContextWindowsOptions"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersSecurityContext(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersSecurityContextCapabilities",
    jsii_struct_bases=[],
    name_mapping={"add": "add", "drop": "drop"},
)
class TenantV2SpecSideCarsContainersSecurityContextCapabilities:
    def __init__(
        self,
        *,
        add: typing.Optional[typing.Sequence[builtins.str]] = None,
        drop: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param add: 
        :param drop: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextCapabilities
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersSecurityContextCapabilities.__init__)
            check_type(argname="argument add", value=add, expected_type=type_hints["add"])
            check_type(argname="argument drop", value=drop, expected_type=type_hints["drop"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add is not None:
            self._values["add"] = add
        if drop is not None:
            self._values["drop"] = drop

    @builtins.property
    def add(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextCapabilities#add
        '''
        result = self._values.get("add")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def drop(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextCapabilities#drop
        '''
        result = self._values.get("drop")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersSecurityContextCapabilities(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions",
    jsii_struct_bases=[],
    name_mapping={"level": "level", "role": "role", "type": "type", "user": "user"},
)
class TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions:
    def __init__(
        self,
        *,
        level: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        type: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param level: 
        :param role: 
        :param type: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions.__init__)
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {}
        if level is not None:
            self._values["level"] = level
        if role is not None:
            self._values["role"] = role
        if type is not None:
            self._values["type"] = type
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def level(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions#level
        '''
        result = self._values.get("level")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersSecurityContextSeccompProfile",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "localhost_profile": "localhostProfile"},
)
class TenantV2SpecSideCarsContainersSecurityContextSeccompProfile:
    def __init__(
        self,
        *,
        type: builtins.str,
        localhost_profile: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param type: 
        :param localhost_profile: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeccompProfile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersSecurityContextSeccompProfile.__init__)
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument localhost_profile", value=localhost_profile, expected_type=type_hints["localhost_profile"])
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if localhost_profile is not None:
            self._values["localhost_profile"] = localhost_profile

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeccompProfile#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def localhost_profile(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextSeccompProfile#localhostProfile
        '''
        result = self._values.get("localhost_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersSecurityContextSeccompProfile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersSecurityContextWindowsOptions",
    jsii_struct_bases=[],
    name_mapping={
        "gmsa_credential_spec": "gmsaCredentialSpec",
        "gmsa_credential_spec_name": "gmsaCredentialSpecName",
        "run_as_user_name": "runAsUserName",
    },
)
class TenantV2SpecSideCarsContainersSecurityContextWindowsOptions:
    def __init__(
        self,
        *,
        gmsa_credential_spec: typing.Optional[builtins.str] = None,
        gmsa_credential_spec_name: typing.Optional[builtins.str] = None,
        run_as_user_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gmsa_credential_spec: 
        :param gmsa_credential_spec_name: 
        :param run_as_user_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextWindowsOptions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersSecurityContextWindowsOptions.__init__)
            check_type(argname="argument gmsa_credential_spec", value=gmsa_credential_spec, expected_type=type_hints["gmsa_credential_spec"])
            check_type(argname="argument gmsa_credential_spec_name", value=gmsa_credential_spec_name, expected_type=type_hints["gmsa_credential_spec_name"])
            check_type(argname="argument run_as_user_name", value=run_as_user_name, expected_type=type_hints["run_as_user_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if gmsa_credential_spec is not None:
            self._values["gmsa_credential_spec"] = gmsa_credential_spec
        if gmsa_credential_spec_name is not None:
            self._values["gmsa_credential_spec_name"] = gmsa_credential_spec_name
        if run_as_user_name is not None:
            self._values["run_as_user_name"] = run_as_user_name

    @builtins.property
    def gmsa_credential_spec(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextWindowsOptions#gmsaCredentialSpec
        '''
        result = self._values.get("gmsa_credential_spec")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gmsa_credential_spec_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
        '''
        result = self._values.get("gmsa_credential_spec_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run_as_user_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersSecurityContextWindowsOptions#runAsUserName
        '''
        result = self._values.get("run_as_user_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersSecurityContextWindowsOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbe",
    jsii_struct_bases=[],
    name_mapping={
        "exec": "exec",
        "failure_threshold": "failureThreshold",
        "http_get": "httpGet",
        "initial_delay_seconds": "initialDelaySeconds",
        "period_seconds": "periodSeconds",
        "success_threshold": "successThreshold",
        "tcp_socket": "tcpSocket",
        "timeout_seconds": "timeoutSeconds",
    },
)
class TenantV2SpecSideCarsContainersStartupProbe:
    def __init__(
        self,
        *,
        exec: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersStartupProbeExec", typing.Dict[str, typing.Any]]] = None,
        failure_threshold: typing.Optional[jsii.Number] = None,
        http_get: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersStartupProbeHttpGet", typing.Dict[str, typing.Any]]] = None,
        initial_delay_seconds: typing.Optional[jsii.Number] = None,
        period_seconds: typing.Optional[jsii.Number] = None,
        success_threshold: typing.Optional[jsii.Number] = None,
        tcp_socket: typing.Optional[typing.Union["TenantV2SpecSideCarsContainersStartupProbeTcpSocket", typing.Dict[str, typing.Any]]] = None,
        timeout_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param exec: 
        :param failure_threshold: 
        :param http_get: 
        :param initial_delay_seconds: 
        :param period_seconds: 
        :param success_threshold: 
        :param tcp_socket: 
        :param timeout_seconds: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe
        '''
        if isinstance(exec, dict):
            exec = TenantV2SpecSideCarsContainersStartupProbeExec(**exec)
        if isinstance(http_get, dict):
            http_get = TenantV2SpecSideCarsContainersStartupProbeHttpGet(**http_get)
        if isinstance(tcp_socket, dict):
            tcp_socket = TenantV2SpecSideCarsContainersStartupProbeTcpSocket(**tcp_socket)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbe.__init__)
            check_type(argname="argument exec", value=exec, expected_type=type_hints["exec"])
            check_type(argname="argument failure_threshold", value=failure_threshold, expected_type=type_hints["failure_threshold"])
            check_type(argname="argument http_get", value=http_get, expected_type=type_hints["http_get"])
            check_type(argname="argument initial_delay_seconds", value=initial_delay_seconds, expected_type=type_hints["initial_delay_seconds"])
            check_type(argname="argument period_seconds", value=period_seconds, expected_type=type_hints["period_seconds"])
            check_type(argname="argument success_threshold", value=success_threshold, expected_type=type_hints["success_threshold"])
            check_type(argname="argument tcp_socket", value=tcp_socket, expected_type=type_hints["tcp_socket"])
            check_type(argname="argument timeout_seconds", value=timeout_seconds, expected_type=type_hints["timeout_seconds"])
        self._values: typing.Dict[str, typing.Any] = {}
        if exec is not None:
            self._values["exec"] = exec
        if failure_threshold is not None:
            self._values["failure_threshold"] = failure_threshold
        if http_get is not None:
            self._values["http_get"] = http_get
        if initial_delay_seconds is not None:
            self._values["initial_delay_seconds"] = initial_delay_seconds
        if period_seconds is not None:
            self._values["period_seconds"] = period_seconds
        if success_threshold is not None:
            self._values["success_threshold"] = success_threshold
        if tcp_socket is not None:
            self._values["tcp_socket"] = tcp_socket
        if timeout_seconds is not None:
            self._values["timeout_seconds"] = timeout_seconds

    @builtins.property
    def exec(self) -> typing.Optional["TenantV2SpecSideCarsContainersStartupProbeExec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#exec
        '''
        result = self._values.get("exec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersStartupProbeExec"], result)

    @builtins.property
    def failure_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#failureThreshold
        '''
        result = self._values.get("failure_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def http_get(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersStartupProbeHttpGet"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#httpGet
        '''
        result = self._values.get("http_get")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersStartupProbeHttpGet"], result)

    @builtins.property
    def initial_delay_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#initialDelaySeconds
        '''
        result = self._values.get("initial_delay_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#periodSeconds
        '''
        result = self._values.get("period_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def success_threshold(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#successThreshold
        '''
        result = self._values.get("success_threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tcp_socket(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsContainersStartupProbeTcpSocket"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#tcpSocket
        '''
        result = self._values.get("tcp_socket")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsContainersStartupProbeTcpSocket"], result)

    @builtins.property
    def timeout_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbe#timeoutSeconds
        '''
        result = self._values.get("timeout_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersStartupProbe(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeExec",
    jsii_struct_bases=[],
    name_mapping={"command": "command"},
)
class TenantV2SpecSideCarsContainersStartupProbeExec:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param command: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeExec
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeExec.__init__)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
        self._values: typing.Dict[str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeExec#command
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersStartupProbeExec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeHttpGet",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "host": "host",
        "http_headers": "httpHeaders",
        "path": "path",
        "scheme": "scheme",
    },
)
class TenantV2SpecSideCarsContainersStartupProbeHttpGet:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersStartupProbeHttpGetPort",
        host: typing.Optional[builtins.str] = None,
        http_headers: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders", typing.Dict[str, typing.Any]]]] = None,
        path: typing.Optional[builtins.str] = None,
        scheme: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 
        :param http_headers: 
        :param path: 
        :param scheme: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeHttpGet.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
            check_type(argname="argument http_headers", value=http_headers, expected_type=type_hints["http_headers"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument scheme", value=scheme, expected_type=type_hints["scheme"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host
        if http_headers is not None:
            self._values["http_headers"] = http_headers
        if path is not None:
            self._values["path"] = path
        if scheme is not None:
            self._values["scheme"] = scheme

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeHttpGetPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def http_headers(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet#httpHeaders
        '''
        result = self._values.get("http_headers")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders"]], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def scheme(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGet#scheme
        '''
        result = self._values.get("scheme")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersStartupProbeHttpGet(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "value": "value"},
)
class TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders:
    def __init__(self, *, name: builtins.str, value: builtins.str) -> None:
        '''
        :param name: 
        :param value: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "value": value,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersStartupProbeHttpGetPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeHttpGetPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersStartupProbeHttpGetPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeHttpGetPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeHttpGetPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersStartupProbeHttpGetPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeHttpGetPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeHttpGetPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeTcpSocket",
    jsii_struct_bases=[],
    name_mapping={"port": "port", "host": "host"},
)
class TenantV2SpecSideCarsContainersStartupProbeTcpSocket:
    def __init__(
        self,
        *,
        port: "TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort",
        host: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param port: 
        :param host: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeTcpSocket
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeTcpSocket.__init__)
            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
        }
        if host is not None:
            self._values["host"] = host

    @builtins.property
    def port(self) -> "TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeTcpSocket#port
        '''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort", result)

    @builtins.property
    def host(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersStartupProbeTcpSocket#host
        '''
        result = self._values.get("host")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersStartupProbeTcpSocket(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersVolumeDevices",
    jsii_struct_bases=[],
    name_mapping={"device_path": "devicePath", "name": "name"},
)
class TenantV2SpecSideCarsContainersVolumeDevices:
    def __init__(self, *, device_path: builtins.str, name: builtins.str) -> None:
        '''
        :param device_path: 
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeDevices
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersVolumeDevices.__init__)
            check_type(argname="argument device_path", value=device_path, expected_type=type_hints["device_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "device_path": device_path,
            "name": name,
        }

    @builtins.property
    def device_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeDevices#devicePath
        '''
        result = self._values.get("device_path")
        assert result is not None, "Required property 'device_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeDevices#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersVolumeDevices(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsContainersVolumeMounts",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "name": "name",
        "mount_propagation": "mountPropagation",
        "read_only": "readOnly",
        "sub_path": "subPath",
        "sub_path_expr": "subPathExpr",
    },
)
class TenantV2SpecSideCarsContainersVolumeMounts:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        name: builtins.str,
        mount_propagation: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        sub_path: typing.Optional[builtins.str] = None,
        sub_path_expr: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param mount_path: 
        :param name: 
        :param mount_propagation: 
        :param read_only: 
        :param sub_path: 
        :param sub_path_expr: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsContainersVolumeMounts.__init__)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument mount_propagation", value=mount_propagation, expected_type=type_hints["mount_propagation"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument sub_path", value=sub_path, expected_type=type_hints["sub_path"])
            check_type(argname="argument sub_path_expr", value=sub_path_expr, expected_type=type_hints["sub_path_expr"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "name": name,
        }
        if mount_propagation is not None:
            self._values["mount_propagation"] = mount_propagation
        if read_only is not None:
            self._values["read_only"] = read_only
        if sub_path is not None:
            self._values["sub_path"] = sub_path
        if sub_path_expr is not None:
            self._values["sub_path_expr"] = sub_path_expr

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mount_propagation(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#mountPropagation
        '''
        result = self._values.get("mount_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def sub_path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#subPath
        '''
        result = self._values.get("sub_path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def sub_path_expr(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsContainersVolumeMounts#subPathExpr
        '''
        result = self._values.get("sub_path_expr")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsContainersVolumeMounts(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplates",
    jsii_struct_bases=[],
    name_mapping={
        "api_version": "apiVersion",
        "kind": "kind",
        "metadata": "metadata",
        "spec": "spec",
        "status": "status",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplates:
    def __init__(
        self,
        *,
        api_version: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesMetadata", typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesSpec", typing.Dict[str, typing.Any]]] = None,
        status: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesStatus", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param api_version: 
        :param kind: 
        :param metadata: 
        :param spec: 
        :param status: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates
        '''
        if isinstance(metadata, dict):
            metadata = TenantV2SpecSideCarsVolumeClaimTemplatesMetadata(**metadata)
        if isinstance(spec, dict):
            spec = TenantV2SpecSideCarsVolumeClaimTemplatesSpec(**spec)
        if isinstance(status, dict):
            status = TenantV2SpecSideCarsVolumeClaimTemplatesStatus(**status)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplates.__init__)
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {}
        if api_version is not None:
            self._values["api_version"] = api_version
        if kind is not None:
            self._values["kind"] = kind
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec
        if status is not None:
            self._values["status"] = status

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesMetadata"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesMetadata"], result)

    @builtins.property
    def spec(self) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpec"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpec"], result)

    @builtins.property
    def status(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesStatus"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplates#status
        '''
        result = self._values.get("status")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesStatus"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplates(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplatesMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplatesSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesStatus",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "capacity": "capacity",
        "conditions": "conditions",
        "phase": "phase",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplatesStatus:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        capacity: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity"]] = None,
        conditions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions", typing.Dict[str, typing.Any]]]] = None,
        phase: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param capacity: 
        :param conditions: 
        :param phase: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatus
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesStatus.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument capacity", value=capacity, expected_type=type_hints["capacity"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument phase", value=phase, expected_type=type_hints["phase"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if capacity is not None:
            self._values["capacity"] = capacity
        if conditions is not None:
            self._values["conditions"] = conditions
        if phase is not None:
            self._values["phase"] = phase

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatus#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def capacity(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatus#capacity
        '''
        result = self._values.get("capacity")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity"]], result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatus#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions"]], result)

    @builtins.property
    def phase(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatus#phase
        '''
        result = self._values.get("phase")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesStatus(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions",
    jsii_struct_bases=[],
    name_mapping={
        "status": "status",
        "type": "type",
        "last_probe_time": "lastProbeTime",
        "last_transition_time": "lastTransitionTime",
        "message": "message",
        "reason": "reason",
    },
)
class TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions:
    def __init__(
        self,
        *,
        status: builtins.str,
        type: builtins.str,
        last_probe_time: typing.Optional[datetime.datetime] = None,
        last_transition_time: typing.Optional[datetime.datetime] = None,
        message: typing.Optional[builtins.str] = None,
        reason: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param status: 
        :param type: 
        :param last_probe_time: 
        :param last_transition_time: 
        :param message: 
        :param reason: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions.__init__)
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument last_probe_time", value=last_probe_time, expected_type=type_hints["last_probe_time"])
            check_type(argname="argument last_transition_time", value=last_transition_time, expected_type=type_hints["last_transition_time"])
            check_type(argname="argument message", value=message, expected_type=type_hints["message"])
            check_type(argname="argument reason", value=reason, expected_type=type_hints["reason"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
            "type": type,
        }
        if last_probe_time is not None:
            self._values["last_probe_time"] = last_probe_time
        if last_transition_time is not None:
            self._values["last_transition_time"] = last_transition_time
        if message is not None:
            self._values["message"] = message
        if reason is not None:
            self._values["reason"] = reason

    @builtins.property
    def status(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#status
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def last_probe_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#lastProbeTime
        '''
        result = self._values.get("last_probe_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def last_transition_time(self) -> typing.Optional[datetime.datetime]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#lastTransitionTime
        '''
        result = self._values.get("last_transition_time")
        return typing.cast(typing.Optional[datetime.datetime], result)

    @builtins.property
    def message(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#message
        '''
        result = self._values.get("message")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def reason(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions#reason
        '''
        result = self._values.get("reason")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumes",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "aws_elastic_block_store": "awsElasticBlockStore",
        "azure_disk": "azureDisk",
        "azure_file": "azureFile",
        "cephfs": "cephfs",
        "cinder": "cinder",
        "config_map": "configMap",
        "csi": "csi",
        "downward_api": "downwardApi",
        "empty_dir": "emptyDir",
        "ephemeral": "ephemeral",
        "fc": "fc",
        "flex_volume": "flexVolume",
        "flocker": "flocker",
        "gce_persistent_disk": "gcePersistentDisk",
        "git_repo": "gitRepo",
        "glusterfs": "glusterfs",
        "host_path": "hostPath",
        "iscsi": "iscsi",
        "nfs": "nfs",
        "persistent_volume_claim": "persistentVolumeClaim",
        "photon_persistent_disk": "photonPersistentDisk",
        "portworx_volume": "portworxVolume",
        "projected": "projected",
        "quobyte": "quobyte",
        "rbd": "rbd",
        "scale_io": "scaleIo",
        "secret": "secret",
        "storageos": "storageos",
        "vsphere_volume": "vsphereVolume",
    },
)
class TenantV2SpecSideCarsVolumes:
    def __init__(
        self,
        *,
        name: builtins.str,
        aws_elastic_block_store: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesAwsElasticBlockStore", typing.Dict[str, typing.Any]]] = None,
        azure_disk: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesAzureDisk", typing.Dict[str, typing.Any]]] = None,
        azure_file: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesAzureFile", typing.Dict[str, typing.Any]]] = None,
        cephfs: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCephfs", typing.Dict[str, typing.Any]]] = None,
        cinder: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCinder", typing.Dict[str, typing.Any]]] = None,
        config_map: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesConfigMap", typing.Dict[str, typing.Any]]] = None,
        csi: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCsi", typing.Dict[str, typing.Any]]] = None,
        downward_api: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesDownwardApi", typing.Dict[str, typing.Any]]] = None,
        empty_dir: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEmptyDir", typing.Dict[str, typing.Any]]] = None,
        ephemeral: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeral", typing.Dict[str, typing.Any]]] = None,
        fc: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesFc", typing.Dict[str, typing.Any]]] = None,
        flex_volume: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesFlexVolume", typing.Dict[str, typing.Any]]] = None,
        flocker: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesFlocker", typing.Dict[str, typing.Any]]] = None,
        gce_persistent_disk: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesGcePersistentDisk", typing.Dict[str, typing.Any]]] = None,
        git_repo: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesGitRepo", typing.Dict[str, typing.Any]]] = None,
        glusterfs: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesGlusterfs", typing.Dict[str, typing.Any]]] = None,
        host_path: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesHostPath", typing.Dict[str, typing.Any]]] = None,
        iscsi: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesIscsi", typing.Dict[str, typing.Any]]] = None,
        nfs: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesNfs", typing.Dict[str, typing.Any]]] = None,
        persistent_volume_claim: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesPersistentVolumeClaim", typing.Dict[str, typing.Any]]] = None,
        photon_persistent_disk: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesPhotonPersistentDisk", typing.Dict[str, typing.Any]]] = None,
        portworx_volume: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesPortworxVolume", typing.Dict[str, typing.Any]]] = None,
        projected: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjected", typing.Dict[str, typing.Any]]] = None,
        quobyte: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesQuobyte", typing.Dict[str, typing.Any]]] = None,
        rbd: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesRbd", typing.Dict[str, typing.Any]]] = None,
        scale_io: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesScaleIo", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesSecret", typing.Dict[str, typing.Any]]] = None,
        storageos: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesStorageos", typing.Dict[str, typing.Any]]] = None,
        vsphere_volume: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesVsphereVolume", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param name: 
        :param aws_elastic_block_store: 
        :param azure_disk: 
        :param azure_file: 
        :param cephfs: 
        :param cinder: 
        :param config_map: 
        :param csi: 
        :param downward_api: 
        :param empty_dir: 
        :param ephemeral: 
        :param fc: 
        :param flex_volume: 
        :param flocker: 
        :param gce_persistent_disk: 
        :param git_repo: 
        :param glusterfs: 
        :param host_path: 
        :param iscsi: 
        :param nfs: 
        :param persistent_volume_claim: 
        :param photon_persistent_disk: 
        :param portworx_volume: 
        :param projected: 
        :param quobyte: 
        :param rbd: 
        :param scale_io: 
        :param secret: 
        :param storageos: 
        :param vsphere_volume: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes
        '''
        if isinstance(aws_elastic_block_store, dict):
            aws_elastic_block_store = TenantV2SpecSideCarsVolumesAwsElasticBlockStore(**aws_elastic_block_store)
        if isinstance(azure_disk, dict):
            azure_disk = TenantV2SpecSideCarsVolumesAzureDisk(**azure_disk)
        if isinstance(azure_file, dict):
            azure_file = TenantV2SpecSideCarsVolumesAzureFile(**azure_file)
        if isinstance(cephfs, dict):
            cephfs = TenantV2SpecSideCarsVolumesCephfs(**cephfs)
        if isinstance(cinder, dict):
            cinder = TenantV2SpecSideCarsVolumesCinder(**cinder)
        if isinstance(config_map, dict):
            config_map = TenantV2SpecSideCarsVolumesConfigMap(**config_map)
        if isinstance(csi, dict):
            csi = TenantV2SpecSideCarsVolumesCsi(**csi)
        if isinstance(downward_api, dict):
            downward_api = TenantV2SpecSideCarsVolumesDownwardApi(**downward_api)
        if isinstance(empty_dir, dict):
            empty_dir = TenantV2SpecSideCarsVolumesEmptyDir(**empty_dir)
        if isinstance(ephemeral, dict):
            ephemeral = TenantV2SpecSideCarsVolumesEphemeral(**ephemeral)
        if isinstance(fc, dict):
            fc = TenantV2SpecSideCarsVolumesFc(**fc)
        if isinstance(flex_volume, dict):
            flex_volume = TenantV2SpecSideCarsVolumesFlexVolume(**flex_volume)
        if isinstance(flocker, dict):
            flocker = TenantV2SpecSideCarsVolumesFlocker(**flocker)
        if isinstance(gce_persistent_disk, dict):
            gce_persistent_disk = TenantV2SpecSideCarsVolumesGcePersistentDisk(**gce_persistent_disk)
        if isinstance(git_repo, dict):
            git_repo = TenantV2SpecSideCarsVolumesGitRepo(**git_repo)
        if isinstance(glusterfs, dict):
            glusterfs = TenantV2SpecSideCarsVolumesGlusterfs(**glusterfs)
        if isinstance(host_path, dict):
            host_path = TenantV2SpecSideCarsVolumesHostPath(**host_path)
        if isinstance(iscsi, dict):
            iscsi = TenantV2SpecSideCarsVolumesIscsi(**iscsi)
        if isinstance(nfs, dict):
            nfs = TenantV2SpecSideCarsVolumesNfs(**nfs)
        if isinstance(persistent_volume_claim, dict):
            persistent_volume_claim = TenantV2SpecSideCarsVolumesPersistentVolumeClaim(**persistent_volume_claim)
        if isinstance(photon_persistent_disk, dict):
            photon_persistent_disk = TenantV2SpecSideCarsVolumesPhotonPersistentDisk(**photon_persistent_disk)
        if isinstance(portworx_volume, dict):
            portworx_volume = TenantV2SpecSideCarsVolumesPortworxVolume(**portworx_volume)
        if isinstance(projected, dict):
            projected = TenantV2SpecSideCarsVolumesProjected(**projected)
        if isinstance(quobyte, dict):
            quobyte = TenantV2SpecSideCarsVolumesQuobyte(**quobyte)
        if isinstance(rbd, dict):
            rbd = TenantV2SpecSideCarsVolumesRbd(**rbd)
        if isinstance(scale_io, dict):
            scale_io = TenantV2SpecSideCarsVolumesScaleIo(**scale_io)
        if isinstance(secret, dict):
            secret = TenantV2SpecSideCarsVolumesSecret(**secret)
        if isinstance(storageos, dict):
            storageos = TenantV2SpecSideCarsVolumesStorageos(**storageos)
        if isinstance(vsphere_volume, dict):
            vsphere_volume = TenantV2SpecSideCarsVolumesVsphereVolume(**vsphere_volume)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumes.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument aws_elastic_block_store", value=aws_elastic_block_store, expected_type=type_hints["aws_elastic_block_store"])
            check_type(argname="argument azure_disk", value=azure_disk, expected_type=type_hints["azure_disk"])
            check_type(argname="argument azure_file", value=azure_file, expected_type=type_hints["azure_file"])
            check_type(argname="argument cephfs", value=cephfs, expected_type=type_hints["cephfs"])
            check_type(argname="argument cinder", value=cinder, expected_type=type_hints["cinder"])
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument csi", value=csi, expected_type=type_hints["csi"])
            check_type(argname="argument downward_api", value=downward_api, expected_type=type_hints["downward_api"])
            check_type(argname="argument empty_dir", value=empty_dir, expected_type=type_hints["empty_dir"])
            check_type(argname="argument ephemeral", value=ephemeral, expected_type=type_hints["ephemeral"])
            check_type(argname="argument fc", value=fc, expected_type=type_hints["fc"])
            check_type(argname="argument flex_volume", value=flex_volume, expected_type=type_hints["flex_volume"])
            check_type(argname="argument flocker", value=flocker, expected_type=type_hints["flocker"])
            check_type(argname="argument gce_persistent_disk", value=gce_persistent_disk, expected_type=type_hints["gce_persistent_disk"])
            check_type(argname="argument git_repo", value=git_repo, expected_type=type_hints["git_repo"])
            check_type(argname="argument glusterfs", value=glusterfs, expected_type=type_hints["glusterfs"])
            check_type(argname="argument host_path", value=host_path, expected_type=type_hints["host_path"])
            check_type(argname="argument iscsi", value=iscsi, expected_type=type_hints["iscsi"])
            check_type(argname="argument nfs", value=nfs, expected_type=type_hints["nfs"])
            check_type(argname="argument persistent_volume_claim", value=persistent_volume_claim, expected_type=type_hints["persistent_volume_claim"])
            check_type(argname="argument photon_persistent_disk", value=photon_persistent_disk, expected_type=type_hints["photon_persistent_disk"])
            check_type(argname="argument portworx_volume", value=portworx_volume, expected_type=type_hints["portworx_volume"])
            check_type(argname="argument projected", value=projected, expected_type=type_hints["projected"])
            check_type(argname="argument quobyte", value=quobyte, expected_type=type_hints["quobyte"])
            check_type(argname="argument rbd", value=rbd, expected_type=type_hints["rbd"])
            check_type(argname="argument scale_io", value=scale_io, expected_type=type_hints["scale_io"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument storageos", value=storageos, expected_type=type_hints["storageos"])
            check_type(argname="argument vsphere_volume", value=vsphere_volume, expected_type=type_hints["vsphere_volume"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if aws_elastic_block_store is not None:
            self._values["aws_elastic_block_store"] = aws_elastic_block_store
        if azure_disk is not None:
            self._values["azure_disk"] = azure_disk
        if azure_file is not None:
            self._values["azure_file"] = azure_file
        if cephfs is not None:
            self._values["cephfs"] = cephfs
        if cinder is not None:
            self._values["cinder"] = cinder
        if config_map is not None:
            self._values["config_map"] = config_map
        if csi is not None:
            self._values["csi"] = csi
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if empty_dir is not None:
            self._values["empty_dir"] = empty_dir
        if ephemeral is not None:
            self._values["ephemeral"] = ephemeral
        if fc is not None:
            self._values["fc"] = fc
        if flex_volume is not None:
            self._values["flex_volume"] = flex_volume
        if flocker is not None:
            self._values["flocker"] = flocker
        if gce_persistent_disk is not None:
            self._values["gce_persistent_disk"] = gce_persistent_disk
        if git_repo is not None:
            self._values["git_repo"] = git_repo
        if glusterfs is not None:
            self._values["glusterfs"] = glusterfs
        if host_path is not None:
            self._values["host_path"] = host_path
        if iscsi is not None:
            self._values["iscsi"] = iscsi
        if nfs is not None:
            self._values["nfs"] = nfs
        if persistent_volume_claim is not None:
            self._values["persistent_volume_claim"] = persistent_volume_claim
        if photon_persistent_disk is not None:
            self._values["photon_persistent_disk"] = photon_persistent_disk
        if portworx_volume is not None:
            self._values["portworx_volume"] = portworx_volume
        if projected is not None:
            self._values["projected"] = projected
        if quobyte is not None:
            self._values["quobyte"] = quobyte
        if rbd is not None:
            self._values["rbd"] = rbd
        if scale_io is not None:
            self._values["scale_io"] = scale_io
        if secret is not None:
            self._values["secret"] = secret
        if storageos is not None:
            self._values["storageos"] = storageos
        if vsphere_volume is not None:
            self._values["vsphere_volume"] = vsphere_volume

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aws_elastic_block_store(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesAwsElasticBlockStore"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#awsElasticBlockStore
        '''
        result = self._values.get("aws_elastic_block_store")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesAwsElasticBlockStore"], result)

    @builtins.property
    def azure_disk(self) -> typing.Optional["TenantV2SpecSideCarsVolumesAzureDisk"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#azureDisk
        '''
        result = self._values.get("azure_disk")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesAzureDisk"], result)

    @builtins.property
    def azure_file(self) -> typing.Optional["TenantV2SpecSideCarsVolumesAzureFile"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#azureFile
        '''
        result = self._values.get("azure_file")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesAzureFile"], result)

    @builtins.property
    def cephfs(self) -> typing.Optional["TenantV2SpecSideCarsVolumesCephfs"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#cephfs
        '''
        result = self._values.get("cephfs")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCephfs"], result)

    @builtins.property
    def cinder(self) -> typing.Optional["TenantV2SpecSideCarsVolumesCinder"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#cinder
        '''
        result = self._values.get("cinder")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCinder"], result)

    @builtins.property
    def config_map(self) -> typing.Optional["TenantV2SpecSideCarsVolumesConfigMap"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesConfigMap"], result)

    @builtins.property
    def csi(self) -> typing.Optional["TenantV2SpecSideCarsVolumesCsi"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#csi
        '''
        result = self._values.get("csi")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCsi"], result)

    @builtins.property
    def downward_api(self) -> typing.Optional["TenantV2SpecSideCarsVolumesDownwardApi"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#downwardAPI
        '''
        result = self._values.get("downward_api")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesDownwardApi"], result)

    @builtins.property
    def empty_dir(self) -> typing.Optional["TenantV2SpecSideCarsVolumesEmptyDir"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#emptyDir
        '''
        result = self._values.get("empty_dir")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEmptyDir"], result)

    @builtins.property
    def ephemeral(self) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeral"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#ephemeral
        '''
        result = self._values.get("ephemeral")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeral"], result)

    @builtins.property
    def fc(self) -> typing.Optional["TenantV2SpecSideCarsVolumesFc"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#fc
        '''
        result = self._values.get("fc")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesFc"], result)

    @builtins.property
    def flex_volume(self) -> typing.Optional["TenantV2SpecSideCarsVolumesFlexVolume"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#flexVolume
        '''
        result = self._values.get("flex_volume")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesFlexVolume"], result)

    @builtins.property
    def flocker(self) -> typing.Optional["TenantV2SpecSideCarsVolumesFlocker"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#flocker
        '''
        result = self._values.get("flocker")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesFlocker"], result)

    @builtins.property
    def gce_persistent_disk(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesGcePersistentDisk"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#gcePersistentDisk
        '''
        result = self._values.get("gce_persistent_disk")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesGcePersistentDisk"], result)

    @builtins.property
    def git_repo(self) -> typing.Optional["TenantV2SpecSideCarsVolumesGitRepo"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#gitRepo
        '''
        result = self._values.get("git_repo")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesGitRepo"], result)

    @builtins.property
    def glusterfs(self) -> typing.Optional["TenantV2SpecSideCarsVolumesGlusterfs"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#glusterfs
        '''
        result = self._values.get("glusterfs")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesGlusterfs"], result)

    @builtins.property
    def host_path(self) -> typing.Optional["TenantV2SpecSideCarsVolumesHostPath"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#hostPath
        '''
        result = self._values.get("host_path")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesHostPath"], result)

    @builtins.property
    def iscsi(self) -> typing.Optional["TenantV2SpecSideCarsVolumesIscsi"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#iscsi
        '''
        result = self._values.get("iscsi")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesIscsi"], result)

    @builtins.property
    def nfs(self) -> typing.Optional["TenantV2SpecSideCarsVolumesNfs"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#nfs
        '''
        result = self._values.get("nfs")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesNfs"], result)

    @builtins.property
    def persistent_volume_claim(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesPersistentVolumeClaim"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#persistentVolumeClaim
        '''
        result = self._values.get("persistent_volume_claim")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesPersistentVolumeClaim"], result)

    @builtins.property
    def photon_persistent_disk(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesPhotonPersistentDisk"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#photonPersistentDisk
        '''
        result = self._values.get("photon_persistent_disk")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesPhotonPersistentDisk"], result)

    @builtins.property
    def portworx_volume(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesPortworxVolume"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#portworxVolume
        '''
        result = self._values.get("portworx_volume")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesPortworxVolume"], result)

    @builtins.property
    def projected(self) -> typing.Optional["TenantV2SpecSideCarsVolumesProjected"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#projected
        '''
        result = self._values.get("projected")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjected"], result)

    @builtins.property
    def quobyte(self) -> typing.Optional["TenantV2SpecSideCarsVolumesQuobyte"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#quobyte
        '''
        result = self._values.get("quobyte")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesQuobyte"], result)

    @builtins.property
    def rbd(self) -> typing.Optional["TenantV2SpecSideCarsVolumesRbd"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#rbd
        '''
        result = self._values.get("rbd")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesRbd"], result)

    @builtins.property
    def scale_io(self) -> typing.Optional["TenantV2SpecSideCarsVolumesScaleIo"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#scaleIO
        '''
        result = self._values.get("scale_io")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesScaleIo"], result)

    @builtins.property
    def secret(self) -> typing.Optional["TenantV2SpecSideCarsVolumesSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesSecret"], result)

    @builtins.property
    def storageos(self) -> typing.Optional["TenantV2SpecSideCarsVolumesStorageos"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#storageos
        '''
        result = self._values.get("storageos")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesStorageos"], result)

    @builtins.property
    def vsphere_volume(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesVsphereVolume"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumes#vsphereVolume
        '''
        result = self._values.get("vsphere_volume")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesVsphereVolume"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesAwsElasticBlockStore",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class TenantV2SpecSideCarsVolumesAwsElasticBlockStore:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param partition: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAwsElasticBlockStore
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesAwsElasticBlockStore.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument partition", value=partition, expected_type=type_hints["partition"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAwsElasticBlockStore#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAwsElasticBlockStore#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAwsElasticBlockStore#partition
        '''
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAwsElasticBlockStore#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesAwsElasticBlockStore(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesAzureDisk",
    jsii_struct_bases=[],
    name_mapping={
        "disk_name": "diskName",
        "disk_uri": "diskUri",
        "caching_mode": "cachingMode",
        "fs_type": "fsType",
        "kind": "kind",
        "read_only": "readOnly",
    },
)
class TenantV2SpecSideCarsVolumesAzureDisk:
    def __init__(
        self,
        *,
        disk_name: builtins.str,
        disk_uri: builtins.str,
        caching_mode: typing.Optional[builtins.str] = None,
        fs_type: typing.Optional[builtins.str] = None,
        kind: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param disk_name: 
        :param disk_uri: 
        :param caching_mode: 
        :param fs_type: 
        :param kind: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesAzureDisk.__init__)
            check_type(argname="argument disk_name", value=disk_name, expected_type=type_hints["disk_name"])
            check_type(argname="argument disk_uri", value=disk_uri, expected_type=type_hints["disk_uri"])
            check_type(argname="argument caching_mode", value=caching_mode, expected_type=type_hints["caching_mode"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "disk_name": disk_name,
            "disk_uri": disk_uri,
        }
        if caching_mode is not None:
            self._values["caching_mode"] = caching_mode
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if kind is not None:
            self._values["kind"] = kind
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def disk_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#diskName
        '''
        result = self._values.get("disk_name")
        assert result is not None, "Required property 'disk_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def disk_uri(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#diskURI
        '''
        result = self._values.get("disk_uri")
        assert result is not None, "Required property 'disk_uri' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def caching_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#cachingMode
        '''
        result = self._values.get("caching_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureDisk#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesAzureDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesAzureFile",
    jsii_struct_bases=[],
    name_mapping={
        "secret_name": "secretName",
        "share_name": "shareName",
        "read_only": "readOnly",
    },
)
class TenantV2SpecSideCarsVolumesAzureFile:
    def __init__(
        self,
        *,
        secret_name: builtins.str,
        share_name: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param secret_name: 
        :param share_name: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureFile
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesAzureFile.__init__)
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
            check_type(argname="argument share_name", value=share_name, expected_type=type_hints["share_name"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_name": secret_name,
            "share_name": share_name,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def secret_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureFile#secretName
        '''
        result = self._values.get("secret_name")
        assert result is not None, "Required property 'secret_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def share_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureFile#shareName
        '''
        result = self._values.get("share_name")
        assert result is not None, "Required property 'share_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesAzureFile#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesAzureFile(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCephfs",
    jsii_struct_bases=[],
    name_mapping={
        "monitors": "monitors",
        "path": "path",
        "read_only": "readOnly",
        "secret_file": "secretFile",
        "secret_ref": "secretRef",
        "user": "user",
    },
)
class TenantV2SpecSideCarsVolumesCephfs:
    def __init__(
        self,
        *,
        monitors: typing.Sequence[builtins.str],
        path: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_file: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCephfsSecretRef", typing.Dict[str, typing.Any]]] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param monitors: 
        :param path: 
        :param read_only: 
        :param secret_file: 
        :param secret_ref: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesCephfsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCephfs.__init__)
            check_type(argname="argument monitors", value=monitors, expected_type=type_hints["monitors"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_file", value=secret_file, expected_type=type_hints["secret_file"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "monitors": monitors,
        }
        if path is not None:
            self._values["path"] = path
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_file is not None:
            self._values["secret_file"] = secret_file
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def monitors(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#monitors
        '''
        result = self._values.get("monitors")
        assert result is not None, "Required property 'monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_file(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#secretFile
        '''
        result = self._values.get("secret_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesCephfsSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCephfsSecretRef"], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfs#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCephfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCephfsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesCephfsSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCephfsSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCephfsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCephfsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCinder",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantV2SpecSideCarsVolumesCinder:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCinderSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinder
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesCinderSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCinder.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinder#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinder#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinder#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesCinderSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinder#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCinderSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCinder(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCinderSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesCinderSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinderSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCinderSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCinderSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCinderSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesConfigMap",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "name": "name",
        "optional": "optional",
    },
)
class TenantV2SpecSideCarsVolumesConfigMap:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesConfigMapItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesConfigMap.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMap#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesConfigMapItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMap#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesConfigMapItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMap#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMap#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantV2SpecSideCarsVolumesConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesConfigMapItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMapItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesConfigMapItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCsi",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "node_publish_secret_ref": "nodePublishSecretRef",
        "read_only": "readOnly",
        "volume_attributes": "volumeAttributes",
    },
)
class TenantV2SpecSideCarsVolumesCsi:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        node_publish_secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef", typing.Dict[str, typing.Any]]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        volume_attributes: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param driver: 
        :param fs_type: 
        :param node_publish_secret_ref: 
        :param read_only: 
        :param volume_attributes: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi
        '''
        if isinstance(node_publish_secret_ref, dict):
            node_publish_secret_ref = TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef(**node_publish_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCsi.__init__)
            check_type(argname="argument driver", value=driver, expected_type=type_hints["driver"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument node_publish_secret_ref", value=node_publish_secret_ref, expected_type=type_hints["node_publish_secret_ref"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument volume_attributes", value=volume_attributes, expected_type=type_hints["volume_attributes"])
        self._values: typing.Dict[str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if node_publish_secret_ref is not None:
            self._values["node_publish_secret_ref"] = node_publish_secret_ref
        if read_only is not None:
            self._values["read_only"] = read_only
        if volume_attributes is not None:
            self._values["volume_attributes"] = volume_attributes

    @builtins.property
    def driver(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi#driver
        '''
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def node_publish_secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi#nodePublishSecretRef
        '''
        result = self._values.get("node_publish_secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef"], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_attributes(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsi#volumeAttributes
        '''
        result = self._values.get("volume_attributes")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"default_mode": "defaultMode", "items": "items"},
)
class TenantV2SpecSideCarsVolumesDownwardApi:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesDownwardApiItems", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApi
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApi.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApi#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesDownwardApiItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApi#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesDownwardApiItems"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesDownwardApi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "field_ref": "fieldRef",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class TenantV2SpecSideCarsVolumesDownwardApiItems:
    def __init__(
        self,
        *,
        path: builtins.str,
        field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef", typing.Dict[str, typing.Any]]] = None,
        mode: typing.Optional[jsii.Number] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param path: 
        :param field_ref: 
        :param mode: 
        :param resource_field_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItems
        '''
        if isinstance(field_ref, dict):
            field_ref = TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef(**resource_field_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApiItems.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItems#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef"], result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItems#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesDownwardApiItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEmptyDir",
    jsii_struct_bases=[],
    name_mapping={"medium": "medium", "size_limit": "sizeLimit"},
)
class TenantV2SpecSideCarsVolumesEmptyDir:
    def __init__(
        self,
        *,
        medium: typing.Optional[builtins.str] = None,
        size_limit: typing.Optional["TenantV2SpecSideCarsVolumesEmptyDirSizeLimit"] = None,
    ) -> None:
        '''
        :param medium: 
        :param size_limit: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEmptyDir
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEmptyDir.__init__)
            check_type(argname="argument medium", value=medium, expected_type=type_hints["medium"])
            check_type(argname="argument size_limit", value=size_limit, expected_type=type_hints["size_limit"])
        self._values: typing.Dict[str, typing.Any] = {}
        if medium is not None:
            self._values["medium"] = medium
        if size_limit is not None:
            self._values["size_limit"] = size_limit

    @builtins.property
    def medium(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEmptyDir#medium
        '''
        result = self._values.get("medium")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def size_limit(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEmptyDirSizeLimit"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEmptyDir#sizeLimit
        '''
        result = self._values.get("size_limit")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEmptyDirSizeLimit"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEmptyDir(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumesEmptyDirSizeLimit(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEmptyDirSizeLimit",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumesEmptyDirSizeLimit
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumesEmptyDirSizeLimit":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEmptyDirSizeLimit.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEmptyDirSizeLimit", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumesEmptyDirSizeLimit":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEmptyDirSizeLimit.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEmptyDirSizeLimit", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeral",
    jsii_struct_bases=[],
    name_mapping={
        "read_only": "readOnly",
        "volume_claim_template": "volumeClaimTemplate",
    },
)
class TenantV2SpecSideCarsVolumesEphemeral:
    def __init__(
        self,
        *,
        read_only: typing.Optional[builtins.bool] = None,
        volume_claim_template: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param read_only: 
        :param volume_claim_template: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeral
        '''
        if isinstance(volume_claim_template, dict):
            volume_claim_template = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate(**volume_claim_template)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeral.__init__)
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument volume_claim_template", value=volume_claim_template, expected_type=type_hints["volume_claim_template"])
        self._values: typing.Dict[str, typing.Any] = {}
        if read_only is not None:
            self._values["read_only"] = read_only
        if volume_claim_template is not None:
            self._values["volume_claim_template"] = volume_claim_template

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeral#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def volume_claim_template(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeral#volumeClaimTemplate
        '''
        result = self._values.get("volume_claim_template")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeral(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate",
    jsii_struct_bases=[],
    name_mapping={"spec": "spec", "metadata": "metadata"},
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate:
    def __init__(
        self,
        *,
        spec: typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec", typing.Dict[str, typing.Any]],
        metadata: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param spec: 
        :param metadata: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate
        '''
        if isinstance(spec, dict):
            spec = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec(**spec)
        if isinstance(metadata, dict):
            metadata = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate.__init__)
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[str, typing.Any] = {
            "spec": spec,
        }
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def spec(self) -> "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate#spec
        '''
        result = self._values.get("spec")
        assert result is not None, "Required property 'spec' is missing"
        return typing.cast("TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec", result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "finalizers": "finalizers",
        "labels": "labels",
        "name": "name",
        "namespace": "namespace",
    },
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        finalizers: typing.Optional[typing.Sequence[builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param annotations: 
        :param finalizers: 
        :param labels: 
        :param name: 
        :param namespace: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument finalizers", value=finalizers, expected_type=type_hints["finalizers"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if finalizers is not None:
            self._values["finalizers"] = finalizers
        if labels is not None:
            self._values["labels"] = labels
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def finalizers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#finalizers
        '''
        result = self._values.get("finalizers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec",
    jsii_struct_bases=[],
    name_mapping={
        "access_modes": "accessModes",
        "data_source": "dataSource",
        "resources": "resources",
        "selector": "selector",
        "storage_class_name": "storageClassName",
        "volume_mode": "volumeMode",
        "volume_name": "volumeName",
    },
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec:
    def __init__(
        self,
        *,
        access_modes: typing.Optional[typing.Sequence[builtins.str]] = None,
        data_source: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource", typing.Dict[str, typing.Any]]] = None,
        resources: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources", typing.Dict[str, typing.Any]]] = None,
        selector: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector", typing.Dict[str, typing.Any]]] = None,
        storage_class_name: typing.Optional[builtins.str] = None,
        volume_mode: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param access_modes: 
        :param data_source: 
        :param resources: 
        :param selector: 
        :param storage_class_name: 
        :param volume_mode: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec
        '''
        if isinstance(data_source, dict):
            data_source = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource(**data_source)
        if isinstance(resources, dict):
            resources = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources(**resources)
        if isinstance(selector, dict):
            selector = TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector(**selector)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec.__init__)
            check_type(argname="argument access_modes", value=access_modes, expected_type=type_hints["access_modes"])
            check_type(argname="argument data_source", value=data_source, expected_type=type_hints["data_source"])
            check_type(argname="argument resources", value=resources, expected_type=type_hints["resources"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument storage_class_name", value=storage_class_name, expected_type=type_hints["storage_class_name"])
            check_type(argname="argument volume_mode", value=volume_mode, expected_type=type_hints["volume_mode"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_modes is not None:
            self._values["access_modes"] = access_modes
        if data_source is not None:
            self._values["data_source"] = data_source
        if resources is not None:
            self._values["resources"] = resources
        if selector is not None:
            self._values["selector"] = selector
        if storage_class_name is not None:
            self._values["storage_class_name"] = storage_class_name
        if volume_mode is not None:
            self._values["volume_mode"] = volume_mode
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def access_modes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#accessModes
        '''
        result = self._values.get("access_modes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def data_source(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#dataSource
        '''
        result = self._values.get("data_source")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource"], result)

    @builtins.property
    def resources(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#resources
        '''
        result = self._values.get("resources")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources"], result)

    @builtins.property
    def selector(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#selector
        '''
        result = self._values.get("selector")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector"], result)

    @builtins.property
    def storage_class_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
        '''
        result = self._values.get("storage_class_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
        '''
        result = self._values.get("volume_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_group": "apiGroup"},
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource:
    def __init__(
        self,
        *,
        kind: builtins.str,
        name: builtins.str,
        api_group: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: 
        :param name: 
        :param api_group: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource.__init__)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_group", value=api_group, expected_type=type_hints["api_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_group is not None:
            self._values["api_group"] = api_group

    @builtins.property
    def kind(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
        '''
        result = self._values.get("api_group")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources",
    jsii_struct_bases=[],
    name_mapping={"limits": "limits", "requests": "requests"},
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources:
    def __init__(
        self,
        *,
        limits: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]] = None,
        requests: typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]] = None,
    ) -> None:
        '''
        :param limits: 
        :param requests: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources.__init__)
            check_type(argname="argument limits", value=limits, expected_type=type_hints["limits"])
            check_type(argname="argument requests", value=requests, expected_type=type_hints["requests"])
        self._values: typing.Dict[str, typing.Any] = {}
        if limits is not None:
            self._values["limits"] = limits
        if requests is not None:
            self._values["requests"] = requests

    @builtins.property
    def limits(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources#limits
        '''
        result = self._values.get("limits")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits"]], result)

    @builtins.property
    def requests(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources#requests
        '''
        result = self._values.get("requests")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param match_expressions: 
        :param match_labels: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector.__init__)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param key: 
        :param operator: 
        :param values: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesFc",
    jsii_struct_bases=[],
    name_mapping={
        "fs_type": "fsType",
        "lun": "lun",
        "read_only": "readOnly",
        "target_ww_ns": "targetWwNs",
        "wwids": "wwids",
    },
)
class TenantV2SpecSideCarsVolumesFc:
    def __init__(
        self,
        *,
        fs_type: typing.Optional[builtins.str] = None,
        lun: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
        target_ww_ns: typing.Optional[typing.Sequence[builtins.str]] = None,
        wwids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param fs_type: 
        :param lun: 
        :param read_only: 
        :param target_ww_ns: 
        :param wwids: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesFc.__init__)
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument lun", value=lun, expected_type=type_hints["lun"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument target_ww_ns", value=target_ww_ns, expected_type=type_hints["target_ww_ns"])
            check_type(argname="argument wwids", value=wwids, expected_type=type_hints["wwids"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if lun is not None:
            self._values["lun"] = lun
        if read_only is not None:
            self._values["read_only"] = read_only
        if target_ww_ns is not None:
            self._values["target_ww_ns"] = target_ww_ns
        if wwids is not None:
            self._values["wwids"] = wwids

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def lun(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc#lun
        '''
        result = self._values.get("lun")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def target_ww_ns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc#targetWWNs
        '''
        result = self._values.get("target_ww_ns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def wwids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFc#wwids
        '''
        result = self._values.get("wwids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesFc(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesFlexVolume",
    jsii_struct_bases=[],
    name_mapping={
        "driver": "driver",
        "fs_type": "fsType",
        "options": "options",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantV2SpecSideCarsVolumesFlexVolume:
    def __init__(
        self,
        *,
        driver: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        options: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesFlexVolumeSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param driver: 
        :param fs_type: 
        :param options: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesFlexVolumeSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesFlexVolume.__init__)
            check_type(argname="argument driver", value=driver, expected_type=type_hints["driver"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "driver": driver,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if options is not None:
            self._values["options"] = options
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def driver(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume#driver
        '''
        result = self._values.get("driver")
        assert result is not None, "Required property 'driver' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def options(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume#options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesFlexVolumeSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolume#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesFlexVolumeSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesFlexVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesFlexVolumeSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesFlexVolumeSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolumeSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesFlexVolumeSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlexVolumeSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesFlexVolumeSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesFlocker",
    jsii_struct_bases=[],
    name_mapping={"dataset_name": "datasetName", "dataset_uuid": "datasetUuid"},
)
class TenantV2SpecSideCarsVolumesFlocker:
    def __init__(
        self,
        *,
        dataset_name: typing.Optional[builtins.str] = None,
        dataset_uuid: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param dataset_name: 
        :param dataset_uuid: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlocker
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesFlocker.__init__)
            check_type(argname="argument dataset_name", value=dataset_name, expected_type=type_hints["dataset_name"])
            check_type(argname="argument dataset_uuid", value=dataset_uuid, expected_type=type_hints["dataset_uuid"])
        self._values: typing.Dict[str, typing.Any] = {}
        if dataset_name is not None:
            self._values["dataset_name"] = dataset_name
        if dataset_uuid is not None:
            self._values["dataset_uuid"] = dataset_uuid

    @builtins.property
    def dataset_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlocker#datasetName
        '''
        result = self._values.get("dataset_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dataset_uuid(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesFlocker#datasetUUID
        '''
        result = self._values.get("dataset_uuid")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesFlocker(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesGcePersistentDisk",
    jsii_struct_bases=[],
    name_mapping={
        "pd_name": "pdName",
        "fs_type": "fsType",
        "partition": "partition",
        "read_only": "readOnly",
    },
)
class TenantV2SpecSideCarsVolumesGcePersistentDisk:
    def __init__(
        self,
        *,
        pd_name: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        partition: typing.Optional[jsii.Number] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param pd_name: 
        :param fs_type: 
        :param partition: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGcePersistentDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesGcePersistentDisk.__init__)
            check_type(argname="argument pd_name", value=pd_name, expected_type=type_hints["pd_name"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument partition", value=partition, expected_type=type_hints["partition"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "pd_name": pd_name,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if partition is not None:
            self._values["partition"] = partition
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def pd_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGcePersistentDisk#pdName
        '''
        result = self._values.get("pd_name")
        assert result is not None, "Required property 'pd_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGcePersistentDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def partition(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGcePersistentDisk#partition
        '''
        result = self._values.get("partition")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGcePersistentDisk#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesGcePersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesGitRepo",
    jsii_struct_bases=[],
    name_mapping={
        "repository": "repository",
        "directory": "directory",
        "revision": "revision",
    },
)
class TenantV2SpecSideCarsVolumesGitRepo:
    def __init__(
        self,
        *,
        repository: builtins.str,
        directory: typing.Optional[builtins.str] = None,
        revision: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param repository: 
        :param directory: 
        :param revision: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGitRepo
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesGitRepo.__init__)
            check_type(argname="argument repository", value=repository, expected_type=type_hints["repository"])
            check_type(argname="argument directory", value=directory, expected_type=type_hints["directory"])
            check_type(argname="argument revision", value=revision, expected_type=type_hints["revision"])
        self._values: typing.Dict[str, typing.Any] = {
            "repository": repository,
        }
        if directory is not None:
            self._values["directory"] = directory
        if revision is not None:
            self._values["revision"] = revision

    @builtins.property
    def repository(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGitRepo#repository
        '''
        result = self._values.get("repository")
        assert result is not None, "Required property 'repository' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def directory(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGitRepo#directory
        '''
        result = self._values.get("directory")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def revision(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGitRepo#revision
        '''
        result = self._values.get("revision")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesGitRepo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesGlusterfs",
    jsii_struct_bases=[],
    name_mapping={"endpoints": "endpoints", "path": "path", "read_only": "readOnly"},
)
class TenantV2SpecSideCarsVolumesGlusterfs:
    def __init__(
        self,
        *,
        endpoints: builtins.str,
        path: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param endpoints: 
        :param path: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGlusterfs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesGlusterfs.__init__)
            check_type(argname="argument endpoints", value=endpoints, expected_type=type_hints["endpoints"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "endpoints": endpoints,
            "path": path,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def endpoints(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGlusterfs#endpoints
        '''
        result = self._values.get("endpoints")
        assert result is not None, "Required property 'endpoints' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGlusterfs#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesGlusterfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesGlusterfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesHostPath",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "type": "type"},
)
class TenantV2SpecSideCarsVolumesHostPath:
    def __init__(
        self,
        *,
        path: builtins.str,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param path: 
        :param type: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesHostPath
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesHostPath.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesHostPath#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesHostPath#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesHostPath(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesIscsi",
    jsii_struct_bases=[],
    name_mapping={
        "iqn": "iqn",
        "lun": "lun",
        "target_portal": "targetPortal",
        "chap_auth_discovery": "chapAuthDiscovery",
        "chap_auth_session": "chapAuthSession",
        "fs_type": "fsType",
        "initiator_name": "initiatorName",
        "iscsi_interface": "iscsiInterface",
        "portals": "portals",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
    },
)
class TenantV2SpecSideCarsVolumesIscsi:
    def __init__(
        self,
        *,
        iqn: builtins.str,
        lun: jsii.Number,
        target_portal: builtins.str,
        chap_auth_discovery: typing.Optional[builtins.bool] = None,
        chap_auth_session: typing.Optional[builtins.bool] = None,
        fs_type: typing.Optional[builtins.str] = None,
        initiator_name: typing.Optional[builtins.str] = None,
        iscsi_interface: typing.Optional[builtins.str] = None,
        portals: typing.Optional[typing.Sequence[builtins.str]] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesIscsiSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param iqn: 
        :param lun: 
        :param target_portal: 
        :param chap_auth_discovery: 
        :param chap_auth_session: 
        :param fs_type: 
        :param initiator_name: 
        :param iscsi_interface: 
        :param portals: 
        :param read_only: 
        :param secret_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesIscsiSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesIscsi.__init__)
            check_type(argname="argument iqn", value=iqn, expected_type=type_hints["iqn"])
            check_type(argname="argument lun", value=lun, expected_type=type_hints["lun"])
            check_type(argname="argument target_portal", value=target_portal, expected_type=type_hints["target_portal"])
            check_type(argname="argument chap_auth_discovery", value=chap_auth_discovery, expected_type=type_hints["chap_auth_discovery"])
            check_type(argname="argument chap_auth_session", value=chap_auth_session, expected_type=type_hints["chap_auth_session"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument initiator_name", value=initiator_name, expected_type=type_hints["initiator_name"])
            check_type(argname="argument iscsi_interface", value=iscsi_interface, expected_type=type_hints["iscsi_interface"])
            check_type(argname="argument portals", value=portals, expected_type=type_hints["portals"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "iqn": iqn,
            "lun": lun,
            "target_portal": target_portal,
        }
        if chap_auth_discovery is not None:
            self._values["chap_auth_discovery"] = chap_auth_discovery
        if chap_auth_session is not None:
            self._values["chap_auth_session"] = chap_auth_session
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if initiator_name is not None:
            self._values["initiator_name"] = initiator_name
        if iscsi_interface is not None:
            self._values["iscsi_interface"] = iscsi_interface
        if portals is not None:
            self._values["portals"] = portals
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def iqn(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#iqn
        '''
        result = self._values.get("iqn")
        assert result is not None, "Required property 'iqn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def lun(self) -> jsii.Number:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#lun
        '''
        result = self._values.get("lun")
        assert result is not None, "Required property 'lun' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def target_portal(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#targetPortal
        '''
        result = self._values.get("target_portal")
        assert result is not None, "Required property 'target_portal' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def chap_auth_discovery(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#chapAuthDiscovery
        '''
        result = self._values.get("chap_auth_discovery")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def chap_auth_session(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#chapAuthSession
        '''
        result = self._values.get("chap_auth_session")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def initiator_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#initiatorName
        '''
        result = self._values.get("initiator_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iscsi_interface(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#iscsiInterface
        '''
        result = self._values.get("iscsi_interface")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def portals(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#portals
        '''
        result = self._values.get("portals")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesIscsiSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsi#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesIscsiSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesIscsi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesIscsiSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesIscsiSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsiSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesIscsiSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesIscsiSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesIscsiSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesNfs",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "server": "server", "read_only": "readOnly"},
)
class TenantV2SpecSideCarsVolumesNfs:
    def __init__(
        self,
        *,
        path: builtins.str,
        server: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param path: 
        :param server: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesNfs
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesNfs.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "server": server,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesNfs#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesNfs#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesNfs#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesNfs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesPersistentVolumeClaim",
    jsii_struct_bases=[],
    name_mapping={"claim_name": "claimName", "read_only": "readOnly"},
)
class TenantV2SpecSideCarsVolumesPersistentVolumeClaim:
    def __init__(
        self,
        *,
        claim_name: builtins.str,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param claim_name: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPersistentVolumeClaim
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesPersistentVolumeClaim.__init__)
            check_type(argname="argument claim_name", value=claim_name, expected_type=type_hints["claim_name"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "claim_name": claim_name,
        }
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def claim_name(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPersistentVolumeClaim#claimName
        '''
        result = self._values.get("claim_name")
        assert result is not None, "Required property 'claim_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPersistentVolumeClaim#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesPersistentVolumeClaim(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesPhotonPersistentDisk",
    jsii_struct_bases=[],
    name_mapping={"pd_id": "pdId", "fs_type": "fsType"},
)
class TenantV2SpecSideCarsVolumesPhotonPersistentDisk:
    def __init__(
        self,
        *,
        pd_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param pd_id: 
        :param fs_type: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPhotonPersistentDisk
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesPhotonPersistentDisk.__init__)
            check_type(argname="argument pd_id", value=pd_id, expected_type=type_hints["pd_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
        self._values: typing.Dict[str, typing.Any] = {
            "pd_id": pd_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type

    @builtins.property
    def pd_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPhotonPersistentDisk#pdID
        '''
        result = self._values.get("pd_id")
        assert result is not None, "Required property 'pd_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPhotonPersistentDisk#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesPhotonPersistentDisk(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesPortworxVolume",
    jsii_struct_bases=[],
    name_mapping={
        "volume_id": "volumeId",
        "fs_type": "fsType",
        "read_only": "readOnly",
    },
)
class TenantV2SpecSideCarsVolumesPortworxVolume:
    def __init__(
        self,
        *,
        volume_id: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param volume_id: 
        :param fs_type: 
        :param read_only: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPortworxVolume
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesPortworxVolume.__init__)
            check_type(argname="argument volume_id", value=volume_id, expected_type=type_hints["volume_id"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_id": volume_id,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPortworxVolume#volumeID
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPortworxVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesPortworxVolume#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesPortworxVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjected",
    jsii_struct_bases=[],
    name_mapping={"default_mode": "defaultMode", "sources": "sources"},
)
class TenantV2SpecSideCarsVolumesProjected:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        sources: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesProjectedSources", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param sources: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjected
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjected.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument sources", value=sources, expected_type=type_hints["sources"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if sources is not None:
            self._values["sources"] = sources

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjected#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def sources(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSources"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjected#sources
        '''
        result = self._values.get("sources")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSources"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjected(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSources",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "downward_api": "downwardApi",
        "secret": "secret",
        "service_account_token": "serviceAccountToken",
    },
)
class TenantV2SpecSideCarsVolumesProjectedSources:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap", typing.Dict[str, typing.Any]]] = None,
        downward_api: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesSecret", typing.Dict[str, typing.Any]]] = None,
        service_account_token: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param downward_api: 
        :param secret: 
        :param service_account_token: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSources
        '''
        if isinstance(config_map, dict):
            config_map = TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap(**config_map)
        if isinstance(downward_api, dict):
            downward_api = TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi(**downward_api)
        if isinstance(secret, dict):
            secret = TenantV2SpecSideCarsVolumesProjectedSourcesSecret(**secret)
        if isinstance(service_account_token, dict):
            service_account_token = TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken(**service_account_token)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSources.__init__)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument downward_api", value=downward_api, expected_type=type_hints["downward_api"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument service_account_token", value=service_account_token, expected_type=type_hints["service_account_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if downward_api is not None:
            self._values["downward_api"] = downward_api
        if secret is not None:
            self._values["secret"] = secret
        if service_account_token is not None:
            self._values["service_account_token"] = service_account_token

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSources#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap"], result)

    @builtins.property
    def downward_api(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSources#downwardAPI
        '''
        result = self._values.get("downward_api")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesSecret"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSources#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesSecret"], result)

    @builtins.property
    def service_account_token(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSources#serviceAccountToken
        '''
        result = self._values.get("service_account_token")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSources(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi",
    jsii_struct_bases=[],
    name_mapping={"items": "items"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param items: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "field_ref": "fieldRef",
        "mode": "mode",
        "resource_field_ref": "resourceFieldRef",
    },
)
class TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems:
    def __init__(
        self,
        *,
        path: builtins.str,
        field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef", typing.Dict[str, typing.Any]]] = None,
        mode: typing.Optional[jsii.Number] = None,
        resource_field_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param path: 
        :param field_ref: 
        :param mode: 
        :param resource_field_ref: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems
        '''
        if isinstance(field_ref, dict):
            field_ref = TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef(**field_ref)
        if isinstance(resource_field_ref, dict):
            resource_field_ref = TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(**resource_field_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument field_ref", value=field_ref, expected_type=type_hints["field_ref"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
            check_type(argname="argument resource_field_ref", value=resource_field_ref, expected_type=type_hints["resource_field_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if field_ref is not None:
            self._values["field_ref"] = field_ref
        if mode is not None:
            self._values["mode"] = mode
        if resource_field_ref is not None:
            self._values["resource_field_ref"] = resource_field_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems#fieldRef
        '''
        result = self._values.get("field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef"], result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def resource_field_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
        '''
        result = self._values.get("resource_field_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef",
    jsii_struct_bases=[],
    name_mapping={"field_path": "fieldPath", "api_version": "apiVersion"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef:
    def __init__(
        self,
        *,
        field_path: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param field_path: 
        :param api_version: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef.__init__)
            check_type(argname="argument field_path", value=field_path, expected_type=type_hints["field_path"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[str, typing.Any] = {
            "field_path": field_path,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def field_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
        '''
        result = self._values.get("field_path")
        assert result is not None, "Required property 'field_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef",
    jsii_struct_bases=[],
    name_mapping={
        "resource": "resource",
        "container_name": "containerName",
        "divisor": "divisor",
    },
)
class TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef:
    def __init__(
        self,
        *,
        resource: builtins.str,
        container_name: typing.Optional[builtins.str] = None,
        divisor: typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"] = None,
    ) -> None:
        '''
        :param resource: 
        :param container_name: 
        :param divisor: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef.__init__)
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
        self._values: typing.Dict[str, typing.Any] = {
            "resource": resource,
        }
        if container_name is not None:
            self._values["container_name"] = container_name
        if divisor is not None:
            self._values["divisor"] = divisor

    @builtins.property
    def resource(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
        '''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def divisor(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
        '''
        result = self._values.get("divisor")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor",
):
    '''
    :stability: experimental
    :schema: TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
    '''

    @jsii.member(jsii_name="fromNumber") # type: ignore[misc]
    @builtins.classmethod
    def from_number(
        cls,
        value: jsii.Number,
    ) -> "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor.from_number)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromNumber", [value]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        value: builtins.str,
    ) -> "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor":
        '''
        :param value: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor.from_string)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast("TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor", jsii.sinvoke(cls, "fromString", [value]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="value")
    def value(self) -> typing.Any:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Any, jsii.get(self, "value"))


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name", "optional": "optional"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesSecret:
    def __init__(
        self,
        *,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        optional: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param items: 
        :param name: 
        :param optional: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesSecret.__init__)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
        self._values: typing.Dict[str, typing.Any] = {}
        if items is not None:
            self._values["items"] = items
        if name is not None:
            self._values["name"] = name
        if optional is not None:
            self._values["optional"] = optional

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecret#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecret#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "audience": "audience",
        "expiration_seconds": "expirationSeconds",
    },
)
class TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken:
    def __init__(
        self,
        *,
        path: builtins.str,
        audience: typing.Optional[builtins.str] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param path: 
        :param audience: 
        :param expiration_seconds: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken.__init__)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument audience", value=audience, expected_type=type_hints["audience"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if audience is not None:
            self._values["audience"] = audience
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audience(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken#audience
        '''
        result = self._values.get("audience")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesQuobyte",
    jsii_struct_bases=[],
    name_mapping={
        "registry": "registry",
        "volume": "volume",
        "group": "group",
        "read_only": "readOnly",
        "tenant": "tenant",
        "user": "user",
    },
)
class TenantV2SpecSideCarsVolumesQuobyte:
    def __init__(
        self,
        *,
        registry: builtins.str,
        volume: builtins.str,
        group: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        tenant: typing.Optional[builtins.str] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param registry: 
        :param volume: 
        :param group: 
        :param read_only: 
        :param tenant: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesQuobyte.__init__)
            check_type(argname="argument registry", value=registry, expected_type=type_hints["registry"])
            check_type(argname="argument volume", value=volume, expected_type=type_hints["volume"])
            check_type(argname="argument group", value=group, expected_type=type_hints["group"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument tenant", value=tenant, expected_type=type_hints["tenant"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "registry": registry,
            "volume": volume,
        }
        if group is not None:
            self._values["group"] = group
        if read_only is not None:
            self._values["read_only"] = read_only
        if tenant is not None:
            self._values["tenant"] = tenant
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def registry(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#registry
        '''
        result = self._values.get("registry")
        assert result is not None, "Required property 'registry' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#volume
        '''
        result = self._values.get("volume")
        assert result is not None, "Required property 'volume' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#group
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tenant(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#tenant
        '''
        result = self._values.get("tenant")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesQuobyte#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesQuobyte(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesRbd",
    jsii_struct_bases=[],
    name_mapping={
        "image": "image",
        "monitors": "monitors",
        "fs_type": "fsType",
        "keyring": "keyring",
        "pool": "pool",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
        "user": "user",
    },
)
class TenantV2SpecSideCarsVolumesRbd:
    def __init__(
        self,
        *,
        image: builtins.str,
        monitors: typing.Sequence[builtins.str],
        fs_type: typing.Optional[builtins.str] = None,
        keyring: typing.Optional[builtins.str] = None,
        pool: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesRbdSecretRef", typing.Dict[str, typing.Any]]] = None,
        user: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param image: 
        :param monitors: 
        :param fs_type: 
        :param keyring: 
        :param pool: 
        :param read_only: 
        :param secret_ref: 
        :param user: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesRbdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesRbd.__init__)
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument monitors", value=monitors, expected_type=type_hints["monitors"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument keyring", value=keyring, expected_type=type_hints["keyring"])
            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "image": image,
            "monitors": monitors,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if keyring is not None:
            self._values["keyring"] = keyring
        if pool is not None:
            self._values["pool"] = pool
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if user is not None:
            self._values["user"] = user

    @builtins.property
    def image(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#image
        '''
        result = self._values.get("image")
        assert result is not None, "Required property 'image' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def monitors(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#monitors
        '''
        result = self._values.get("monitors")
        assert result is not None, "Required property 'monitors' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def keyring(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#keyring
        '''
        result = self._values.get("keyring")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def pool(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#pool
        '''
        result = self._values.get("pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["TenantV2SpecSideCarsVolumesRbdSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesRbdSecretRef"], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbd#user
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesRbd(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesRbdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesRbdSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesRbdSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesRbdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesRbdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesScaleIo",
    jsii_struct_bases=[],
    name_mapping={
        "gateway": "gateway",
        "secret_ref": "secretRef",
        "system": "system",
        "fs_type": "fsType",
        "protection_domain": "protectionDomain",
        "read_only": "readOnly",
        "ssl_enabled": "sslEnabled",
        "storage_mode": "storageMode",
        "storage_pool": "storagePool",
        "volume_name": "volumeName",
    },
)
class TenantV2SpecSideCarsVolumesScaleIo:
    def __init__(
        self,
        *,
        gateway: builtins.str,
        secret_ref: typing.Union["TenantV2SpecSideCarsVolumesScaleIoSecretRef", typing.Dict[str, typing.Any]],
        system: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        protection_domain: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        ssl_enabled: typing.Optional[builtins.bool] = None,
        storage_mode: typing.Optional[builtins.str] = None,
        storage_pool: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param gateway: 
        :param secret_ref: 
        :param system: 
        :param fs_type: 
        :param protection_domain: 
        :param read_only: 
        :param ssl_enabled: 
        :param storage_mode: 
        :param storage_pool: 
        :param volume_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesScaleIoSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesScaleIo.__init__)
            check_type(argname="argument gateway", value=gateway, expected_type=type_hints["gateway"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument system", value=system, expected_type=type_hints["system"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument protection_domain", value=protection_domain, expected_type=type_hints["protection_domain"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument ssl_enabled", value=ssl_enabled, expected_type=type_hints["ssl_enabled"])
            check_type(argname="argument storage_mode", value=storage_mode, expected_type=type_hints["storage_mode"])
            check_type(argname="argument storage_pool", value=storage_pool, expected_type=type_hints["storage_pool"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "gateway": gateway,
            "secret_ref": secret_ref,
            "system": system,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if protection_domain is not None:
            self._values["protection_domain"] = protection_domain
        if read_only is not None:
            self._values["read_only"] = read_only
        if ssl_enabled is not None:
            self._values["ssl_enabled"] = ssl_enabled
        if storage_mode is not None:
            self._values["storage_mode"] = storage_mode
        if storage_pool is not None:
            self._values["storage_pool"] = storage_pool
        if volume_name is not None:
            self._values["volume_name"] = volume_name

    @builtins.property
    def gateway(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#gateway
        '''
        result = self._values.get("gateway")
        assert result is not None, "Required property 'gateway' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "TenantV2SpecSideCarsVolumesScaleIoSecretRef":
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("TenantV2SpecSideCarsVolumesScaleIoSecretRef", result)

    @builtins.property
    def system(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#system
        '''
        result = self._values.get("system")
        assert result is not None, "Required property 'system' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protection_domain(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#protectionDomain
        '''
        result = self._values.get("protection_domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ssl_enabled(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#sslEnabled
        '''
        result = self._values.get("ssl_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def storage_mode(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#storageMode
        '''
        result = self._values.get("storage_mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_pool(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#storagePool
        '''
        result = self._values.get("storage_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIo#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesScaleIo(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesScaleIoSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesScaleIoSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIoSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesScaleIoSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesScaleIoSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesScaleIoSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesSecret",
    jsii_struct_bases=[],
    name_mapping={
        "default_mode": "defaultMode",
        "items": "items",
        "optional": "optional",
        "secret_name": "secretName",
    },
)
class TenantV2SpecSideCarsVolumesSecret:
    def __init__(
        self,
        *,
        default_mode: typing.Optional[jsii.Number] = None,
        items: typing.Optional[typing.Sequence[typing.Union["TenantV2SpecSideCarsVolumesSecretItems", typing.Dict[str, typing.Any]]]] = None,
        optional: typing.Optional[builtins.bool] = None,
        secret_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param default_mode: 
        :param items: 
        :param optional: 
        :param secret_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesSecret.__init__)
            check_type(argname="argument default_mode", value=default_mode, expected_type=type_hints["default_mode"])
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument optional", value=optional, expected_type=type_hints["optional"])
            check_type(argname="argument secret_name", value=secret_name, expected_type=type_hints["secret_name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if default_mode is not None:
            self._values["default_mode"] = default_mode
        if items is not None:
            self._values["items"] = items
        if optional is not None:
            self._values["optional"] = optional
        if secret_name is not None:
            self._values["secret_name"] = secret_name

    @builtins.property
    def default_mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecret#defaultMode
        '''
        result = self._values.get("default_mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def items(
        self,
    ) -> typing.Optional[typing.List["TenantV2SpecSideCarsVolumesSecretItems"]]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecret#items
        '''
        result = self._values.get("items")
        return typing.cast(typing.Optional[typing.List["TenantV2SpecSideCarsVolumesSecretItems"]], result)

    @builtins.property
    def optional(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecret#optional
        '''
        result = self._values.get("optional")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecret#secretName
        '''
        result = self._values.get("secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "path": "path", "mode": "mode"},
)
class TenantV2SpecSideCarsVolumesSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        path: builtins.str,
        mode: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param key: 
        :param path: 
        :param mode: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesSecretItems.__init__)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "path": path,
        }
        if mode is not None:
            self._values["mode"] = mode

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecretItems#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def mode(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesSecretItems#mode
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesStorageos",
    jsii_struct_bases=[],
    name_mapping={
        "fs_type": "fsType",
        "read_only": "readOnly",
        "secret_ref": "secretRef",
        "volume_name": "volumeName",
        "volume_namespace": "volumeNamespace",
    },
)
class TenantV2SpecSideCarsVolumesStorageos:
    def __init__(
        self,
        *,
        fs_type: typing.Optional[builtins.str] = None,
        read_only: typing.Optional[builtins.bool] = None,
        secret_ref: typing.Optional[typing.Union["TenantV2SpecSideCarsVolumesStorageosSecretRef", typing.Dict[str, typing.Any]]] = None,
        volume_name: typing.Optional[builtins.str] = None,
        volume_namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param fs_type: 
        :param read_only: 
        :param secret_ref: 
        :param volume_name: 
        :param volume_namespace: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos
        '''
        if isinstance(secret_ref, dict):
            secret_ref = TenantV2SpecSideCarsVolumesStorageosSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesStorageos.__init__)
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument read_only", value=read_only, expected_type=type_hints["read_only"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument volume_name", value=volume_name, expected_type=type_hints["volume_name"])
            check_type(argname="argument volume_namespace", value=volume_namespace, expected_type=type_hints["volume_namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if read_only is not None:
            self._values["read_only"] = read_only
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if volume_name is not None:
            self._values["volume_name"] = volume_name
        if volume_namespace is not None:
            self._values["volume_namespace"] = volume_namespace

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_only(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos#readOnly
        '''
        result = self._values.get("read_only")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["TenantV2SpecSideCarsVolumesStorageosSecretRef"]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["TenantV2SpecSideCarsVolumesStorageosSecretRef"], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos#volumeName
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_namespace(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageos#volumeNamespace
        '''
        result = self._values.get("volume_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesStorageos(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesStorageosSecretRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecSideCarsVolumesStorageosSecretRef:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageosSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesStorageosSecretRef.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesStorageosSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesStorageosSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecSideCarsVolumesVsphereVolume",
    jsii_struct_bases=[],
    name_mapping={
        "volume_path": "volumePath",
        "fs_type": "fsType",
        "storage_policy_id": "storagePolicyId",
        "storage_policy_name": "storagePolicyName",
    },
)
class TenantV2SpecSideCarsVolumesVsphereVolume:
    def __init__(
        self,
        *,
        volume_path: builtins.str,
        fs_type: typing.Optional[builtins.str] = None,
        storage_policy_id: typing.Optional[builtins.str] = None,
        storage_policy_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param volume_path: 
        :param fs_type: 
        :param storage_policy_id: 
        :param storage_policy_name: 

        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesVsphereVolume
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecSideCarsVolumesVsphereVolume.__init__)
            check_type(argname="argument volume_path", value=volume_path, expected_type=type_hints["volume_path"])
            check_type(argname="argument fs_type", value=fs_type, expected_type=type_hints["fs_type"])
            check_type(argname="argument storage_policy_id", value=storage_policy_id, expected_type=type_hints["storage_policy_id"])
            check_type(argname="argument storage_policy_name", value=storage_policy_name, expected_type=type_hints["storage_policy_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "volume_path": volume_path,
        }
        if fs_type is not None:
            self._values["fs_type"] = fs_type
        if storage_policy_id is not None:
            self._values["storage_policy_id"] = storage_policy_id
        if storage_policy_name is not None:
            self._values["storage_policy_name"] = storage_policy_name

    @builtins.property
    def volume_path(self) -> builtins.str:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesVsphereVolume#volumePath
        '''
        result = self._values.get("volume_path")
        assert result is not None, "Required property 'volume_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fs_type(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesVsphereVolume#fsType
        '''
        result = self._values.get("fs_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_policy_id(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesVsphereVolume#storagePolicyID
        '''
        result = self._values.get("storage_policy_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def storage_policy_name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecSideCarsVolumesVsphereVolume#storagePolicyName
        '''
        result = self._values.get("storage_policy_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecSideCarsVolumesVsphereVolume(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk8s-metaflow.minio.TenantV2SpecUsers",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class TenantV2SpecUsers:
    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
        '''
        :param name: 

        :stability: experimental
        :schema: TenantV2SpecUsers
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TenantV2SpecUsers.__init__)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        :schema: TenantV2SpecUsers#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TenantV2SpecUsers(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "Tenant",
    "TenantProps",
    "TenantScheduler",
    "TenantSpec",
    "TenantSpecCertConfig",
    "TenantSpecConfiguration",
    "TenantSpecCredsSecret",
    "TenantSpecEnv",
    "TenantSpecEnvValueFrom",
    "TenantSpecEnvValueFromConfigMapKeyRef",
    "TenantSpecEnvValueFromFieldRef",
    "TenantSpecEnvValueFromResourceFieldRef",
    "TenantSpecEnvValueFromResourceFieldRefDivisor",
    "TenantSpecEnvValueFromSecretKeyRef",
    "TenantSpecExposeServices",
    "TenantSpecExternalCaCertSecret",
    "TenantSpecExternalCertSecret",
    "TenantSpecExternalClientCertSecret",
    "TenantSpecImagePullSecret",
    "TenantSpecKes",
    "TenantSpecKesAffinity",
    "TenantSpecKesAffinityNodeAffinity",
    "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantSpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantSpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantSpecKesAffinityPodAffinity",
    "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecKesAffinityPodAntiAffinity",
    "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecKesClientCertSecret",
    "TenantSpecKesExternalCertSecret",
    "TenantSpecKesKesSecret",
    "TenantSpecKesResources",
    "TenantSpecKesResourcesLimits",
    "TenantSpecKesResourcesRequests",
    "TenantSpecKesSecurityContext",
    "TenantSpecKesSecurityContextSeLinuxOptions",
    "TenantSpecKesSecurityContextSeccompProfile",
    "TenantSpecKesSecurityContextSysctls",
    "TenantSpecKesSecurityContextWindowsOptions",
    "TenantSpecKesTolerations",
    "TenantSpecKesTopologySpreadConstraints",
    "TenantSpecKesTopologySpreadConstraintsLabelSelector",
    "TenantSpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantSpecLog",
    "TenantSpecLogAffinity",
    "TenantSpecLogAffinityNodeAffinity",
    "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantSpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantSpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantSpecLogAffinityPodAffinity",
    "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecLogAffinityPodAntiAffinity",
    "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecLogAudit",
    "TenantSpecLogDb",
    "TenantSpecLogDbAffinity",
    "TenantSpecLogDbAffinityNodeAffinity",
    "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantSpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantSpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantSpecLogDbAffinityPodAffinity",
    "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecLogDbAffinityPodAntiAffinity",
    "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecLogDbResources",
    "TenantSpecLogDbResourcesLimits",
    "TenantSpecLogDbResourcesRequests",
    "TenantSpecLogDbSecurityContext",
    "TenantSpecLogDbSecurityContextSeLinuxOptions",
    "TenantSpecLogDbSecurityContextSeccompProfile",
    "TenantSpecLogDbSecurityContextSysctls",
    "TenantSpecLogDbSecurityContextWindowsOptions",
    "TenantSpecLogDbTolerations",
    "TenantSpecLogDbTopologySpreadConstraints",
    "TenantSpecLogDbTopologySpreadConstraintsLabelSelector",
    "TenantSpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantSpecLogDbVolumeClaimTemplate",
    "TenantSpecLogDbVolumeClaimTemplateMetadata",
    "TenantSpecLogDbVolumeClaimTemplateSpec",
    "TenantSpecLogDbVolumeClaimTemplateSpecDataSource",
    "TenantSpecLogDbVolumeClaimTemplateSpecResources",
    "TenantSpecLogDbVolumeClaimTemplateSpecResourcesLimits",
    "TenantSpecLogDbVolumeClaimTemplateSpecResourcesRequests",
    "TenantSpecLogDbVolumeClaimTemplateSpecSelector",
    "TenantSpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantSpecLogDbVolumeClaimTemplateStatus",
    "TenantSpecLogDbVolumeClaimTemplateStatusCapacity",
    "TenantSpecLogDbVolumeClaimTemplateStatusConditions",
    "TenantSpecLogResources",
    "TenantSpecLogResourcesLimits",
    "TenantSpecLogResourcesRequests",
    "TenantSpecLogSecurityContext",
    "TenantSpecLogSecurityContextSeLinuxOptions",
    "TenantSpecLogSecurityContextSeccompProfile",
    "TenantSpecLogSecurityContextSysctls",
    "TenantSpecLogSecurityContextWindowsOptions",
    "TenantSpecLogTolerations",
    "TenantSpecLogTopologySpreadConstraints",
    "TenantSpecLogTopologySpreadConstraintsLabelSelector",
    "TenantSpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantSpecPrometheus",
    "TenantSpecPrometheusAffinity",
    "TenantSpecPrometheusAffinityNodeAffinity",
    "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantSpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantSpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantSpecPrometheusAffinityPodAffinity",
    "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecPrometheusAffinityPodAntiAffinity",
    "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecPrometheusResources",
    "TenantSpecPrometheusResourcesLimits",
    "TenantSpecPrometheusResourcesRequests",
    "TenantSpecPrometheusSecurityContext",
    "TenantSpecPrometheusSecurityContextSeLinuxOptions",
    "TenantSpecPrometheusSecurityContextSeccompProfile",
    "TenantSpecPrometheusSecurityContextSysctls",
    "TenantSpecPrometheusSecurityContextWindowsOptions",
    "TenantSpecPrometheusTopologySpreadConstraints",
    "TenantSpecPrometheusTopologySpreadConstraintsLabelSelector",
    "TenantSpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantSpecS3",
    "TenantSpecSecurityContext",
    "TenantSpecSecurityContextSeLinuxOptions",
    "TenantSpecSecurityContextSeccompProfile",
    "TenantSpecSecurityContextSysctls",
    "TenantSpecSecurityContextWindowsOptions",
    "TenantSpecSideCars",
    "TenantSpecSideCarsContainers",
    "TenantSpecSideCarsContainersEnv",
    "TenantSpecSideCarsContainersEnvFrom",
    "TenantSpecSideCarsContainersEnvFromConfigMapRef",
    "TenantSpecSideCarsContainersEnvFromSecretRef",
    "TenantSpecSideCarsContainersEnvValueFrom",
    "TenantSpecSideCarsContainersEnvValueFromConfigMapKeyRef",
    "TenantSpecSideCarsContainersEnvValueFromFieldRef",
    "TenantSpecSideCarsContainersEnvValueFromResourceFieldRef",
    "TenantSpecSideCarsContainersEnvValueFromResourceFieldRefDivisor",
    "TenantSpecSideCarsContainersEnvValueFromSecretKeyRef",
    "TenantSpecSideCarsContainersLifecycle",
    "TenantSpecSideCarsContainersLifecyclePostStart",
    "TenantSpecSideCarsContainersLifecyclePostStartExec",
    "TenantSpecSideCarsContainersLifecyclePostStartHttpGet",
    "TenantSpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders",
    "TenantSpecSideCarsContainersLifecyclePostStartHttpGetPort",
    "TenantSpecSideCarsContainersLifecyclePostStartTcpSocket",
    "TenantSpecSideCarsContainersLifecyclePostStartTcpSocketPort",
    "TenantSpecSideCarsContainersLifecyclePreStop",
    "TenantSpecSideCarsContainersLifecyclePreStopExec",
    "TenantSpecSideCarsContainersLifecyclePreStopHttpGet",
    "TenantSpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders",
    "TenantSpecSideCarsContainersLifecyclePreStopHttpGetPort",
    "TenantSpecSideCarsContainersLifecyclePreStopTcpSocket",
    "TenantSpecSideCarsContainersLifecyclePreStopTcpSocketPort",
    "TenantSpecSideCarsContainersLivenessProbe",
    "TenantSpecSideCarsContainersLivenessProbeExec",
    "TenantSpecSideCarsContainersLivenessProbeHttpGet",
    "TenantSpecSideCarsContainersLivenessProbeHttpGetHttpHeaders",
    "TenantSpecSideCarsContainersLivenessProbeHttpGetPort",
    "TenantSpecSideCarsContainersLivenessProbeTcpSocket",
    "TenantSpecSideCarsContainersLivenessProbeTcpSocketPort",
    "TenantSpecSideCarsContainersPorts",
    "TenantSpecSideCarsContainersReadinessProbe",
    "TenantSpecSideCarsContainersReadinessProbeExec",
    "TenantSpecSideCarsContainersReadinessProbeHttpGet",
    "TenantSpecSideCarsContainersReadinessProbeHttpGetHttpHeaders",
    "TenantSpecSideCarsContainersReadinessProbeHttpGetPort",
    "TenantSpecSideCarsContainersReadinessProbeTcpSocket",
    "TenantSpecSideCarsContainersReadinessProbeTcpSocketPort",
    "TenantSpecSideCarsContainersResources",
    "TenantSpecSideCarsContainersResourcesLimits",
    "TenantSpecSideCarsContainersResourcesRequests",
    "TenantSpecSideCarsContainersSecurityContext",
    "TenantSpecSideCarsContainersSecurityContextCapabilities",
    "TenantSpecSideCarsContainersSecurityContextSeLinuxOptions",
    "TenantSpecSideCarsContainersSecurityContextSeccompProfile",
    "TenantSpecSideCarsContainersSecurityContextWindowsOptions",
    "TenantSpecSideCarsContainersStartupProbe",
    "TenantSpecSideCarsContainersStartupProbeExec",
    "TenantSpecSideCarsContainersStartupProbeHttpGet",
    "TenantSpecSideCarsContainersStartupProbeHttpGetHttpHeaders",
    "TenantSpecSideCarsContainersStartupProbeHttpGetPort",
    "TenantSpecSideCarsContainersStartupProbeTcpSocket",
    "TenantSpecSideCarsContainersStartupProbeTcpSocketPort",
    "TenantSpecSideCarsContainersVolumeDevices",
    "TenantSpecSideCarsContainersVolumeMounts",
    "TenantSpecSideCarsVolumeClaimTemplates",
    "TenantSpecSideCarsVolumeClaimTemplatesMetadata",
    "TenantSpecSideCarsVolumeClaimTemplatesSpec",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecDataSource",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecResources",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesLimits",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecResourcesRequests",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecSelector",
    "TenantSpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions",
    "TenantSpecSideCarsVolumeClaimTemplatesStatus",
    "TenantSpecSideCarsVolumeClaimTemplatesStatusCapacity",
    "TenantSpecSideCarsVolumeClaimTemplatesStatusConditions",
    "TenantSpecSideCarsVolumes",
    "TenantSpecSideCarsVolumesAwsElasticBlockStore",
    "TenantSpecSideCarsVolumesAzureDisk",
    "TenantSpecSideCarsVolumesAzureFile",
    "TenantSpecSideCarsVolumesCephfs",
    "TenantSpecSideCarsVolumesCephfsSecretRef",
    "TenantSpecSideCarsVolumesCinder",
    "TenantSpecSideCarsVolumesCinderSecretRef",
    "TenantSpecSideCarsVolumesConfigMap",
    "TenantSpecSideCarsVolumesConfigMapItems",
    "TenantSpecSideCarsVolumesCsi",
    "TenantSpecSideCarsVolumesCsiNodePublishSecretRef",
    "TenantSpecSideCarsVolumesDownwardApi",
    "TenantSpecSideCarsVolumesDownwardApiItems",
    "TenantSpecSideCarsVolumesDownwardApiItemsFieldRef",
    "TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRef",
    "TenantSpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor",
    "TenantSpecSideCarsVolumesEmptyDir",
    "TenantSpecSideCarsVolumesEmptyDirSizeLimit",
    "TenantSpecSideCarsVolumesEphemeral",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplate",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector",
    "TenantSpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantSpecSideCarsVolumesFc",
    "TenantSpecSideCarsVolumesFlexVolume",
    "TenantSpecSideCarsVolumesFlexVolumeSecretRef",
    "TenantSpecSideCarsVolumesFlocker",
    "TenantSpecSideCarsVolumesGcePersistentDisk",
    "TenantSpecSideCarsVolumesGitRepo",
    "TenantSpecSideCarsVolumesGlusterfs",
    "TenantSpecSideCarsVolumesHostPath",
    "TenantSpecSideCarsVolumesIscsi",
    "TenantSpecSideCarsVolumesIscsiSecretRef",
    "TenantSpecSideCarsVolumesNfs",
    "TenantSpecSideCarsVolumesPersistentVolumeClaim",
    "TenantSpecSideCarsVolumesPhotonPersistentDisk",
    "TenantSpecSideCarsVolumesPortworxVolume",
    "TenantSpecSideCarsVolumesProjected",
    "TenantSpecSideCarsVolumesProjectedSources",
    "TenantSpecSideCarsVolumesProjectedSourcesConfigMap",
    "TenantSpecSideCarsVolumesProjectedSourcesConfigMapItems",
    "TenantSpecSideCarsVolumesProjectedSourcesDownwardApi",
    "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItems",
    "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef",
    "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef",
    "TenantSpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor",
    "TenantSpecSideCarsVolumesProjectedSourcesSecret",
    "TenantSpecSideCarsVolumesProjectedSourcesSecretItems",
    "TenantSpecSideCarsVolumesProjectedSourcesServiceAccountToken",
    "TenantSpecSideCarsVolumesQuobyte",
    "TenantSpecSideCarsVolumesRbd",
    "TenantSpecSideCarsVolumesRbdSecretRef",
    "TenantSpecSideCarsVolumesScaleIo",
    "TenantSpecSideCarsVolumesScaleIoSecretRef",
    "TenantSpecSideCarsVolumesSecret",
    "TenantSpecSideCarsVolumesSecretItems",
    "TenantSpecSideCarsVolumesStorageos",
    "TenantSpecSideCarsVolumesStorageosSecretRef",
    "TenantSpecSideCarsVolumesVsphereVolume",
    "TenantSpecUsers",
    "TenantSpecZones",
    "TenantSpecZonesAffinity",
    "TenantSpecZonesAffinityNodeAffinity",
    "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantSpecZonesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantSpecZonesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantSpecZonesAffinityPodAffinity",
    "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecZonesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecZonesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecZonesAffinityPodAntiAffinity",
    "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantSpecZonesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantSpecZonesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantSpecZonesResources",
    "TenantSpecZonesResourcesLimits",
    "TenantSpecZonesResourcesRequests",
    "TenantSpecZonesSecurityContext",
    "TenantSpecZonesSecurityContextSeLinuxOptions",
    "TenantSpecZonesSecurityContextSeccompProfile",
    "TenantSpecZonesSecurityContextSysctls",
    "TenantSpecZonesSecurityContextWindowsOptions",
    "TenantSpecZonesTolerations",
    "TenantSpecZonesTopologySpreadConstraints",
    "TenantSpecZonesTopologySpreadConstraintsLabelSelector",
    "TenantSpecZonesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantSpecZonesVolumeClaimTemplate",
    "TenantSpecZonesVolumeClaimTemplateMetadata",
    "TenantSpecZonesVolumeClaimTemplateSpec",
    "TenantSpecZonesVolumeClaimTemplateSpecDataSource",
    "TenantSpecZonesVolumeClaimTemplateSpecResources",
    "TenantSpecZonesVolumeClaimTemplateSpecResourcesLimits",
    "TenantSpecZonesVolumeClaimTemplateSpecResourcesRequests",
    "TenantSpecZonesVolumeClaimTemplateSpecSelector",
    "TenantSpecZonesVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantSpecZonesVolumeClaimTemplateStatus",
    "TenantSpecZonesVolumeClaimTemplateStatusCapacity",
    "TenantSpecZonesVolumeClaimTemplateStatusConditions",
    "TenantV2",
    "TenantV2Props",
    "TenantV2Scheduler",
    "TenantV2Spec",
    "TenantV2SpecBuckets",
    "TenantV2SpecCertConfig",
    "TenantV2SpecConfiguration",
    "TenantV2SpecCredsSecret",
    "TenantV2SpecEnv",
    "TenantV2SpecEnvValueFrom",
    "TenantV2SpecEnvValueFromConfigMapKeyRef",
    "TenantV2SpecEnvValueFromFieldRef",
    "TenantV2SpecEnvValueFromResourceFieldRef",
    "TenantV2SpecEnvValueFromResourceFieldRefDivisor",
    "TenantV2SpecEnvValueFromSecretKeyRef",
    "TenantV2SpecExposeServices",
    "TenantV2SpecExternalCaCertSecret",
    "TenantV2SpecExternalCertSecret",
    "TenantV2SpecExternalClientCertSecret",
    "TenantV2SpecFeatures",
    "TenantV2SpecFeaturesDomains",
    "TenantV2SpecImagePullSecret",
    "TenantV2SpecKes",
    "TenantV2SpecKesAffinity",
    "TenantV2SpecKesAffinityNodeAffinity",
    "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantV2SpecKesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantV2SpecKesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantV2SpecKesAffinityPodAffinity",
    "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecKesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecKesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecKesAffinityPodAntiAffinity",
    "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecKesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecKesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecKesClientCertSecret",
    "TenantV2SpecKesExternalCertSecret",
    "TenantV2SpecKesKesSecret",
    "TenantV2SpecKesResources",
    "TenantV2SpecKesResourcesLimits",
    "TenantV2SpecKesResourcesRequests",
    "TenantV2SpecKesSecurityContext",
    "TenantV2SpecKesSecurityContextSeLinuxOptions",
    "TenantV2SpecKesSecurityContextSeccompProfile",
    "TenantV2SpecKesSecurityContextSysctls",
    "TenantV2SpecKesSecurityContextWindowsOptions",
    "TenantV2SpecKesTolerations",
    "TenantV2SpecKesTopologySpreadConstraints",
    "TenantV2SpecKesTopologySpreadConstraintsLabelSelector",
    "TenantV2SpecKesTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantV2SpecLiveness",
    "TenantV2SpecLivenessExec",
    "TenantV2SpecLivenessHttpGet",
    "TenantV2SpecLivenessHttpGetHttpHeaders",
    "TenantV2SpecLivenessHttpGetPort",
    "TenantV2SpecLivenessTcpSocket",
    "TenantV2SpecLivenessTcpSocketPort",
    "TenantV2SpecLog",
    "TenantV2SpecLogAffinity",
    "TenantV2SpecLogAffinityNodeAffinity",
    "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantV2SpecLogAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantV2SpecLogAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantV2SpecLogAffinityPodAffinity",
    "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecLogAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecLogAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecLogAffinityPodAntiAffinity",
    "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecLogAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecLogAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecLogAudit",
    "TenantV2SpecLogDb",
    "TenantV2SpecLogDbAffinity",
    "TenantV2SpecLogDbAffinityNodeAffinity",
    "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantV2SpecLogDbAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantV2SpecLogDbAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantV2SpecLogDbAffinityPodAffinity",
    "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecLogDbAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecLogDbAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecLogDbAffinityPodAntiAffinity",
    "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecLogDbAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecLogDbAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecLogDbResources",
    "TenantV2SpecLogDbResourcesLimits",
    "TenantV2SpecLogDbResourcesRequests",
    "TenantV2SpecLogDbSecurityContext",
    "TenantV2SpecLogDbSecurityContextSeLinuxOptions",
    "TenantV2SpecLogDbSecurityContextSeccompProfile",
    "TenantV2SpecLogDbSecurityContextSysctls",
    "TenantV2SpecLogDbSecurityContextWindowsOptions",
    "TenantV2SpecLogDbTolerations",
    "TenantV2SpecLogDbTopologySpreadConstraints",
    "TenantV2SpecLogDbTopologySpreadConstraintsLabelSelector",
    "TenantV2SpecLogDbTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantV2SpecLogDbVolumeClaimTemplate",
    "TenantV2SpecLogDbVolumeClaimTemplateMetadata",
    "TenantV2SpecLogDbVolumeClaimTemplateSpec",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecDataSource",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecResources",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesLimits",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecResourcesRequests",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecSelector",
    "TenantV2SpecLogDbVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantV2SpecLogDbVolumeClaimTemplateStatus",
    "TenantV2SpecLogDbVolumeClaimTemplateStatusCapacity",
    "TenantV2SpecLogDbVolumeClaimTemplateStatusConditions",
    "TenantV2SpecLogResources",
    "TenantV2SpecLogResourcesLimits",
    "TenantV2SpecLogResourcesRequests",
    "TenantV2SpecLogSecurityContext",
    "TenantV2SpecLogSecurityContextSeLinuxOptions",
    "TenantV2SpecLogSecurityContextSeccompProfile",
    "TenantV2SpecLogSecurityContextSysctls",
    "TenantV2SpecLogSecurityContextWindowsOptions",
    "TenantV2SpecLogTolerations",
    "TenantV2SpecLogTopologySpreadConstraints",
    "TenantV2SpecLogTopologySpreadConstraintsLabelSelector",
    "TenantV2SpecLogTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantV2SpecLogging",
    "TenantV2SpecPools",
    "TenantV2SpecPoolsAffinity",
    "TenantV2SpecPoolsAffinityNodeAffinity",
    "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantV2SpecPoolsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantV2SpecPoolsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantV2SpecPoolsAffinityPodAffinity",
    "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecPoolsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecPoolsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecPoolsAffinityPodAntiAffinity",
    "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecPoolsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecPoolsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecPoolsResources",
    "TenantV2SpecPoolsResourcesLimits",
    "TenantV2SpecPoolsResourcesRequests",
    "TenantV2SpecPoolsSecurityContext",
    "TenantV2SpecPoolsSecurityContextSeLinuxOptions",
    "TenantV2SpecPoolsSecurityContextSeccompProfile",
    "TenantV2SpecPoolsSecurityContextSysctls",
    "TenantV2SpecPoolsSecurityContextWindowsOptions",
    "TenantV2SpecPoolsTolerations",
    "TenantV2SpecPoolsTopologySpreadConstraints",
    "TenantV2SpecPoolsTopologySpreadConstraintsLabelSelector",
    "TenantV2SpecPoolsTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantV2SpecPoolsVolumeClaimTemplate",
    "TenantV2SpecPoolsVolumeClaimTemplateMetadata",
    "TenantV2SpecPoolsVolumeClaimTemplateSpec",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecDataSource",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecResources",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesLimits",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecResourcesRequests",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecSelector",
    "TenantV2SpecPoolsVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantV2SpecPoolsVolumeClaimTemplateStatus",
    "TenantV2SpecPoolsVolumeClaimTemplateStatusCapacity",
    "TenantV2SpecPoolsVolumeClaimTemplateStatusConditions",
    "TenantV2SpecPrometheus",
    "TenantV2SpecPrometheusAffinity",
    "TenantV2SpecPrometheusAffinityNodeAffinity",
    "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions",
    "TenantV2SpecPrometheusAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields",
    "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms",
    "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions",
    "TenantV2SpecPrometheusAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields",
    "TenantV2SpecPrometheusAffinityPodAffinity",
    "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecPrometheusAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecPrometheusAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecPrometheusAffinityPodAntiAffinity",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    "TenantV2SpecPrometheusAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions",
    "TenantV2SpecPrometheusResources",
    "TenantV2SpecPrometheusResourcesLimits",
    "TenantV2SpecPrometheusResourcesRequests",
    "TenantV2SpecPrometheusSecurityContext",
    "TenantV2SpecPrometheusSecurityContextSeLinuxOptions",
    "TenantV2SpecPrometheusSecurityContextSeccompProfile",
    "TenantV2SpecPrometheusSecurityContextSysctls",
    "TenantV2SpecPrometheusSecurityContextWindowsOptions",
    "TenantV2SpecPrometheusTopologySpreadConstraints",
    "TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelector",
    "TenantV2SpecPrometheusTopologySpreadConstraintsLabelSelectorMatchExpressions",
    "TenantV2SpecReadiness",
    "TenantV2SpecReadinessExec",
    "TenantV2SpecReadinessHttpGet",
    "TenantV2SpecReadinessHttpGetHttpHeaders",
    "TenantV2SpecReadinessHttpGetPort",
    "TenantV2SpecReadinessTcpSocket",
    "TenantV2SpecReadinessTcpSocketPort",
    "TenantV2SpecS3",
    "TenantV2SpecServiceMetadata",
    "TenantV2SpecSideCars",
    "TenantV2SpecSideCarsContainers",
    "TenantV2SpecSideCarsContainersEnv",
    "TenantV2SpecSideCarsContainersEnvFrom",
    "TenantV2SpecSideCarsContainersEnvFromConfigMapRef",
    "TenantV2SpecSideCarsContainersEnvFromSecretRef",
    "TenantV2SpecSideCarsContainersEnvValueFrom",
    "TenantV2SpecSideCarsContainersEnvValueFromConfigMapKeyRef",
    "TenantV2SpecSideCarsContainersEnvValueFromFieldRef",
    "TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRef",
    "TenantV2SpecSideCarsContainersEnvValueFromResourceFieldRefDivisor",
    "TenantV2SpecSideCarsContainersEnvValueFromSecretKeyRef",
    "TenantV2SpecSideCarsContainersLifecycle",
    "TenantV2SpecSideCarsContainersLifecyclePostStart",
    "TenantV2SpecSideCarsContainersLifecyclePostStartExec",
    "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGet",
    "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetHttpHeaders",
    "TenantV2SpecSideCarsContainersLifecyclePostStartHttpGetPort",
    "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocket",
    "TenantV2SpecSideCarsContainersLifecyclePostStartTcpSocketPort",
    "TenantV2SpecSideCarsContainersLifecyclePreStop",
    "TenantV2SpecSideCarsContainersLifecyclePreStopExec",
    "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGet",
    "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetHttpHeaders",
    "TenantV2SpecSideCarsContainersLifecyclePreStopHttpGetPort",
    "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocket",
    "TenantV2SpecSideCarsContainersLifecyclePreStopTcpSocketPort",
    "TenantV2SpecSideCarsContainersLivenessProbe",
    "TenantV2SpecSideCarsContainersLivenessProbeExec",
    "TenantV2SpecSideCarsContainersLivenessProbeHttpGet",
    "TenantV2SpecSideCarsContainersLivenessProbeHttpGetHttpHeaders",
    "TenantV2SpecSideCarsContainersLivenessProbeHttpGetPort",
    "TenantV2SpecSideCarsContainersLivenessProbeTcpSocket",
    "TenantV2SpecSideCarsContainersLivenessProbeTcpSocketPort",
    "TenantV2SpecSideCarsContainersPorts",
    "TenantV2SpecSideCarsContainersReadinessProbe",
    "TenantV2SpecSideCarsContainersReadinessProbeExec",
    "TenantV2SpecSideCarsContainersReadinessProbeHttpGet",
    "TenantV2SpecSideCarsContainersReadinessProbeHttpGetHttpHeaders",
    "TenantV2SpecSideCarsContainersReadinessProbeHttpGetPort",
    "TenantV2SpecSideCarsContainersReadinessProbeTcpSocket",
    "TenantV2SpecSideCarsContainersReadinessProbeTcpSocketPort",
    "TenantV2SpecSideCarsContainersResources",
    "TenantV2SpecSideCarsContainersResourcesLimits",
    "TenantV2SpecSideCarsContainersResourcesRequests",
    "TenantV2SpecSideCarsContainersSecurityContext",
    "TenantV2SpecSideCarsContainersSecurityContextCapabilities",
    "TenantV2SpecSideCarsContainersSecurityContextSeLinuxOptions",
    "TenantV2SpecSideCarsContainersSecurityContextSeccompProfile",
    "TenantV2SpecSideCarsContainersSecurityContextWindowsOptions",
    "TenantV2SpecSideCarsContainersStartupProbe",
    "TenantV2SpecSideCarsContainersStartupProbeExec",
    "TenantV2SpecSideCarsContainersStartupProbeHttpGet",
    "TenantV2SpecSideCarsContainersStartupProbeHttpGetHttpHeaders",
    "TenantV2SpecSideCarsContainersStartupProbeHttpGetPort",
    "TenantV2SpecSideCarsContainersStartupProbeTcpSocket",
    "TenantV2SpecSideCarsContainersStartupProbeTcpSocketPort",
    "TenantV2SpecSideCarsContainersVolumeDevices",
    "TenantV2SpecSideCarsContainersVolumeMounts",
    "TenantV2SpecSideCarsVolumeClaimTemplates",
    "TenantV2SpecSideCarsVolumeClaimTemplatesMetadata",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpec",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecDataSource",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResources",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesLimits",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecResourcesRequests",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelector",
    "TenantV2SpecSideCarsVolumeClaimTemplatesSpecSelectorMatchExpressions",
    "TenantV2SpecSideCarsVolumeClaimTemplatesStatus",
    "TenantV2SpecSideCarsVolumeClaimTemplatesStatusCapacity",
    "TenantV2SpecSideCarsVolumeClaimTemplatesStatusConditions",
    "TenantV2SpecSideCarsVolumes",
    "TenantV2SpecSideCarsVolumesAwsElasticBlockStore",
    "TenantV2SpecSideCarsVolumesAzureDisk",
    "TenantV2SpecSideCarsVolumesAzureFile",
    "TenantV2SpecSideCarsVolumesCephfs",
    "TenantV2SpecSideCarsVolumesCephfsSecretRef",
    "TenantV2SpecSideCarsVolumesCinder",
    "TenantV2SpecSideCarsVolumesCinderSecretRef",
    "TenantV2SpecSideCarsVolumesConfigMap",
    "TenantV2SpecSideCarsVolumesConfigMapItems",
    "TenantV2SpecSideCarsVolumesCsi",
    "TenantV2SpecSideCarsVolumesCsiNodePublishSecretRef",
    "TenantV2SpecSideCarsVolumesDownwardApi",
    "TenantV2SpecSideCarsVolumesDownwardApiItems",
    "TenantV2SpecSideCarsVolumesDownwardApiItemsFieldRef",
    "TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRef",
    "TenantV2SpecSideCarsVolumesDownwardApiItemsResourceFieldRefDivisor",
    "TenantV2SpecSideCarsVolumesEmptyDir",
    "TenantV2SpecSideCarsVolumesEmptyDirSizeLimit",
    "TenantV2SpecSideCarsVolumesEphemeral",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplate",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateMetadata",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpec",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecDataSource",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResources",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelector",
    "TenantV2SpecSideCarsVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions",
    "TenantV2SpecSideCarsVolumesFc",
    "TenantV2SpecSideCarsVolumesFlexVolume",
    "TenantV2SpecSideCarsVolumesFlexVolumeSecretRef",
    "TenantV2SpecSideCarsVolumesFlocker",
    "TenantV2SpecSideCarsVolumesGcePersistentDisk",
    "TenantV2SpecSideCarsVolumesGitRepo",
    "TenantV2SpecSideCarsVolumesGlusterfs",
    "TenantV2SpecSideCarsVolumesHostPath",
    "TenantV2SpecSideCarsVolumesIscsi",
    "TenantV2SpecSideCarsVolumesIscsiSecretRef",
    "TenantV2SpecSideCarsVolumesNfs",
    "TenantV2SpecSideCarsVolumesPersistentVolumeClaim",
    "TenantV2SpecSideCarsVolumesPhotonPersistentDisk",
    "TenantV2SpecSideCarsVolumesPortworxVolume",
    "TenantV2SpecSideCarsVolumesProjected",
    "TenantV2SpecSideCarsVolumesProjectedSources",
    "TenantV2SpecSideCarsVolumesProjectedSourcesConfigMap",
    "TenantV2SpecSideCarsVolumesProjectedSourcesConfigMapItems",
    "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApi",
    "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItems",
    "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsFieldRef",
    "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRef",
    "TenantV2SpecSideCarsVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor",
    "TenantV2SpecSideCarsVolumesProjectedSourcesSecret",
    "TenantV2SpecSideCarsVolumesProjectedSourcesSecretItems",
    "TenantV2SpecSideCarsVolumesProjectedSourcesServiceAccountToken",
    "TenantV2SpecSideCarsVolumesQuobyte",
    "TenantV2SpecSideCarsVolumesRbd",
    "TenantV2SpecSideCarsVolumesRbdSecretRef",
    "TenantV2SpecSideCarsVolumesScaleIo",
    "TenantV2SpecSideCarsVolumesScaleIoSecretRef",
    "TenantV2SpecSideCarsVolumesSecret",
    "TenantV2SpecSideCarsVolumesSecretItems",
    "TenantV2SpecSideCarsVolumesStorageos",
    "TenantV2SpecSideCarsVolumesStorageosSecretRef",
    "TenantV2SpecSideCarsVolumesVsphereVolume",
    "TenantV2SpecUsers",
]

publication.publish()
