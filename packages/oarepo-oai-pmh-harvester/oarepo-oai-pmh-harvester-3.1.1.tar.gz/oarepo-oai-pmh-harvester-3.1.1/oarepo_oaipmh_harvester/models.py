from __future__ import absolute_import, print_function

import json
import traceback
from enum import Enum

from invenio_db import db
import sqlalchemy_utils

from sqlalchemy.orm.attributes import flag_modified

import logging

log = logging.getLogger('oarepo_oaipmh_harvester')


class OAIHarvesterConfig(db.Model):
    """Represents a OAIHarvester."""

    __tablename__ = 'oarepo_oaipmh_harvester'

    id = db.Column(db.Integer, primary_key=True)
    """automatic id"""

    code = db.Column(db.String(255), nullable=False, unique=True)
    """Server code, must be unique, is written to the records"""

    baseurl = db.Column(db.String(255), nullable=False, server_default='')
    """OAI server base url"""
    metadataprefix = db.Column(db.String(255), nullable=False,
                               server_default='oai_dc')
    """OAI server metadata prefix"""

    comment = db.Column(db.Text, nullable=True)
    """A comment (just for administration)"""

    name = db.Column(db.String(255), nullable=False)
    """The name of the server (just for administration)"""

    setspecs = db.Column(db.Text, nullable=False)
    """Which sets should be harvested"""

    parser = db.Column(db.Text, nullable=True)
    """A python class that parses the metadata in XML into an intermediary json representation. 
    Leave empty for built-in parser"""

    transformer = db.Column(db.Text, nullable=False)
    """A python class that transforms the intermediary json representation into a record."""

    max_records = db.Column(db.Integer, default=50000000)
    """In one round, fetch at most this number of records"""

    batch_size = db.Column(db.Integer, default=50)
    """Group records for processing, depends on memory size. SQLite gets progressively slow as this number increases,
    so it is a compromise between database speed on bigger transactions and elasticsearch indexing/searching speed"""

    runs = db.relationship("OAIHarvestRun", back_populates="harvester")
    """Reference to runs of this harvester"""

    def save(self):
        """Save object to persistent storage."""
        with db.session.begin_nested():
            db.session.merge(self)

    def get_last_record_date(self):
        last_run = OAIHarvestRun.query.filter_by(harvester=self).order_by(OAIHarvestRun.last_datestamp.desc()).first()
        if last_run:
            return last_run.last_datestamp
        return None


class HarvestStatus(Enum):
    RUNNING = 'R'
    FINISHED = 'O'
    WARNING = 'W'
    FAILED = 'E'
    INTERRUPTED = 'I'


class OAIHarvestRun(db.Model):
    """Represents a Run of oai harvester."""

    __tablename__ = 'oarepo_oaipmh_harvester_run'

    id = db.Column(db.Integer, primary_key=True)
    """autogenerated primary key"""

    harvester_id = db.Column(db.Integer, db.ForeignKey('oarepo_oaipmh_harvester.id'))
    harvester = db.relationship("OAIHarvesterConfig", back_populates="runs")
    """harvester for this run"""

    started = db.Column(db.DateTime, nullable=True)
    """When the run has started"""

    finished = db.Column(db.DateTime, nullable=True)
    """When the run has finished"""

    first_datestamp = db.Column(db.String(length=32), nullable=True)
    """Timestamp of the last retrieved record"""

    last_datestamp = db.Column(db.String(length=32), nullable=True)
    """Timestamp of the last retrieved record"""

    batches = db.relationship("OAIHarvestRunBatch", back_populates="run")
    """Reference to runs of this harvester"""

    status = db.Column(sqlalchemy_utils.ChoiceType(HarvestStatus, impl=db.String(length=1)))
    """Status of this run"""

    exception = db.Column(db.Text, nullable=True)
    """Exception during the processing"""


class OAIHarvestRunBatch(db.Model):
    __tablename__ = 'oarepo_oaipmh_harvester_batch'

    id = db.Column(db.Integer, primary_key=True)
    """autogenerated primary key"""

    run_id = db.Column(db.Integer, db.ForeignKey('oarepo_oaipmh_harvester_run.id'))
    run = db.relationship("OAIHarvestRun", back_populates="batches")
    """harvester run for this batch"""

    harvested_records = db.Column(sqlalchemy_utils.types.json.JSONType(), default=list)
    """OAI ids of the records harvested in this run (that is those written to the database without errors). 
    This is an array of oaipmh ids."""

    warning_records = db.Column(sqlalchemy_utils.types.json.JSONType(), default=dict)
    """OAI ids of the records harvested in this run (that is those written to the database but with some warnings. 
    Those are specified in the oarepo:validity section). This is a dict where key is oaipmh id and value is 
    a list of objects containing:
      * warning type in the 'type' property
      * warning message in the 'message' property 
      * (and other properties depending on the warning).
    """

    failed_records = db.Column(sqlalchemy_utils.types.json.JSONType(), default=dict)
    """OAI ids of the records rejected in this run (validation errors preventing db storage). 
    This is a dict where key is oaipmh id and value is 
    a list of objects containing: 
      * error type in the 'type' property 
      * error message in the 'message' property 
      * (and other properties depending on the error).
    """

    started = db.Column(db.DateTime, nullable=True)
    """When the run has started"""

    finished = db.Column(db.DateTime, nullable=True)
    """When the run has finished"""

    status = db.Column(sqlalchemy_utils.ChoiceType(HarvestStatus, impl=db.String(length=1)))
    """Status of this batch"""

    exception = db.Column(db.Text, nullable=True)
    """Exception during the processing - this is a global exception, not an exception when processing a single record
    - these are in the warning_records / failed records"""

    def add_error(self, message):
        if not self.exception:
            self.exception = message
        else:
            self.exception += "\n" + message
        self.status = HarvestStatus.FAILED

    def record_harvested(self, oai_identifier):
        self.harvested_records.append(oai_identifier)
        flag_modified(self, 'harvested_records')

    def record_warning(self, oai_identifier, warning_type, warning_message, record=None, **kwargs):
        self.warning_records.setdefault(oai_identifier, []).append({
            'type': warning_type,
            'message': (warning_message or '')[:256],
            'record': record.identifier if record else None,
            **kwargs
        })
        self._log_error_to_terminal(record)
        if self.status != HarvestStatus.FAILED:
            self.status = HarvestStatus.WARNING
        flag_modified(self, 'warning_records')

    def record_error(self, oai_identifier, error_type, error_message, record=None, **kwargs):
        self.failed_records.setdefault(oai_identifier, []).append({
            'type': error_type,
            'message': (error_message or '')[:256],
            'record': record.identifier if record else None,
            **kwargs
        })
        self._log_error_to_terminal(record)
        self.status = HarvestStatus.FAILED
        flag_modified(self, 'failed_records')

    def record_exception(self, oai_identifier, exception, record=None, **kwargs):
        self.failed_records.setdefault(oai_identifier, []).append({
            'type': 'exception',
            'message': str(exception)[:256],
            'stacktrace': ''.join(
                traceback.TracebackException.from_exception(exception, capture_locals=False).format()),
            'record': record.identifier if record else None,
            **kwargs
        })
        self._log_error_to_terminal(record, exception)
        self.status = HarvestStatus.FAILED
        flag_modified(self, 'failed_records')

    def _log_error_to_terminal(self, record, exception=None):
        if record:
            log.error("Failed record with identifier %s:\n\n----- parsed ----\n%s\n\n---- transformed ------\n%s\n\n-------",
                      record.identifier,
                      json.dumps(record.data, ensure_ascii=False, indent=4, default=lambda x: str(x)),
                      json.dumps(record.transformed, ensure_ascii=False, indent=4, default=lambda x: str(x)))
        if exception:
            log.exception('%s', str(exception))

    def add_exception(self, exception):
        message = ''.join(traceback.TracebackException.from_exception(exception, capture_locals=False).format())
        if not self.exception:
            self.exception = message
        else:
            self.exception += "\n" + message
        self.status = HarvestStatus.FAILED


__all__ = ('OAIHarvesterConfig', 'OAIHarvestRun', 'OAIHarvestRunBatch', 'HarvestStatus')
