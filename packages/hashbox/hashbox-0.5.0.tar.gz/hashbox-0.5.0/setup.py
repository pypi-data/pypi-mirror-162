# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['hashbox', 'hashbox.frozen', 'hashbox.mutable']

package_data = \
{'': ['*']}

install_requires = \
['cykhash>=2.0.0,<3.0.0', 'numpy>=1.14,<2.0', 'sortednp>=0.4.0,<0.5.0']

setup_kwargs = {
    'name': 'hashbox',
    'version': '0.5.0',
    'description': 'Find Python objects by exact match on their attributes.',
    'long_description': '# HashBox\n\nContainer for finding Python objects by matching attributes. \n\nUses hash-based methods for storage and retrieval, so find is very fast.\n\n```\npip install hashbox\n```\n\n\n[![tests Actions Status](https://github.com/manimino/hashbox/workflows/tests/badge.svg)](https://github.com/manimino/hashbox/actions)\n[![Coverage - 100%](https://img.shields.io/static/v1?label=Coverage&message=100%&color=2ea44f)](test/cov.txt)\n[![license - MIT](https://img.shields.io/static/v1?label=license&message=MIT&color=2ea44f)](/LICENSE)\n![python - 3.7+](https://img.shields.io/static/v1?label=python&message=3.7%2B&color=2ea44f)\n\n\n### Usage:\n\n```\nfrom hashbox import HashBox\n\nobjects = [\n    {\'a\': 1, \'b\': 2}, \n    {\'a\': 1, \'b\': 3}\n]\n\nhb = HashBox(\n    objects,\n    on=[\'a\', \'b\']\n)\n\nhb.find(\n    match={\'a\': 1}, \n    exclude={\'b\': 3}\n)  \n# result: [{\'a\': 1, \'b\': 2}]\n```\n\nThe objects can be any type: class instances, namedtuples, dicts, strings, floats, ints, etc.\n\nThere are two classes available.\n - HashBox: can `add()` and `remove()` objects.\n - FrozenHashBox: faster finds, lower memory usage, and immutable.\n\n____\n\n## Examples\n\nExpand for sample code.\n\n<details>\n<summary>Specify a list of values for an attribute to include / exclude values in the list</summary>\n<br>\n\n\n```\nfrom hashbox import HashBox\n\nobjects = [\n    {\'order\': 1, \'size\': \'regular\', \'topping\': \'smothered\'}, \n    {\'order\': 2, \'size\': \'regular\', \'topping\': \'diced\'}, \n    {\'order\': 3, \'size\': \'large\', \'topping\': \'covered\'},\n    {\'order\': 4, \'size\': \'triple\', \'topping\': \'chunked\'}\n]\n\nhb = HashBox(objects, on=[\'size\', \'topping\'])\n\nhb.find(\n    match={\'size\': [\'regular\', \'large\']},  # match anything with size in [\'regular\', \'large\'] \n    exclude={\'topping\': \'diced\'}           # exclude where topping is \'diced\'\n)  # result: orders 1 and 3\n\nhb.find(\n    match={},                               # match all objects\n    exclude={\'size\': [\'regular\', \'large\']}  # where size is not in [\'regular\', \'large\']\n)  # result: order 4\n\n```\n</details>\n\n<details>\n<summary>Define a function to access nested attributes</summary>\n\n\n```\nfrom hashbox import HashBox\n\nclass Order:\n    def __init__(self, num, size, toppings):\n        self.num = num\n        self.size = size\n        self.toppings = toppings\n        \n    def __repr__(self):\n        return f"order: {self.num}, size: \'{self.size}\', toppings: {self.toppings}"\n    \nobjects = [\n    Order(1, \'regular\', [\'scattered\', \'smothered\', \'covered\']),\n    Order(2, \'large\', [\'scattered\', \'covered\', \'peppered\']),\n    Order(3, \'large\', [\'scattered\', \'diced\', \'chunked\']),\n    Order(4, \'triple\', [\'all the way\']),\n]\n\ndef has_cheese(obj):\n    return \'covered\' in obj.toppings or \'all the way\' in obj.toppings\n\nhb = HashBox(objects, [\'size\', has_cheese])\n\n# returns orders 1, 2 and 4\nhb.find({has_cheese: True})  \n```\n</details>\n\n\n<details>\n<summary>Derived attributes</summary>\n<br />\nFind-by-function is very powerful. Here we find string objects with certain characteristics.\n\n```\nfrom hashbox import FrozenHashBox\n\nobjects = [\'mushrooms\', \'peppers\', \'onions\']\n\ndef o_count(obj):\n    return obj.count(\'o\')\n\nf = FrozenHashBox(objects, [o_count, len])\nf.find({len: 6})       # returns [\'onions\']\nf.find({o_count: 2})   # returns [\'mushrooms\', \'onions\']\n```\n</details>\n\n<details>\n<summary>Handling missing attributes</summary>\n\n- Objects that are missing an attribute will not be stored under that attribute. This saves lots of memory.\n- To find all objects that have an attribute, match the special value ANY. \n- To find objects missing the attribute, exclude ANY.\n- In functions, raise MissingAttribute to tell HashBox the object is missing.\n\n```\nfrom hashbox import HashBox, ANY\nfrom hashbox.exceptions import MissingAttribute\n\ndef get_a(obj):\n    try:\n        return obj[\'a\']\n    except KeyError:\n        raise MissingAttribute  # tell HashBox this attribute is missing\n\nobjs = [{\'a\': 1}, {\'a\': 2}, {}]\nhb = HashBox(objs, [\'a\', get_a])\n\nhb.find({\'a\': ANY})          # result: [{\'a\': 1}, {\'a\': 2}]\nhb.find({get_a: ANY})        # result: [{\'a\': 1}, {\'a\': 2}]\nhb.find(exclude={\'a\': ANY})  # result: [{}]\n```\n</details>\n\n### Recipes\n \n - [Auto-updating](https://github.com/manimino/hashbox/blob/main/examples/update.py) - Keep HashBox updated when attribute values change\n - [Wordle solver](https://github.com/manimino/hashbox/blob/main/examples/wordle.ipynb) - Demonstrates using `functools.partials` to make attribute functions\n - [Collision detection](https://github.com/manimino/hashbox/blob/main/examples/collision.py) - Find objects based on type and proximity (grid-based)\n - [Percentiles](https://github.com/manimino/hashbox/blob/main/examples/percentile.py) - Find by percentile (median, p99, etc.)\n\n____\n\n## Performance\n\nDemo: [HashBox going 5x~10x faster than SQLite](https://github.com/manimino/hashbox/blob/main/examples/perf_demo.ipynb)\n\n____\n\n## How it works\n\nIn HashBox, each attribute is a dict of sets: `{attribute value: set(object IDs)}`. \nOn `find()`, object IDs are retrieved for each attribute value. Then, set operations are applied to get the final\nobject ID set. Last, the object IDs are mapped to objects, which are then returned.\n\nFrozenHashBox uses arrays instead of sets, thanks to its immutability constraint. It stores a numpy array \nof objects. Attribute values map to indices in the object array. On `find()`, the array indices for each match are \nretrieved. Then, set operations provided by [sortednp](https://pypi.org/project/sortednp/) are used to get a \nfinal set of object array indices. Last, the objects are retrieved from the object array by index and returned.\n\n### Related projects\n\nHashBox is a type of inverted index. It is optimized for its goal of finding in-memory Python objects.\n\nOther Python inverted index implementations are aimed at things like [vector search](https://pypi.org/project/rii/) and\n[finding documents by words](https://pypi.org/project/nltk/). Outside of Python, ElasticSearch is a popular inverted\nindex search tool. Each of these has goals outside of HashBox\'s niche; there are no plans to expand HashBox towards\nthese functions.\n\n____\n\n<div align="center">\n  <img src="https://github.com/manimino/hashbox/blob/main/img/hashbox-logo.png"><br>\n</div>\n',
    'author': 'Theo Walker',
    'author_email': 'theo.ca.walker@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/manimino/hashbox/',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
